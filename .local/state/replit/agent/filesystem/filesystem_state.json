{"file_contents":{"views/zones_alerts.py":{"content":"import streamlit as st\nfrom database import get_db_session, Building, Floor, Gateway, Beacon, Position, Zone, ZoneAlert, CoverageZone\nfrom datetime import datetime, timedelta\nfrom io import BytesIO\nfrom PIL import Image\nimport plotly.graph_objects as go\nimport base64\nimport json\nimport math\nfrom utils.mqtt_publisher import get_mqtt_publisher\n\n\ndef point_in_zone(x, y, zone):\n    \"\"\"Check if a point is inside a zone rectangle (legacy for Zone model)\"\"\"\n    return zone.x_min <= x <= zone.x_max and zone.y_min <= y <= zone.y_max\n\n\ndef point_in_polygon(x, y, polygon_coords):\n    \"\"\"Check if a point is inside a polygon using ray casting algorithm\"\"\"\n    if isinstance(polygon_coords, str):\n        try:\n            polygon_coords = json.loads(polygon_coords)\n        except:\n            return False\n    \n    if not polygon_coords or len(polygon_coords) < 3:\n        return False\n    \n    n = len(polygon_coords)\n    inside = False\n    \n    j = n - 1\n    for i in range(n):\n        xi, yi = polygon_coords[i][0], polygon_coords[i][1]\n        xj, yj = polygon_coords[j][0], polygon_coords[j][1]\n        \n        if ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi):\n            inside = not inside\n        j = i\n    \n    return inside\n\n\ndef latlon_to_meters(lat, lon, origin_lat, origin_lon):\n    \"\"\"Convert lat/lon to local meter coordinates using equirectangular projection\"\"\"\n    dx = (lon - origin_lon) * math.cos(math.radians(origin_lat)) * 111000\n    dy = (lat - origin_lat) * 111000\n    return dx, dy\n\n\ndef get_geojson_bounds(floor):\n    \"\"\"Calculate the actual coordinate bounds of the GeoJSON floor plan in meters\"\"\"\n    if not floor.floor_plan_geojson or not floor.origin_lat or not floor.origin_lon:\n        return None\n    \n    try:\n        geojson_data = json.loads(floor.floor_plan_geojson)\n        all_x = []\n        all_y = []\n        \n        origin_lat = float(floor.origin_lat)\n        origin_lon = float(floor.origin_lon)\n        \n        for feature in geojson_data.get('features', []):\n            geom = feature.get('geometry', {})\n            geom_type = geom.get('type', '')\n            \n            coords_list = []\n            if geom_type == 'Polygon':\n                coords_list = geom.get('coordinates', [[]])[0]\n            elif geom_type == 'LineString':\n                coords_list = geom.get('coordinates', [])\n            elif geom_type == 'MultiPolygon':\n                for poly in geom.get('coordinates', []):\n                    if poly:\n                        coords_list.extend(poly[0])\n            \n            for c in coords_list:\n                if len(c) >= 2:\n                    lon, lat = c[0], c[1]\n                    x, y = latlon_to_meters(lat, lon, origin_lat, origin_lon)\n                    all_x.append(x)\n                    all_y.append(y)\n        \n        if all_x and all_y:\n            return {\n                'x_min': min(all_x),\n                'x_max': max(all_x),\n                'y_min': min(all_y),\n                'y_max': max(all_y)\n            }\n    except Exception:\n        pass\n    \n    return None\n\n\ndef render_geojson_floor_plan(fig, floor):\n    \"\"\"Render GeoJSON floor plan as Plotly traces in meter coordinates\"\"\"\n    if not floor.floor_plan_geojson or not floor.origin_lat or not floor.origin_lon:\n        return False\n    \n    try:\n        geojson_data = json.loads(floor.floor_plan_geojson)\n        \n        for feature in geojson_data.get('features', []):\n            props = feature.get('properties', {})\n            geom = feature.get('geometry', {})\n            geom_type = props.get('geomType', '')\n            \n            if geom_type == 'room' and geom.get('type') == 'Polygon':\n                coords = geom.get('coordinates', [[]])[0]\n                if coords:\n                    xs = []\n                    ys = []\n                    for c in coords:\n                        lon, lat = c[0], c[1]\n                        x, y = latlon_to_meters(lat, lon, float(floor.origin_lat), float(floor.origin_lon))\n                        xs.append(x)\n                        ys.append(y)\n                    \n                    name = props.get('name', 'Unnamed')\n                    \n                    fig.add_trace(go.Scatter(\n                        x=xs,\n                        y=ys,\n                        fill='toself',\n                        fillcolor='rgba(46, 92, 191, 0.15)',\n                        line=dict(color='#2e5cbf', width=1),\n                        name=name,\n                        hovertemplate=f\"<b>{name}</b><extra></extra>\",\n                        mode='lines',\n                        showlegend=False\n                    ))\n                    \n                    center_x = sum(xs) / len(xs)\n                    center_y = sum(ys) / len(ys)\n                    fig.add_annotation(\n                        x=center_x,\n                        y=center_y,\n                        text=name[:12],\n                        showarrow=False,\n                        font=dict(size=8, color='#1a1a1a')\n                    )\n            \n            elif geom_type == 'wall' and geom.get('type') == 'LineString':\n                coords = geom.get('coordinates', [])\n                if coords:\n                    xs = []\n                    ys = []\n                    for c in coords:\n                        lon, lat = c[0], c[1]\n                        x, y = latlon_to_meters(lat, lon, float(floor.origin_lat), float(floor.origin_lon))\n                        xs.append(x)\n                        ys.append(y)\n                    \n                    wall_type = props.get('subType', 'inner')\n                    line_width = 2 if wall_type == 'outer' else 1\n                    \n                    fig.add_trace(go.Scatter(\n                        x=xs,\n                        y=ys,\n                        mode='lines',\n                        line=dict(color='#333', width=line_width),\n                        showlegend=False,\n                        hoverinfo='skip'\n                    ))\n        \n        return True\n    except Exception:\n        return False\n\n\ndef get_zones_figure(floor, zones, gateways_data, beacon_positions=None, editable=False, new_zone=None, bounds=None):\n    \"\"\"Create a plotly figure with floor plan, zones, and current positions\"\"\"\n    \n    fig = go.Figure()\n    has_floor_plan = False\n    \n    if bounds is None:\n        bounds = get_geojson_bounds(floor)\n    \n    if floor.floor_plan_image:\n        try:\n            image = Image.open(BytesIO(floor.floor_plan_image))\n            \n            buffered = BytesIO()\n            image.save(buffered, format=\"PNG\")\n            img_str = base64.b64encode(buffered.getvalue()).decode()\n            \n            fig.add_layout_image(\n                dict(\n                    source=f\"data:image/png;base64,{img_str}\",\n                    xref=\"x\",\n                    yref=\"y\",\n                    x=0,\n                    y=float(floor.height_meters),\n                    sizex=float(floor.width_meters),\n                    sizey=float(floor.height_meters),\n                    sizing=\"stretch\",\n                    opacity=0.9,\n                    layer=\"below\"\n                )\n            )\n            has_floor_plan = True\n        except Exception:\n            pass\n    \n    if not has_floor_plan and floor.floor_plan_geojson:\n        has_floor_plan = render_geojson_floor_plan(fig, floor)\n    \n    for zone in zones:\n        # Check if zone is a CoverageZone (polygon) or Zone (rectangle)\n        if hasattr(zone, 'polygon_coords') and zone.polygon_coords:\n            # Render as polygon\n            try:\n                coords = json.loads(zone.polygon_coords) if isinstance(zone.polygon_coords, str) else zone.polygon_coords\n                if coords and len(coords) >= 3:\n                    xs = [c[0] for c in coords] + [coords[0][0]]\n                    ys = [c[1] for c in coords] + [coords[0][1]]\n                    \n                    color = zone.color if zone.color else '#2e5cbf'\n                    fig.add_trace(go.Scatter(\n                        x=xs, y=ys,\n                        fill='toself',\n                        fillcolor=color.replace('#', 'rgba(') + ',0.25)' if color.startswith('#') else f'rgba(46,92,191,0.25)',\n                        line=dict(color=color, width=2),\n                        mode='lines',\n                        name=zone.name,\n                        showlegend=False,\n                        hovertemplate=f'{zone.name}<extra></extra>'\n                    ))\n                    \n                    center_x = sum([c[0] for c in coords]) / len(coords)\n                    center_y = sum([c[1] for c in coords]) / len(coords)\n                    fig.add_annotation(\n                        x=center_x,\n                        y=center_y,\n                        text=zone.name,\n                        showarrow=False,\n                        font=dict(size=11, color=color)\n                    )\n            except:\n                pass\n        else:\n            # Render as rectangle (legacy Zone model)\n            fig.add_shape(\n                type=\"rect\",\n                x0=zone.x_min,\n                y0=zone.y_min,\n                x1=zone.x_max,\n                y1=zone.y_max,\n                line=dict(color=zone.color, width=2),\n                fillcolor=zone.color,\n                opacity=0.3,\n                name=zone.name\n            )\n            \n            fig.add_annotation(\n                x=(zone.x_min + zone.x_max) / 2,\n                y=zone.y_max + 0.5,\n                text=zone.name,\n                showarrow=False,\n                font=dict(size=12, color=zone.color)\n            )\n    \n    if new_zone:\n        fig.add_shape(\n            type=\"rect\",\n            x0=new_zone['x_min'],\n            y0=new_zone['y_min'],\n            x1=new_zone['x_max'],\n            y1=new_zone['y_max'],\n            line=dict(color=new_zone.get('color', '#FF0000'), width=3, dash='dash'),\n            fillcolor=new_zone.get('color', '#FF0000'),\n            opacity=0.4,\n            name=\"New Zone (Preview)\"\n        )\n        \n        fig.add_annotation(\n            x=(new_zone['x_min'] + new_zone['x_max']) / 2,\n            y=(new_zone['y_min'] + new_zone['y_max']) / 2,\n            text=new_zone.get('name', 'New Zone'),\n            showarrow=False,\n            font=dict(size=14, color='white'),\n            bgcolor=new_zone.get('color', '#FF0000'),\n            bordercolor=new_zone.get('color', '#FF0000'),\n            borderwidth=1\n        )\n    \n    for gw in gateways_data:\n        fig.add_trace(go.Scatter(\n            x=[gw['x']],\n            y=[gw['y']],\n            mode='markers',\n            marker=dict(size=10, color='blue', symbol='square'),\n            name=f\"Gateway: {gw['name']}\",\n            showlegend=False\n        ))\n    \n    if beacon_positions:\n        colors = ['red', 'green', 'orange', 'purple', 'cyan', 'magenta']\n        for idx, (beacon_name, pos) in enumerate(beacon_positions.items()):\n            color = colors[idx % len(colors)]\n            fig.add_trace(go.Scatter(\n                x=[pos['x']],\n                y=[pos['y']],\n                mode='markers+text',\n                marker=dict(size=12, color=color),\n                text=[beacon_name],\n                textposition='bottom center',\n                name=beacon_name\n            ))\n    \n    if bounds:\n        x_min_range = bounds['x_min'] - 2\n        x_max_range = bounds['x_max'] + 2\n        y_min_range = bounds['y_min'] - 2\n        y_max_range = bounds['y_max'] + 2\n        w = bounds['x_max'] - bounds['x_min']\n        h = bounds['y_max'] - bounds['y_min']\n    else:\n        x_min_range = 0\n        x_max_range = float(floor.width_meters)\n        y_min_range = 0\n        y_max_range = float(floor.height_meters)\n        w = x_max_range\n        h = y_max_range\n    \n    fig.update_layout(\n        xaxis=dict(\n            range=[x_min_range, x_max_range],\n            title=\"X (meters)\",\n            showgrid=not has_floor_plan,\n            zeroline=False,\n            constrain='domain',\n            dtick=max(1, int(w // 8))\n        ),\n        yaxis=dict(\n            range=[y_min_range, y_max_range],\n            title=\"Y (meters)\",\n            showgrid=not has_floor_plan,\n            zeroline=False,\n            scaleanchor=\"x\",\n            scaleratio=1,\n            dtick=max(1, int(h // 8))\n        ),\n        showlegend=True,\n        legend=dict(x=1.02, y=1, bgcolor='rgba(255,255,255,0.8)'),\n        margin=dict(l=50, r=150, t=50, b=50),\n        height=500,\n        plot_bgcolor='rgba(240,240,240,0.3)' if not has_floor_plan else 'rgba(255,255,255,0)'\n    )\n    \n    return fig\n\n\ndef check_zone_transitions(session, floor_id):\n    \"\"\"Check for beacon zone entry/exit events using CoverageZone polygons\"\"\"\n    zones = session.query(CoverageZone).filter(\n        CoverageZone.floor_id == floor_id,\n        CoverageZone.is_active == True\n    ).all()\n    \n    if not zones:\n        return []\n    \n    alerts = []\n    thirty_seconds_ago = datetime.utcnow() - timedelta(seconds=30)\n    \n    beacons = session.query(Beacon).filter(Beacon.is_active == True).all()\n    \n    for beacon in beacons:\n        positions = session.query(Position).filter(\n            Position.beacon_id == beacon.id,\n            Position.floor_id == floor_id,\n            Position.timestamp >= thirty_seconds_ago\n        ).order_by(Position.timestamp.desc()).limit(2).all()\n        \n        if len(positions) < 2:\n            continue\n        \n        current_pos = positions[0]\n        prev_pos = positions[1]\n        \n        for zone in zones:\n            was_in_zone = point_in_polygon(prev_pos.x_position, prev_pos.y_position, zone.polygon_coords)\n            is_in_zone = point_in_polygon(current_pos.x_position, current_pos.y_position, zone.polygon_coords)\n            \n            if not was_in_zone and is_in_zone and zone.alert_on_enter:\n                alerts.append({\n                    'type': 'enter',\n                    'zone': zone.name,\n                    'beacon': beacon.name,\n                    'time': datetime.utcnow()\n                })\n                \n                publisher = get_mqtt_publisher()\n                if publisher.is_connected():\n                    floor = session.query(Floor).filter(Floor.id == zone.floor_id).first()\n                    floor_name = floor.name if floor else \"\"\n                    publisher.publish_alert(\n                        alert_type='enter',\n                        beacon_mac=beacon.mac_address,\n                        beacon_name=beacon.name,\n                        zone_id=zone.id,\n                        zone_name=zone.name,\n                        floor_name=floor_name,\n                        x=current_pos.x_position,\n                        y=current_pos.y_position,\n                        resource_type=beacon.resource_type\n                    )\n            \n            elif was_in_zone and not is_in_zone and zone.alert_on_exit:\n                alerts.append({\n                    'type': 'exit',\n                    'zone': zone.name,\n                    'beacon': beacon.name,\n                    'time': datetime.utcnow()\n                })\n                \n                publisher = get_mqtt_publisher()\n                if publisher.is_connected():\n                    floor = session.query(Floor).filter(Floor.id == zone.floor_id).first()\n                    floor_name = floor.name if floor else \"\"\n                    publisher.publish_alert(\n                        alert_type='exit',\n                        beacon_mac=beacon.mac_address,\n                        beacon_name=beacon.name,\n                        zone_id=zone.id,\n                        zone_name=zone.name,\n                        floor_name=floor_name,\n                        x=current_pos.x_position,\n                        y=current_pos.y_position,\n                        resource_type=beacon.resource_type\n                    )\n    \n    return alerts\n\n\ndef render():\n    st.title(\"Zones & Alerts\")\n    st.markdown(\"Define geofencing zones and monitor entry/exit alerts\")\n    \n    tab1, tab2, tab3 = st.tabs([\"Zone Management\", \"Live Monitoring\", \"Alert History\"])\n    \n    with tab1:\n        render_zone_management()\n    \n    with tab2:\n        render_live_monitoring()\n    \n    with tab3:\n        render_alert_history()\n\n\ndef render_zone_management():\n    with get_db_session() as session:\n        buildings = session.query(Building).all()\n        if not buildings:\n            st.warning(\"No buildings configured. Please add a building first.\")\n            return\n        \n        st.subheader(\"Create New Zone\")\n        \n        building_options = {b.name: b.id for b in buildings}\n        selected_building = st.selectbox(\"Building\", options=list(building_options.keys()), key=\"zone_building\")\n        \n        floors = session.query(Floor).filter(\n            Floor.building_id == building_options[selected_building]\n        ).order_by(Floor.floor_number).all()\n        \n        if not floors:\n            st.warning(\"No floor plans for this building.\")\n            return\n        \n        floor_options = {f\"Floor {f.floor_number}: {f.name or ''}\": f.id for f in floors}\n        selected_floor_key = st.selectbox(\"Floor\", options=list(floor_options.keys()), key=\"zone_floor\")\n        selected_floor_id = floor_options[selected_floor_key]\n        \n        floor = session.query(Floor).filter(Floor.id == selected_floor_id).first()\n        if not floor:\n            st.warning(\"Floor not found.\")\n            return\n        \n        existing_zones = session.query(Zone).filter(Zone.floor_id == selected_floor_id).all()\n        \n        gateways = session.query(Gateway).filter(\n            Gateway.floor_id == selected_floor_id,\n            Gateway.is_active == True\n        ).all()\n        gateways_data = [{'name': gw.name, 'x': float(gw.x_position), 'y': float(gw.y_position)} for gw in gateways]\n        \n        col_form, col_preview = st.columns([1, 2])\n        \n        geojson_bounds = get_geojson_bounds(floor)\n        \n        if geojson_bounds:\n            x_range_min = geojson_bounds['x_min']\n            x_range_max = geojson_bounds['x_max']\n            y_range_min = geojson_bounds['y_min']\n            y_range_max = geojson_bounds['y_max']\n            w = x_range_max - x_range_min\n            h = y_range_max - y_range_min\n        else:\n            x_range_min = 0.0\n            y_range_min = 0.0\n            x_range_max = float(floor.width_meters)\n            y_range_max = float(floor.height_meters)\n            w = x_range_max\n            h = y_range_max\n        \n        with col_form:\n            st.markdown(\"#### Zone Settings\")\n            \n            zone_name = st.text_input(\"Zone Name*\", placeholder=\"e.g., Restricted Area\", key=\"zone_name\")\n            description = st.text_area(\"Description\", placeholder=\"Zone description...\", key=\"zone_desc\", height=68)\n            color = st.color_picker(\"Zone Color\", \"#FF0000\", key=\"zone_color\")\n            \n            st.markdown(\"#### Zone Position\")\n            if geojson_bounds:\n                st.caption(f\"Floor area: X [{x_range_min:.1f} to {x_range_max:.1f}]m, Y [{y_range_min:.1f} to {y_range_max:.1f}]m\")\n            else:\n                st.caption(f\"Floor dimensions: {w:.1f}m x {h:.1f}m\")\n            \n            preset = st.selectbox(\n                \"Quick Presets\",\n                options=[\"Custom\", \"Top-Left Quarter\", \"Top-Right Quarter\", \"Bottom-Left Quarter\", \n                         \"Bottom-Right Quarter\", \"Center\", \"Left Half\", \"Right Half\", \"Top Half\", \"Bottom Half\"],\n                key=\"zone_preset\"\n            )\n            \n            mid_x = (x_range_min + x_range_max) / 2\n            mid_y = (y_range_min + y_range_max) / 2\n            \n            if preset == \"Top-Left Quarter\":\n                default_x_min, default_y_min = x_range_min, mid_y\n                default_x_max, default_y_max = mid_x, y_range_max\n            elif preset == \"Top-Right Quarter\":\n                default_x_min, default_y_min = mid_x, mid_y\n                default_x_max, default_y_max = x_range_max, y_range_max\n            elif preset == \"Bottom-Left Quarter\":\n                default_x_min, default_y_min = x_range_min, y_range_min\n                default_x_max, default_y_max = mid_x, mid_y\n            elif preset == \"Bottom-Right Quarter\":\n                default_x_min, default_y_min = mid_x, y_range_min\n                default_x_max, default_y_max = x_range_max, mid_y\n            elif preset == \"Center\":\n                default_x_min, default_y_min = x_range_min + w/4, y_range_min + h/4\n                default_x_max, default_y_max = x_range_max - w/4, y_range_max - h/4\n            elif preset == \"Left Half\":\n                default_x_min, default_y_min = x_range_min, y_range_min\n                default_x_max, default_y_max = mid_x, y_range_max\n            elif preset == \"Right Half\":\n                default_x_min, default_y_min = mid_x, y_range_min\n                default_x_max, default_y_max = x_range_max, y_range_max\n            elif preset == \"Top Half\":\n                default_x_min, default_y_min = x_range_min, mid_y\n                default_x_max, default_y_max = x_range_max, y_range_max\n            elif preset == \"Bottom Half\":\n                default_x_min, default_y_min = x_range_min, y_range_min\n                default_x_max, default_y_max = x_range_max, mid_y\n            else:\n                zone_w = min(10.0, w/3)\n                zone_h = min(10.0, h/3)\n                default_x_min = x_range_min + w/2 - zone_w/2\n                default_y_min = y_range_min + h/2 - zone_h/2\n                default_x_max = default_x_min + zone_w\n                default_y_max = default_y_min + zone_h\n            \n            col2a, col2b = st.columns(2)\n            with col2a:\n                x_min = st.number_input(\"X Min (m)\", value=default_x_min, min_value=x_range_min - 10, max_value=x_range_max + 10, step=0.5, key=\"x_min\")\n                y_min = st.number_input(\"Y Min (m)\", value=default_y_min, min_value=y_range_min - 10, max_value=y_range_max + 10, step=0.5, key=\"y_min\")\n            with col2b:\n                x_max = st.number_input(\"X Max (m)\", value=default_x_max, min_value=x_range_min - 10, max_value=x_range_max + 10, step=0.5, key=\"x_max\")\n                y_max = st.number_input(\"Y Max (m)\", value=default_y_max, min_value=y_range_min - 10, max_value=y_range_max + 10, step=0.5, key=\"y_max\")\n            \n            st.markdown(\"#### Alerts\")\n            col_alert1, col_alert2 = st.columns(2)\n            with col_alert1:\n                alert_on_enter = st.checkbox(\"Alert on Enter\", value=True, key=\"alert_enter\")\n            with col_alert2:\n                alert_on_exit = st.checkbox(\"Alert on Exit\", value=True, key=\"alert_exit\")\n            \n            if st.button(\"Create Zone\", type=\"primary\", use_container_width=True):\n                if not zone_name:\n                    st.error(\"Zone name is required\")\n                elif x_max <= x_min or y_max <= y_min:\n                    st.error(\"Max values must be greater than min values\")\n                else:\n                    zone = Zone(\n                        floor_id=selected_floor_id,\n                        name=zone_name,\n                        description=description,\n                        x_min=x_min,\n                        y_min=y_min,\n                        x_max=x_max,\n                        y_max=y_max,\n                        color=color,\n                        alert_on_enter=alert_on_enter,\n                        alert_on_exit=alert_on_exit,\n                        is_active=True\n                    )\n                    session.add(zone)\n                    st.success(f\"Zone '{zone_name}' created!\")\n                    st.rerun()\n        \n        with col_preview:\n            st.markdown(\"#### Floor Plan Preview\")\n            st.caption(\"The dashed rectangle shows where your new zone will be placed\")\n            \n            new_zone_preview = {\n                'x_min': x_min,\n                'y_min': y_min,\n                'x_max': x_max,\n                'y_max': y_max,\n                'color': color,\n                'name': zone_name or \"New Zone\"\n            }\n            \n            fig = get_zones_figure(floor, existing_zones, gateways_data, new_zone=new_zone_preview, bounds=geojson_bounds)\n            st.plotly_chart(fig, use_container_width=True, key=\"zone_preview_chart\")\n            \n            if existing_zones:\n                st.caption(f\"Existing zones shown in solid colors ({len(existing_zones)} zones)\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Existing Zones\")\n        \n        editing_zone_id = st.session_state.get('editing_zone_id', None)\n        \n        if editing_zone_id:\n            edit_zone = session.query(Zone).filter(Zone.id == editing_zone_id).first()\n            if edit_zone:\n                edit_floor = session.query(Floor).filter(Floor.id == edit_zone.floor_id).first()\n                if edit_floor:\n                    st.markdown(f\"### Editing Zone: {edit_zone.name}\")\n                    \n                    edit_bounds = get_geojson_bounds(edit_floor)\n                    if edit_bounds:\n                        ex_min, ex_max = edit_bounds['x_min'], edit_bounds['x_max']\n                        ey_min, ey_max = edit_bounds['y_min'], edit_bounds['y_max']\n                    else:\n                        ex_min, ey_min = 0.0, 0.0\n                        ex_max = float(edit_floor.width_meters)\n                        ey_max = float(edit_floor.height_meters)\n                    \n                    edit_col1, edit_col2 = st.columns([1, 2])\n                    \n                    with edit_col1:\n                        edit_name = st.text_input(\"Zone Name\", value=edit_zone.name, key=\"edit_zone_name\")\n                        edit_desc = st.text_area(\"Description\", value=edit_zone.description or \"\", key=\"edit_zone_desc\", height=68)\n                        edit_color = st.color_picker(\"Color\", value=edit_zone.color, key=\"edit_zone_color\")\n                        \n                        st.markdown(\"**Position**\")\n                        ecol1, ecol2 = st.columns(2)\n                        with ecol1:\n                            edit_x_min = st.number_input(\"X Min\", value=float(edit_zone.x_min), min_value=ex_min - 20, max_value=ex_max + 20, step=0.5, key=\"edit_x_min\")\n                            edit_y_min = st.number_input(\"Y Min\", value=float(edit_zone.y_min), min_value=ey_min - 20, max_value=ey_max + 20, step=0.5, key=\"edit_y_min\")\n                        with ecol2:\n                            edit_x_max = st.number_input(\"X Max\", value=float(edit_zone.x_max), min_value=ex_min - 20, max_value=ex_max + 20, step=0.5, key=\"edit_x_max\")\n                            edit_y_max = st.number_input(\"Y Max\", value=float(edit_zone.y_max), min_value=ey_min - 20, max_value=ey_max + 20, step=0.5, key=\"edit_y_max\")\n                        \n                        st.markdown(\"**Alerts**\")\n                        ecol3, ecol4 = st.columns(2)\n                        with ecol3:\n                            edit_alert_enter = st.checkbox(\"Alert on Enter\", value=bool(edit_zone.alert_on_enter), key=\"edit_alert_enter\")\n                        with ecol4:\n                            edit_alert_exit = st.checkbox(\"Alert on Exit\", value=bool(edit_zone.alert_on_exit), key=\"edit_alert_exit\")\n                        \n                        bcol1, bcol2, bcol3 = st.columns(3)\n                        with bcol1:\n                            if st.button(\"Save Changes\", type=\"primary\", key=\"save_edit\"):\n                                if not edit_name:\n                                    st.error(\"Zone name is required\")\n                                elif edit_x_max <= edit_x_min or edit_y_max <= edit_y_min:\n                                    st.error(\"Max values must be greater than min values\")\n                                else:\n                                    edit_zone.name = edit_name\n                                    edit_zone.description = edit_desc\n                                    edit_zone.color = edit_color\n                                    edit_zone.x_min = edit_x_min\n                                    edit_zone.y_min = edit_y_min\n                                    edit_zone.x_max = edit_x_max\n                                    edit_zone.y_max = edit_y_max\n                                    edit_zone.alert_on_enter = edit_alert_enter\n                                    edit_zone.alert_on_exit = edit_alert_exit\n                                    st.session_state['editing_zone_id'] = None\n                                    st.success(f\"Zone '{edit_name}' updated!\")\n                                    st.rerun()\n                        with bcol2:\n                            if st.button(\"Cancel\", key=\"cancel_edit\"):\n                                st.session_state['editing_zone_id'] = None\n                                st.rerun()\n                        with bcol3:\n                            if st.button(\"Delete Zone\", type=\"secondary\", key=\"delete_in_edit\"):\n                                session.delete(edit_zone)\n                                st.session_state['editing_zone_id'] = None\n                                st.success(f\"Zone '{edit_zone.name}' deleted!\")\n                                st.rerun()\n                    \n                    with edit_col2:\n                        st.markdown(\"**Preview**\")\n                        edit_gws = session.query(Gateway).filter(Gateway.floor_id == edit_floor.id, Gateway.is_active == True).all()\n                        edit_gw_data = [{'name': gw.name, 'x': float(gw.x_position), 'y': float(gw.y_position)} for gw in edit_gws]\n                        \n                        edit_preview = {\n                            'x_min': edit_x_min,\n                            'y_min': edit_y_min,\n                            'x_max': edit_x_max,\n                            'y_max': edit_y_max,\n                            'color': edit_color,\n                            'name': edit_name or \"Zone\"\n                        }\n                        \n                        other_zones = session.query(Zone).filter(Zone.floor_id == edit_floor.id, Zone.id != edit_zone.id).all()\n                        edit_fig = get_zones_figure(edit_floor, other_zones, edit_gw_data, new_zone=edit_preview, bounds=edit_bounds)\n                        st.plotly_chart(edit_fig, use_container_width=True, key=\"edit_zone_preview\")\n                    \n                    st.markdown(\"---\")\n        \n        zones = session.query(Zone).order_by(Zone.name).all()\n        \n        if zones:\n            zones_by_floor = {}\n            for zone in zones:\n                floor_obj = session.query(Floor).filter(Floor.id == zone.floor_id).first()\n                floor_key = f\"{floor_obj.name or f'Floor {floor_obj.floor_number}'}\" if floor_obj else \"Unknown\"\n                if floor_key not in zones_by_floor:\n                    zones_by_floor[floor_key] = []\n                zones_by_floor[floor_key].append((zone, floor_obj))\n            \n            for floor_name, floor_zones in zones_by_floor.items():\n                st.markdown(f\"**{floor_name}**\")\n                \n                for zone, floor_obj in floor_zones:\n                    status_icon = \"ðŸŸ¢\" if zone.is_active else \"ðŸ”´\"\n                    is_editing = editing_zone_id == zone.id\n                    \n                    with st.expander(f\"{status_icon} {zone.name}\" + (\" (editing)\" if is_editing else \"\"), expanded=is_editing):\n                        col1, col2, col3 = st.columns([2, 2, 1])\n                        \n                        with col1:\n                            st.write(f\"**Area:** ({float(zone.x_min):.1f}, {float(zone.y_min):.1f}) to ({float(zone.x_max):.1f}, {float(zone.y_max):.1f})\")\n                            st.write(f\"**Size:** {float(zone.x_max) - float(zone.x_min):.1f}m x {float(zone.y_max) - float(zone.y_min):.1f}m\")\n                            st.write(f\"**Description:** {zone.description or 'None'}\")\n                        \n                        with col2:\n                            st.write(f\"**Alert on Enter:** {'Yes' if zone.alert_on_enter else 'No'}\")\n                            st.write(f\"**Alert on Exit:** {'Yes' if zone.alert_on_exit else 'No'}\")\n                            st.markdown(f\"**Color:** <span style='background-color:{zone.color}; padding: 2px 10px; border-radius: 3px;'>&nbsp;</span> {zone.color}\", unsafe_allow_html=True)\n                        \n                        with col3:\n                            if st.button(\"Toggle Active\", key=f\"toggle_zone_{zone.id}\"):\n                                zone.is_active = not zone.is_active\n                                st.rerun()\n                            \n                            if not is_editing:\n                                if st.button(\"Edit\", key=f\"edit_zone_{zone.id}\", type=\"primary\"):\n                                    st.session_state['editing_zone_id'] = zone.id\n                                    st.rerun()\n                            \n                            if st.button(\"Delete\", key=f\"del_zone_{zone.id}\", type=\"secondary\"):\n                                session.delete(zone)\n                                if editing_zone_id == zone.id:\n                                    st.session_state['editing_zone_id'] = None\n                                st.success(f\"Zone '{zone.name}' deleted\")\n                                st.rerun()\n        else:\n            st.info(\"No zones created yet.\")\n\n\ndef render_live_monitoring():\n    with get_db_session() as session:\n        buildings = session.query(Building).all()\n        if not buildings:\n            st.warning(\"No buildings configured.\")\n            return\n        \n        col1, col2 = st.columns([1, 3])\n        \n        with col1:\n            st.subheader(\"Settings\")\n            \n            building_options = {b.name: b.id for b in buildings}\n            selected_building = st.selectbox(\"Building\", options=list(building_options.keys()), key=\"monitor_building\")\n            \n            floors = session.query(Floor).filter(\n                Floor.building_id == building_options[selected_building]\n            ).order_by(Floor.floor_number).all()\n            \n            if not floors:\n                st.warning(\"No floor plans.\")\n                return\n            \n            floor_options = {f\"Floor {f.floor_number}\": f.id for f in floors}\n            selected_floor_name = st.selectbox(\"Floor\", options=list(floor_options.keys()), key=\"monitor_floor\")\n            selected_floor_id = floor_options[selected_floor_name]\n            \n            auto_refresh = st.checkbox(\"Auto-refresh\", value=True, key=\"zone_auto_refresh\")\n            \n            if st.button(\"Check for Alerts\"):\n                new_alerts = check_zone_transitions(session, selected_floor_id)\n                if new_alerts:\n                    for alert in new_alerts:\n                        st.warning(f\"{alert['beacon']} {alert['type']}ed {alert['zone']}\")\n                else:\n                    st.info(\"No new zone transitions detected\")\n        \n        with col2:\n            floor = session.query(Floor).filter(Floor.id == selected_floor_id).first()\n            \n            # Use CoverageZone (polygons) instead of Zone (rectangles)\n            zones = session.query(CoverageZone).filter(\n                CoverageZone.floor_id == selected_floor_id,\n                CoverageZone.is_active == True\n            ).all()\n            \n            gateways = session.query(Gateway).filter(\n                Gateway.floor_id == selected_floor_id,\n                Gateway.is_active == True\n            ).all()\n            \n            gateways_data = [\n                {'name': gw.name, 'x': gw.x_position, 'y': gw.y_position}\n                for gw in gateways\n            ]\n            \n            five_seconds_ago = datetime.utcnow() - timedelta(seconds=5)\n            recent_positions = session.query(Position).filter(\n                Position.floor_id == selected_floor_id,\n                Position.timestamp >= five_seconds_ago\n            ).order_by(Position.timestamp.desc()).all()\n            \n            beacon_positions = {}\n            for pos in recent_positions:\n                beacon = session.query(Beacon).filter(Beacon.id == pos.beacon_id).first()\n                if beacon and beacon.name not in beacon_positions:\n                    beacon_positions[beacon.name] = {\n                        'x': pos.x_position,\n                        'y': pos.y_position\n                    }\n            \n            st.subheader(f\"Zone Map: {floor.name or f'Floor {floor.floor_number}'}\")\n            \n            fig = get_zones_figure(floor, zones, gateways_data, beacon_positions)\n            st.plotly_chart(fig, use_container_width=True)\n            \n            st.subheader(\"Current Zone Occupancy\")\n            \n            if zones and beacon_positions:\n                for zone in zones:\n                    beacons_in_zone = []\n                    for beacon_name, pos in beacon_positions.items():\n                        if point_in_polygon(pos['x'], pos['y'], zone.polygon_coords):\n                            beacons_in_zone.append(beacon_name)\n                    \n                    if beacons_in_zone:\n                        st.write(f\"**{zone.name}:** {', '.join(beacons_in_zone)}\")\n                    else:\n                        st.write(f\"**{zone.name}:** Empty\")\n            elif not zones:\n                st.info(\"No zones defined for this floor. Create zones in Coverage Zones.\")\n            else:\n                st.info(\"No beacons currently tracked on this floor.\")\n            \n            if auto_refresh:\n                import time\n                time.sleep(2)\n                st.rerun()\n\n\ndef render_alert_history():\n    with get_db_session() as session:\n        st.subheader(\"Alert History\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            filter_type = st.selectbox(\n                \"Filter by Type\",\n                options=[\"All\", \"Enter\", \"Exit\"]\n            )\n        \n        with col2:\n            filter_ack = st.selectbox(\n                \"Filter by Status\",\n                options=[\"All\", \"Unacknowledged\", \"Acknowledged\"]\n            )\n        \n        query = session.query(ZoneAlert).order_by(ZoneAlert.timestamp.desc())\n        \n        if filter_type != \"All\":\n            query = query.filter(ZoneAlert.alert_type == filter_type.lower())\n        \n        if filter_ack == \"Unacknowledged\":\n            query = query.filter(ZoneAlert.acknowledged == False)\n        elif filter_ack == \"Acknowledged\":\n            query = query.filter(ZoneAlert.acknowledged == True)\n        \n        alerts = query.limit(100).all()\n        \n        if alerts:\n            st.write(f\"**Total alerts shown:** {len(alerts)}\")\n            \n            if st.button(\"Acknowledge All Visible\"):\n                for alert in alerts:\n                    alert.acknowledged = True\n                st.success(\"All alerts acknowledged\")\n                st.rerun()\n            \n            for alert in alerts:\n                zone = session.query(Zone).filter(Zone.id == alert.zone_id).first()\n                beacon = session.query(Beacon).filter(Beacon.id == alert.beacon_id).first()\n                \n                icon = \"ðŸšª\" if alert.alert_type == \"enter\" else \"ðŸš¶\"\n                ack_icon = \"âœ“\" if alert.acknowledged else \"!\"\n                \n                with st.expander(\n                    f\"{icon} [{ack_icon}] {beacon.name if beacon else 'Unknown'} {alert.alert_type}ed {zone.name if zone else 'Unknown'} - {alert.timestamp.strftime('%Y-%m-%d %H:%M:%S')}\",\n                    expanded=False\n                ):\n                    col1, col2 = st.columns([3, 1])\n                    \n                    with col1:\n                        st.write(f\"**Zone:** {zone.name if zone else 'Unknown'}\")\n                        st.write(f\"**Beacon:** {beacon.name if beacon else 'Unknown'}\")\n                        st.write(f\"**Position:** ({alert.x_position:.2f}, {alert.y_position:.2f})\")\n                        st.write(f\"**Time:** {alert.timestamp}\")\n                    \n                    with col2:\n                        if not alert.acknowledged:\n                            if st.button(\"Acknowledge\", key=f\"ack_{alert.id}\"):\n                                alert.acknowledged = True\n                                st.rerun()\n        else:\n            st.info(\"No alerts recorded yet.\")\n","path":null,"size_bytes":40762,"size_tokens":null},"database/models.py":{"content":"from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, ForeignKey, Text, LargeBinary, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, relationship\nfrom datetime import datetime\nfrom contextlib import contextmanager\nimport os\n\nBase = declarative_base()\n\n_engine = None\n_SessionLocal = None\n\n\nclass Building(Base):\n    \"\"\"Building information with GPS coordinates\"\"\"\n    __tablename__ = 'buildings'\n    \n    id = Column(Integer, primary_key=True)\n    name = Column(String(255), nullable=False)\n    description = Column(Text)\n    address = Column(String(500))\n    latitude = Column(Float)\n    longitude = Column(Float)\n    boundary_coords = Column(Text)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    floors = relationship(\"Floor\", back_populates=\"building\", cascade=\"all, delete-orphan\")\n    gateways = relationship(\"Gateway\", back_populates=\"building\", cascade=\"all, delete-orphan\")\n\n\nclass Floor(Base):\n    \"\"\"Floor plan for each story of a building\"\"\"\n    __tablename__ = 'floors'\n    \n    id = Column(Integer, primary_key=True)\n    building_id = Column(Integer, ForeignKey('buildings.id'), nullable=False)\n    floor_number = Column(Integer, nullable=False)\n    name = Column(String(255))\n    floor_plan_image = Column(LargeBinary)\n    floor_plan_filename = Column(String(255))\n    floor_plan_geojson = Column(Text)\n    floor_plan_type = Column(String(20), default='image')\n    width_meters = Column(Float, default=50.0)\n    height_meters = Column(Float, default=50.0)\n    origin_lat = Column(Float)\n    origin_lon = Column(Float)\n    origin_x = Column(Float, default=0)\n    origin_y = Column(Float, default=0)\n    focus_min_x = Column(Float)\n    focus_max_x = Column(Float)\n    focus_min_y = Column(Float)\n    focus_max_y = Column(Float)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    building = relationship(\"Building\", back_populates=\"floors\")\n    gateways = relationship(\"Gateway\", back_populates=\"floor\", cascade=\"all, delete-orphan\")\n    beacons = relationship(\"Beacon\", back_populates=\"floor\", cascade=\"all, delete-orphan\")\n    positions = relationship(\"Position\", back_populates=\"floor\", cascade=\"all, delete-orphan\")\n    zones = relationship(\"Zone\", back_populates=\"floor\", cascade=\"all, delete-orphan\")\n    calibration_points = relationship(\"CalibrationPoint\", back_populates=\"floor\", cascade=\"all, delete-orphan\")\n    coverage_zones = relationship(\"CoverageZone\", back_populates=\"floor\", cascade=\"all, delete-orphan\")\n\n\nclass Gateway(Base):\n    \"\"\"Careflow BLE Gateway configuration\"\"\"\n    __tablename__ = 'gateways'\n    \n    id = Column(Integer, primary_key=True)\n    building_id = Column(Integer, ForeignKey('buildings.id'), nullable=False)\n    floor_id = Column(Integer, ForeignKey('floors.id'), nullable=False)\n    mac_address = Column(String(17), unique=True, nullable=False)\n    name = Column(String(255), nullable=False)\n    description = Column(Text)\n    x_position = Column(Float, nullable=False)\n    y_position = Column(Float, nullable=False)\n    latitude = Column(Float)\n    longitude = Column(Float)\n    mqtt_topic = Column(String(255))\n    wifi_ssid = Column(String(255))\n    is_active = Column(Boolean, default=True)\n    signal_strength_calibration = Column(Float, default=-59)\n    path_loss_exponent = Column(Float, default=2.0)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    building = relationship(\"Building\", back_populates=\"gateways\")\n    floor = relationship(\"Floor\", back_populates=\"gateways\")\n    rssi_signals = relationship(\"RSSISignal\", back_populates=\"gateway\", cascade=\"all, delete-orphan\")\n\n\nclass Beacon(Base):\n    \"\"\"BLE Beacon configuration\"\"\"\n    __tablename__ = 'beacons'\n    \n    id = Column(Integer, primary_key=True)\n    floor_id = Column(Integer, ForeignKey('floors.id'))\n    mac_address = Column(String(17), unique=True, nullable=False)\n    uuid = Column(String(36))\n    major = Column(Integer)\n    minor = Column(Integer)\n    name = Column(String(255), nullable=False)\n    description = Column(Text)\n    resource_type = Column(String(100))\n    assigned_to = Column(String(255))\n    is_fixed = Column(Boolean, default=False)\n    fixed_x = Column(Float)\n    fixed_y = Column(Float)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    floor = relationship(\"Floor\", back_populates=\"beacons\")\n    rssi_signals = relationship(\"RSSISignal\", back_populates=\"beacon\", cascade=\"all, delete-orphan\")\n    positions = relationship(\"Position\", back_populates=\"beacon\", cascade=\"all, delete-orphan\")\n\n\nclass RSSISignal(Base):\n    \"\"\"Raw RSSI signal data received from gateways\"\"\"\n    __tablename__ = 'rssi_signals'\n    \n    id = Column(Integer, primary_key=True)\n    gateway_id = Column(Integer, ForeignKey('gateways.id'), nullable=False)\n    beacon_id = Column(Integer, ForeignKey('beacons.id'), nullable=False)\n    rssi = Column(Integer, nullable=False)\n    tx_power = Column(Integer)\n    timestamp = Column(DateTime, default=datetime.utcnow, nullable=False)\n    raw_data = Column(Text)\n    \n    gateway = relationship(\"Gateway\", back_populates=\"rssi_signals\")\n    beacon = relationship(\"Beacon\", back_populates=\"rssi_signals\")\n\n\nclass Position(Base):\n    \"\"\"Calculated position from triangulation\"\"\"\n    __tablename__ = 'positions'\n    \n    id = Column(Integer, primary_key=True)\n    beacon_id = Column(Integer, ForeignKey('beacons.id'), nullable=False)\n    floor_id = Column(Integer, ForeignKey('floors.id'), nullable=False)\n    x_position = Column(Float, nullable=False)\n    y_position = Column(Float, nullable=False)\n    accuracy = Column(Float)\n    velocity_x = Column(Float, default=0)\n    velocity_y = Column(Float, default=0)\n    speed = Column(Float, default=0)\n    heading = Column(Float)\n    timestamp = Column(DateTime, default=datetime.utcnow, nullable=False)\n    calculation_method = Column(String(50), default='triangulation')\n    \n    beacon = relationship(\"Beacon\", back_populates=\"positions\")\n    floor = relationship(\"Floor\", back_populates=\"positions\")\n\n\nclass MQTTConfig(Base):\n    \"\"\"MQTT Broker configuration\"\"\"\n    __tablename__ = 'mqtt_config'\n    \n    id = Column(Integer, primary_key=True)\n    broker_host = Column(String(255), nullable=False)\n    broker_port = Column(Integer, default=1883)\n    username = Column(String(255))\n    password_env_key = Column(String(255))\n    topic_prefix = Column(String(255), default='ble/gateway/')\n    use_tls = Column(Boolean, default=False)\n    ca_cert_path = Column(String(500))\n    is_active = Column(Boolean, default=True)\n    auto_discover_beacons = Column(Boolean, default=False)\n    publish_enabled = Column(Boolean, default=False)\n    publish_positions_topic = Column(String(255), default='careflow/positions')\n    publish_alerts_topic = Column(String(255), default='careflow/alerts')\n    refresh_interval = Column(Float, default=1.0)\n    signal_window_seconds = Column(Float, default=3.0)\n    rssi_smoothing_enabled = Column(Boolean, default=True)\n    position_smoothing_alpha = Column(Float, default=0.4)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n\nclass Zone(Base):\n    \"\"\"Geofencing zone definition\"\"\"\n    __tablename__ = 'zones'\n    \n    id = Column(Integer, primary_key=True)\n    floor_id = Column(Integer, ForeignKey('floors.id'), nullable=False)\n    name = Column(String(255), nullable=False)\n    description = Column(Text)\n    zone_type = Column(String(50), default='rectangle')\n    x_min = Column(Float, nullable=False)\n    y_min = Column(Float, nullable=False)\n    x_max = Column(Float, nullable=False)\n    y_max = Column(Float, nullable=False)\n    color = Column(String(20), default='#FF0000')\n    alert_on_enter = Column(Boolean, default=True)\n    alert_on_exit = Column(Boolean, default=True)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    floor = relationship(\"Floor\", back_populates=\"zones\")\n    alerts = relationship(\"ZoneAlert\", back_populates=\"zone\", cascade=\"all, delete-orphan\")\n\n\nclass ZoneAlert(Base):\n    \"\"\"Zone entry/exit alert events\"\"\"\n    __tablename__ = 'zone_alerts'\n    \n    id = Column(Integer, primary_key=True)\n    zone_id = Column(Integer, ForeignKey('zones.id'), nullable=False)\n    beacon_id = Column(Integer, ForeignKey('beacons.id'), nullable=False)\n    alert_type = Column(String(20), nullable=False)\n    timestamp = Column(DateTime, default=datetime.utcnow, nullable=False)\n    x_position = Column(Float)\n    y_position = Column(Float)\n    acknowledged = Column(Boolean, default=False)\n    \n    zone = relationship(\"Zone\", back_populates=\"alerts\")\n\n\nclass CalibrationPoint(Base):\n    \"\"\"Calibration reference points for accuracy improvement\"\"\"\n    __tablename__ = 'calibration_points'\n    \n    id = Column(Integer, primary_key=True)\n    floor_id = Column(Integer, ForeignKey('floors.id'), nullable=False)\n    beacon_id = Column(Integer, ForeignKey('beacons.id'), nullable=False)\n    known_x = Column(Float, nullable=False)\n    known_y = Column(Float, nullable=False)\n    measured_x = Column(Float)\n    measured_y = Column(Float)\n    error_distance = Column(Float)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    is_verified = Column(Boolean, default=False)\n    \n    floor = relationship(\"Floor\", back_populates=\"calibration_points\")\n\n\nclass CoverageZone(Base):\n    \"\"\"Coverage zone for gateway planning and geofencing - defines polygonal areas\"\"\"\n    __tablename__ = 'coverage_zones'\n    \n    id = Column(Integer, primary_key=True)\n    floor_id = Column(Integer, ForeignKey('floors.id'), nullable=False)\n    name = Column(String(255), nullable=False)\n    description = Column(Text)\n    polygon_coords = Column(Text, nullable=False)\n    target_accuracy = Column(Float, default=1.0)\n    priority = Column(Integer, default=1)\n    color = Column(String(20), default='#2e5cbf')\n    is_active = Column(Boolean, default=True)\n    alert_on_enter = Column(Boolean, default=True)\n    alert_on_exit = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    floor = relationship(\"Floor\", back_populates=\"coverage_zones\")\n\n\nclass GatewayPlan(Base):\n    \"\"\"Gateway placement plan for infrastructure planning before installation\"\"\"\n    __tablename__ = 'gateway_plans'\n    \n    id = Column(Integer, primary_key=True)\n    floor_id = Column(Integer, ForeignKey('floors.id'), nullable=False)\n    name = Column(String(255), nullable=False)\n    description = Column(Text)\n    target_accuracy = Column(Float, default=1.0)\n    signal_range = Column(Float, default=15.0)\n    path_loss_exponent = Column(Float, default=2.5)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    floor = relationship(\"Floor\")\n    planned_gateways = relationship(\"PlannedGateway\", back_populates=\"plan\", cascade=\"all, delete-orphan\")\n\n\nclass PlannedGateway(Base):\n    \"\"\"Individual gateway position within a plan\"\"\"\n    __tablename__ = 'planned_gateways'\n    \n    id = Column(Integer, primary_key=True)\n    plan_id = Column(Integer, ForeignKey('gateway_plans.id'), nullable=False)\n    name = Column(String(255), nullable=False)\n    x_position = Column(Float, nullable=False)\n    y_position = Column(Float, nullable=False)\n    notes = Column(Text)\n    is_installed = Column(Boolean, default=False)\n    installed_gateway_id = Column(Integer, ForeignKey('gateways.id'))\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    plan = relationship(\"GatewayPlan\", back_populates=\"planned_gateways\")\n    installed_gateway = relationship(\"Gateway\")\n\n\ndef get_engine():\n    \"\"\"Create database engine from environment variables (singleton)\"\"\"\n    global _engine\n    if _engine is None:\n        database_url = os.environ.get('DATABASE_URL')\n        if not database_url:\n            raise ValueError(\"DATABASE_URL environment variable is not set\")\n        _engine = create_engine(database_url, pool_pre_ping=True, pool_recycle=300)\n    return _engine\n\n\ndef get_session_factory():\n    \"\"\"Get session factory (singleton)\"\"\"\n    global _SessionLocal\n    if _SessionLocal is None:\n        engine = get_engine()\n        _SessionLocal = sessionmaker(bind=engine)\n    return _SessionLocal\n\n\n@contextmanager\ndef get_db_session():\n    \"\"\"Context manager for database sessions - ensures proper cleanup\"\"\"\n    SessionLocal = get_session_factory()\n    session = SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except Exception:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n\n\ndef get_session():\n    \"\"\"Create a new database session (legacy - use get_db_session context manager instead)\"\"\"\n    SessionLocal = get_session_factory()\n    return SessionLocal()\n\n\ndef init_db():\n    \"\"\"Initialize database tables\"\"\"\n    engine = get_engine()\n    Base.metadata.create_all(engine)\n    return engine\n","path":null,"size_bytes":13585,"size_tokens":null},"main.py":{"content":"def main():\n    print(\"Hello from repl-nix-workspace!\")\n\n\nif __name__ == \"__main__\":\n    main()\n","path":null,"size_bytes":96,"size_tokens":null},"views/import_export.py":{"content":"import streamlit as st\nfrom database import get_db_session, Building, Floor, Gateway, Beacon, Zone\nimport json\nimport csv\nfrom io import StringIO\nfrom datetime import datetime\n\n\ndef render():\n    st.title(\"Import / Export\")\n    st.markdown(\"Bulk import and export gateway and beacon configurations\")\n    \n    tab1, tab2 = st.tabs([\"Export\", \"Import\"])\n    \n    with tab1:\n        render_export()\n    \n    with tab2:\n        render_import()\n\n\ndef render_export():\n    st.subheader(\"Export Configurations\")\n    \n    with get_db_session() as session:\n        export_type = st.selectbox(\n            \"What to Export\",\n            options=[\"Gateways\", \"Beacons\", \"Zones\", \"All Configurations\"]\n        )\n        \n        export_format = st.radio(\n            \"Format\",\n            options=[\"JSON\", \"CSV\"],\n            horizontal=True\n        )\n        \n        if st.button(\"Generate Export\", type=\"primary\"):\n            if export_type == \"Gateways\" or export_type == \"All Configurations\":\n                gateways = session.query(Gateway).all()\n                gateway_data = []\n                for gw in gateways:\n                    building = session.query(Building).filter(Building.id == gw.building_id).first()\n                    floor = session.query(Floor).filter(Floor.id == gw.floor_id).first()\n                    gateway_data.append({\n                        'mac_address': gw.mac_address,\n                        'name': gw.name,\n                        'description': gw.description or '',\n                        'building_name': building.name if building else '',\n                        'floor_number': floor.floor_number if floor else 0,\n                        'x_position': gw.x_position,\n                        'y_position': gw.y_position,\n                        'latitude': gw.latitude or '',\n                        'longitude': gw.longitude or '',\n                        'mqtt_topic': gw.mqtt_topic or '',\n                        'wifi_ssid': gw.wifi_ssid or '',\n                        'signal_calibration': gw.signal_strength_calibration,\n                        'path_loss_exponent': gw.path_loss_exponent,\n                        'is_active': gw.is_active\n                    })\n            \n            if export_type == \"Beacons\" or export_type == \"All Configurations\":\n                beacons = session.query(Beacon).all()\n                beacon_data = []\n                for b in beacons:\n                    floor = session.query(Floor).filter(Floor.id == b.floor_id).first() if b.floor_id else None\n                    beacon_data.append({\n                        'mac_address': b.mac_address,\n                        'name': b.name,\n                        'uuid': b.uuid or '',\n                        'major': b.major or 0,\n                        'minor': b.minor or 0,\n                        'description': b.description or '',\n                        'resource_type': b.resource_type or '',\n                        'assigned_to': b.assigned_to or '',\n                        'is_fixed': b.is_fixed,\n                        'floor_number': floor.floor_number if floor else '',\n                        'fixed_x': b.fixed_x or '',\n                        'fixed_y': b.fixed_y or '',\n                        'is_active': b.is_active\n                    })\n            \n            if export_type == \"Zones\" or export_type == \"All Configurations\":\n                zones = session.query(Zone).all()\n                zone_data = []\n                for z in zones:\n                    floor = session.query(Floor).filter(Floor.id == z.floor_id).first()\n                    building = session.query(Building).filter(Building.id == floor.building_id).first() if floor else None\n                    zone_data.append({\n                        'name': z.name,\n                        'description': z.description or '',\n                        'building_name': building.name if building else '',\n                        'floor_number': floor.floor_number if floor else 0,\n                        'x_min': z.x_min,\n                        'y_min': z.y_min,\n                        'x_max': z.x_max,\n                        'y_max': z.y_max,\n                        'color': z.color,\n                        'alert_on_enter': z.alert_on_enter,\n                        'alert_on_exit': z.alert_on_exit,\n                        'is_active': z.is_active\n                    })\n            \n            if export_format == \"JSON\":\n                if export_type == \"All Configurations\":\n                    export_data = {\n                        'export_date': datetime.utcnow().isoformat(),\n                        'gateways': gateway_data,\n                        'beacons': beacon_data,\n                        'zones': zone_data\n                    }\n                elif export_type == \"Gateways\":\n                    export_data = {'gateways': gateway_data}\n                elif export_type == \"Beacons\":\n                    export_data = {'beacons': beacon_data}\n                else:\n                    export_data = {'zones': zone_data}\n                \n                json_str = json.dumps(export_data, indent=2)\n                st.download_button(\n                    label=\"Download JSON\",\n                    data=json_str,\n                    file_name=f\"ble_config_{export_type.lower()}_{datetime.now().strftime('%Y%m%d')}.json\",\n                    mime=\"application/json\"\n                )\n                \n                st.json(export_data)\n            \n            else:\n                if export_type == \"Gateways\":\n                    data = gateway_data\n                elif export_type == \"Beacons\":\n                    data = beacon_data\n                elif export_type == \"Zones\":\n                    data = zone_data\n                else:\n                    st.warning(\"CSV export only supports single type. Please select Gateways, Beacons, or Zones.\")\n                    return\n                \n                if data:\n                    output = StringIO()\n                    writer = csv.DictWriter(output, fieldnames=data[0].keys())\n                    writer.writeheader()\n                    writer.writerows(data)\n                    csv_str = output.getvalue()\n                    \n                    st.download_button(\n                        label=\"Download CSV\",\n                        data=csv_str,\n                        file_name=f\"ble_config_{export_type.lower()}_{datetime.now().strftime('%Y%m%d')}.csv\",\n                        mime=\"text/csv\"\n                    )\n                    \n                    st.text(csv_str[:2000] + \"...\" if len(csv_str) > 2000 else csv_str)\n                else:\n                    st.info(f\"No {export_type.lower()} data to export.\")\n\n\ndef render_import():\n    st.subheader(\"Import Configurations\")\n    \n    import_type = st.selectbox(\n        \"What to Import\",\n        options=[\"Gateways\", \"Beacons\", \"Zones\"]\n    )\n    \n    import_format = st.radio(\n        \"Format\",\n        options=[\"JSON\", \"CSV\"],\n        horizontal=True,\n        key=\"import_format\"\n    )\n    \n    uploaded_file = st.file_uploader(\n        f\"Upload {import_format} File\",\n        type=['json'] if import_format == \"JSON\" else ['csv']\n    )\n    \n    if uploaded_file:\n        try:\n            if import_format == \"JSON\":\n                try:\n                    content = uploaded_file.read().decode('utf-8')\n                    data = json.loads(content)\n                except json.JSONDecodeError as e:\n                    st.error(f\"Invalid JSON file: {str(e)}\")\n                    return\n                \n                if import_type == \"Gateways\":\n                    items = data.get('gateways', data if isinstance(data, list) else [])\n                elif import_type == \"Beacons\":\n                    items = data.get('beacons', data if isinstance(data, list) else [])\n                else:\n                    items = data.get('zones', data if isinstance(data, list) else [])\n            else:\n                try:\n                    content = uploaded_file.read().decode('utf-8')\n                    reader = csv.DictReader(StringIO(content))\n                    items = list(reader)\n                except Exception as e:\n                    st.error(f\"Error parsing CSV file: {str(e)}\")\n                    return\n            \n            st.write(f\"**Found {len(items)} items to import**\")\n            \n            if items:\n                st.json(items[:5])\n                if len(items) > 5:\n                    st.write(f\"... and {len(items) - 5} more\")\n            \n            col1, col2 = st.columns(2)\n            \n            with col1:\n                skip_existing = st.checkbox(\"Skip existing (by MAC address)\", value=True)\n            \n            with col2:\n                update_existing = st.checkbox(\"Update existing entries\", value=False)\n            \n            if st.button(\"Import Data\", type=\"primary\"):\n                with get_db_session() as session:\n                    imported = 0\n                    skipped = 0\n                    updated = 0\n                    errors = []\n                    \n                    for item in items:\n                        try:\n                            if import_type == \"Gateways\":\n                                mac = item.get('mac_address', '').upper()\n                                existing = session.query(Gateway).filter(Gateway.mac_address == mac).first()\n                                \n                                if existing:\n                                    if skip_existing and not update_existing:\n                                        skipped += 1\n                                        continue\n                                    elif update_existing:\n                                        existing.name = item.get('name', existing.name)\n                                        existing.description = item.get('description') or existing.description\n                                        existing.x_position = float(item.get('x_position', existing.x_position))\n                                        existing.y_position = float(item.get('y_position', existing.y_position))\n                                        existing.signal_strength_calibration = float(item.get('signal_calibration', existing.signal_strength_calibration))\n                                        existing.path_loss_exponent = float(item.get('path_loss_exponent', existing.path_loss_exponent))\n                                        updated += 1\n                                        continue\n                                \n                                building_name = item.get('building_name', '')\n                                floor_number = int(item.get('floor_number', 0))\n                                \n                                building = session.query(Building).filter(Building.name == building_name).first()\n                                if not building:\n                                    errors.append(f\"Building '{building_name}' not found for gateway {mac}\")\n                                    continue\n                                \n                                floor = session.query(Floor).filter(\n                                    Floor.building_id == building.id,\n                                    Floor.floor_number == floor_number\n                                ).first()\n                                if not floor:\n                                    errors.append(f\"Floor {floor_number} not found in '{building_name}' for gateway {mac}\")\n                                    continue\n                                \n                                gateway = Gateway(\n                                    building_id=building.id,\n                                    floor_id=floor.id,\n                                    mac_address=mac,\n                                    name=item.get('name', ''),\n                                    description=item.get('description'),\n                                    x_position=float(item.get('x_position', 0)),\n                                    y_position=float(item.get('y_position', 0)),\n                                    latitude=float(item['latitude']) if item.get('latitude') else None,\n                                    longitude=float(item['longitude']) if item.get('longitude') else None,\n                                    mqtt_topic=item.get('mqtt_topic'),\n                                    wifi_ssid=item.get('wifi_ssid'),\n                                    signal_strength_calibration=float(item.get('signal_calibration', -59)),\n                                    path_loss_exponent=float(item.get('path_loss_exponent', 2.0)),\n                                    is_active=str(item.get('is_active', 'true')).lower() == 'true'\n                                )\n                                session.add(gateway)\n                                imported += 1\n                            \n                            elif import_type == \"Beacons\":\n                                mac = item.get('mac_address', '').upper()\n                                existing = session.query(Beacon).filter(Beacon.mac_address == mac).first()\n                                \n                                if existing:\n                                    if skip_existing and not update_existing:\n                                        skipped += 1\n                                        continue\n                                    elif update_existing:\n                                        existing.name = item.get('name', existing.name)\n                                        existing.description = item.get('description') or existing.description\n                                        existing.resource_type = item.get('resource_type') or existing.resource_type\n                                        existing.assigned_to = item.get('assigned_to') or existing.assigned_to\n                                        updated += 1\n                                        continue\n                                \n                                floor_id = None\n                                if item.get('floor_number'):\n                                    floor = session.query(Floor).filter(\n                                        Floor.floor_number == int(item.get('floor_number', 0))\n                                    ).first()\n                                    if floor:\n                                        floor_id = floor.id\n                                \n                                beacon = Beacon(\n                                    mac_address=mac,\n                                    name=item.get('name', ''),\n                                    uuid=item.get('uuid'),\n                                    major=int(item['major']) if item.get('major') else None,\n                                    minor=int(item['minor']) if item.get('minor') else None,\n                                    description=item.get('description'),\n                                    resource_type=item.get('resource_type'),\n                                    assigned_to=item.get('assigned_to'),\n                                    is_fixed=str(item.get('is_fixed', 'false')).lower() == 'true',\n                                    floor_id=floor_id,\n                                    fixed_x=float(item['fixed_x']) if item.get('fixed_x') else None,\n                                    fixed_y=float(item['fixed_y']) if item.get('fixed_y') else None,\n                                    is_active=str(item.get('is_active', 'true')).lower() == 'true'\n                                )\n                                session.add(beacon)\n                                imported += 1\n                            \n                            elif import_type == \"Zones\":\n                                building_name = item.get('building_name', '')\n                                floor_number = int(item.get('floor_number', 0))\n                                \n                                building = session.query(Building).filter(Building.name == building_name).first()\n                                if not building:\n                                    errors.append(f\"Building '{building_name}' not found for zone {item.get('name')}\")\n                                    continue\n                                \n                                floor = session.query(Floor).filter(\n                                    Floor.building_id == building.id,\n                                    Floor.floor_number == floor_number\n                                ).first()\n                                if not floor:\n                                    errors.append(f\"Floor {floor_number} not found in '{building_name}'\")\n                                    continue\n                                \n                                zone = Zone(\n                                    floor_id=floor.id,\n                                    name=item.get('name', ''),\n                                    description=item.get('description'),\n                                    x_min=float(item.get('x_min', 0)),\n                                    y_min=float(item.get('y_min', 0)),\n                                    x_max=float(item.get('x_max', 10)),\n                                    y_max=float(item.get('y_max', 10)),\n                                    color=item.get('color', '#FF0000'),\n                                    alert_on_enter=str(item.get('alert_on_enter', 'true')).lower() == 'true',\n                                    alert_on_exit=str(item.get('alert_on_exit', 'true')).lower() == 'true',\n                                    is_active=str(item.get('is_active', 'true')).lower() == 'true'\n                                )\n                                session.add(zone)\n                                imported += 1\n                        \n                        except Exception as e:\n                            errors.append(f\"Error processing item: {str(e)}\")\n                    \n                    st.success(f\"Import complete: {imported} imported, {updated} updated, {skipped} skipped\")\n                    \n                    if errors:\n                        st.warning(f\"Errors encountered: {len(errors)}\")\n                        with st.expander(\"View Errors\"):\n                            for error in errors:\n                                st.write(f\"- {error}\")\n        \n        except Exception as e:\n            st.error(f\"Error reading file: {str(e)}\")\n    \n    st.markdown(\"---\")\n    st.subheader(\"Import Templates\")\n    \n    st.markdown(\"\"\"\n    **Gateway CSV Template:**\n    ```\n    mac_address,name,description,building_name,floor_number,x_position,y_position,latitude,longitude,mqtt_topic,wifi_ssid,signal_calibration,path_loss_exponent,is_active\n    AA:BB:CC:DD:EE:FF,Gateway 1,Main entrance,Main Building,0,5.0,10.0,,,ble/gateway/1,Office_WiFi,-59,2.0,true\n    ```\n    \n    **Beacon CSV Template:**\n    ```\n    mac_address,name,uuid,major,minor,description,resource_type,assigned_to,is_fixed,floor_number,fixed_x,fixed_y,is_active\n    11:22:33:44:55:66,Asset Tag 1,,0,0,Forklift,Asset,Warehouse Team,false,,,true\n    ```\n    \n    **Zone CSV Template:**\n    ```\n    name,description,building_name,floor_number,x_min,y_min,x_max,y_max,color,alert_on_enter,alert_on_exit,is_active\n    Restricted Area,No unauthorized access,Main Building,0,0,0,10,10,#FF0000,true,true,true\n    ```\n    \"\"\")\n","path":null,"size_bytes":19549,"size_tokens":null},"views/beacons.py":{"content":"import streamlit as st\nfrom database import get_db_session, Building, Floor, Beacon\nfrom datetime import datetime\nimport re\n\n\ndef show_pending_message():\n    \"\"\"Display any pending success message from session state\"\"\"\n    if 'beacons_success_msg' in st.session_state:\n        st.success(st.session_state['beacons_success_msg'])\n        del st.session_state['beacons_success_msg']\n\n\ndef set_success_and_rerun(message):\n    \"\"\"Store success message in session state and rerun\"\"\"\n    st.session_state['beacons_success_msg'] = message\n    st.rerun()\n\n\ndef validate_mac_address(mac: str) -> bool:\n    \"\"\"Validate MAC address format\"\"\"\n    pattern = re.compile(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$')\n    return bool(pattern.match(mac))\n\n\ndef render():\n    st.title(\"BLE Beacon Management\")\n    st.markdown(\"Register and manage BLE beacons for tracking\")\n    \n    show_pending_message()\n    \n    with get_db_session() as session:\n        st.subheader(\"Add New Beacon\")\n        \n        with st.form(\"add_beacon\"):\n            col1, col2 = st.columns(2)\n            \n            with col1:\n                mac_address = st.text_input(\n                    \"MAC Address*\",\n                    placeholder=\"AA:BB:CC:DD:EE:FF\",\n                    help=\"The MAC address of the BLE beacon\"\n                ).upper()\n                \n                name = st.text_input(\n                    \"Beacon Name*\",\n                    placeholder=\"e.g., Asset Tag #001\"\n                )\n                \n                uuid = st.text_input(\n                    \"UUID\",\n                    placeholder=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n                    help=\"iBeacon UUID (optional)\"\n                )\n            \n            with col2:\n                resource_type = st.selectbox(\n                    \"Resource Type*\",\n                    options=[\"Device\", \"Staff\", \"Asset\", \"Vehicle\", \"Equipment\", \"Other\"],\n                    help=\"What type of resource is this beacon attached to?\"\n                )\n                \n                assigned_to = st.text_input(\n                    \"Assigned To\",\n                    placeholder=\"e.g., John Smith, Forklift #3\",\n                    help=\"Person or item this beacon is attached to\"\n                )\n                \n                col2a, col2b = st.columns(2)\n                with col2a:\n                    major = st.number_input(\"Major\", value=0, min_value=0, max_value=65535)\n                with col2b:\n                    minor = st.number_input(\"Minor\", value=0, min_value=0, max_value=65535)\n            \n            description = st.text_area(\n                \"Description\",\n                placeholder=\"Additional details about this beacon...\"\n            )\n            \n            st.markdown(\"**Fixed Position (Optional)**\")\n            st.caption(\"If this beacon is stationary, you can set its fixed position for calibration\")\n            \n            buildings = session.query(Building).order_by(Building.name).all()\n            \n            col3, col4 = st.columns(2)\n            \n            with col3:\n                is_fixed = st.checkbox(\"This beacon has a fixed position\")\n            \n            floor_id = None\n            fixed_x = None\n            fixed_y = None\n            \n            if is_fixed and buildings:\n                with col4:\n                    building_options = {b.name: b.id for b in buildings}\n                    selected_building = st.selectbox(\n                        \"Building\",\n                        options=list(building_options.keys()),\n                        key=\"beacon_building\"\n                    )\n                    \n                    floors = session.query(Floor).filter(\n                        Floor.building_id == building_options[selected_building]\n                    ).order_by(Floor.floor_number).all()\n                    \n                    if floors:\n                        floor_options = {\n                            f\"{f.floor_number}: {f.name or 'Floor ' + str(f.floor_number)}\": f.id \n                            for f in floors\n                        }\n                        selected_floor = st.selectbox(\n                            \"Floor\",\n                            options=list(floor_options.keys()),\n                            key=\"beacon_floor\"\n                        )\n                        floor_id = floor_options[selected_floor]\n                \n                col5, col6 = st.columns(2)\n                with col5:\n                    fixed_x = st.number_input(\"X Position (meters)\", value=0.0, min_value=0.0)\n                with col6:\n                    fixed_y = st.number_input(\"Y Position (meters)\", value=0.0, min_value=0.0)\n            \n            is_active = st.checkbox(\"Beacon is active\", value=True)\n            \n            submitted = st.form_submit_button(\"Add Beacon\", type=\"primary\")\n            \n            if submitted:\n                if not name:\n                    st.error(\"Beacon name is required\")\n                elif not mac_address:\n                    st.error(\"MAC address is required\")\n                elif not validate_mac_address(mac_address):\n                    st.error(\"Invalid MAC address format. Use AA:BB:CC:DD:EE:FF\")\n                else:\n                    existing = session.query(Beacon).filter(\n                        Beacon.mac_address == mac_address\n                    ).first()\n                    \n                    if existing:\n                        st.error(\"A beacon with this MAC address already exists\")\n                    else:\n                        beacon = Beacon(\n                            mac_address=mac_address,\n                            name=name,\n                            uuid=uuid or None,\n                            major=major if major > 0 else None,\n                            minor=minor if minor > 0 else None,\n                            description=description or None,\n                            resource_type=resource_type,\n                            assigned_to=assigned_to or None,\n                            is_fixed=is_fixed,\n                            floor_id=floor_id,\n                            fixed_x=fixed_x,\n                            fixed_y=fixed_y,\n                            is_active=is_active\n                        )\n                        session.add(beacon)\n                        session.commit()\n                        set_success_and_rerun(f\"Beacon '{name}' added successfully!\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Registered Beacons\")\n        \n        auto_discovered_count = session.query(Beacon).filter(\n            Beacon.name.like('Auto-%')\n        ).count()\n        \n        if auto_discovered_count > 0:\n            st.warning(f\"You have {auto_discovered_count} auto-discovered beacon(s) that may be unwanted devices\")\n            \n            with st.expander(\"Bulk Delete Auto-Discovered Beacons\", expanded=False):\n                st.caption(\"These are BLE devices automatically detected by gateways (phones, headphones, etc.)\")\n                \n                col_bulk1, col_bulk2 = st.columns(2)\n                \n                with col_bulk1:\n                    if st.button(\"Delete All Auto-Discovered\", type=\"secondary\"):\n                        st.session_state['confirm_delete_auto'] = True\n                \n                with col_bulk2:\n                    if st.session_state.get('confirm_delete_auto', False):\n                        st.warning(\"This will delete all auto-discovered beacons and their related data!\")\n                        if st.button(\"Confirm Delete\", type=\"primary\"):\n                            from database import RSSISignal, Position, ZoneAlert, CalibrationPoint\n                            auto_beacons = session.query(Beacon).filter(\n                                Beacon.name.like('Auto-%')\n                            ).all()\n                            \n                            deleted_count = 0\n                            for beacon in auto_beacons:\n                                session.query(ZoneAlert).filter(ZoneAlert.beacon_id == beacon.id).delete()\n                                session.query(CalibrationPoint).filter(CalibrationPoint.beacon_id == beacon.id).delete()\n                                session.query(RSSISignal).filter(RSSISignal.beacon_id == beacon.id).delete()\n                                session.query(Position).filter(Position.beacon_id == beacon.id).delete()\n                                session.delete(beacon)\n                                deleted_count += 1\n                            \n                            session.commit()\n                            st.session_state['confirm_delete_auto'] = False\n                            set_success_and_rerun(f\"Deleted {deleted_count} auto-discovered beacons\")\n                        if st.button(\"Cancel\", key=\"cancel_bulk_delete\"):\n                            st.session_state['confirm_delete_auto'] = False\n                            st.rerun()\n        \n        filter_col1, filter_col2 = st.columns(2)\n        with filter_col1:\n            filter_type = st.selectbox(\n                \"Filter by Type\",\n                options=[\"All\", \"Device\", \"Staff\", \"Asset\", \"Vehicle\", \"Equipment\", \"Other\"]\n            )\n        with filter_col2:\n            filter_active = st.selectbox(\n                \"Filter by Status\",\n                options=[\"All\", \"Active Only\", \"Inactive Only\"]\n            )\n        \n        query = session.query(Beacon)\n        \n        if filter_type != \"All\":\n            query = query.filter(Beacon.resource_type == filter_type)\n        \n        if filter_active == \"Active Only\":\n            query = query.filter(Beacon.is_active == True)\n        elif filter_active == \"Inactive Only\":\n            query = query.filter(Beacon.is_active == False)\n        \n        beacons = query.order_by(Beacon.name).all()\n        \n        if beacons:\n            for beacon in beacons:\n                status_icon = \"ðŸŸ¢\" if beacon.is_active else \"ðŸ”´\"\n                type_icon = {\n                    \"Device\": \"ðŸ“±\",\n                    \"Staff\": \"ðŸ‘¤\",\n                    \"Asset\": \"ðŸ“¦\",\n                    \"Vehicle\": \"ðŸš—\",\n                    \"Equipment\": \"ðŸ”§\",\n                    \"Other\": \"ðŸ“\"\n                }.get(beacon.resource_type, \"ðŸ“\")\n                \n                with st.expander(\n                    f\"{status_icon} {type_icon} {beacon.name} ({beacon.mac_address})\",\n                    expanded=False\n                ):\n                    col1, col2, col3 = st.columns([2, 2, 1])\n                    \n                    with col1:\n                        st.write(f\"**Type:** {beacon.resource_type}\")\n                        st.write(f\"**Assigned To:** {beacon.assigned_to or 'Not assigned'}\")\n                        if beacon.uuid:\n                            st.write(f\"**UUID:** {beacon.uuid}\")\n                        if beacon.major or beacon.minor:\n                            st.write(f\"**Major/Minor:** {beacon.major or 0}/{beacon.minor or 0}\")\n                    \n                    with col2:\n                        if beacon.is_fixed:\n                            floor = session.query(Floor).filter(Floor.id == beacon.floor_id).first()\n                            st.write(f\"**Fixed Position:** Yes\")\n                            if floor:\n                                st.write(f\"**Floor:** {floor.name}\")\n                            st.write(f\"**Position:** ({beacon.fixed_x}m, {beacon.fixed_y}m)\")\n                        else:\n                            st.write(\"**Fixed Position:** No (mobile)\")\n                        \n                        if beacon.description:\n                            st.write(f\"**Description:** {beacon.description}\")\n                    \n                    with col3:\n                        if st.button(\"Toggle Active\", key=f\"toggle_beacon_{beacon.id}\"):\n                            beacon.is_active = not beacon.is_active\n                            session.commit()\n                            st.rerun()\n                        \n                        if st.button(\"Delete\", key=f\"del_beacon_{beacon.id}\", type=\"secondary\"):\n                            beacon_name = beacon.name\n                            session.delete(beacon)\n                            session.commit()\n                            set_success_and_rerun(f\"Beacon '{beacon_name}' deleted\")\n            \n            st.markdown(\"---\")\n            st.write(f\"**Total beacons:** {len(beacons)}\")\n        else:\n            st.info(\"No beacons registered yet. Add your first beacon above.\")\n","path":null,"size_bytes":12637,"size_tokens":null},"database/__init__.py":{"content":"from database.models import (\n    Base, Building, Floor, Gateway, Beacon, \n    RSSISignal, Position, MQTTConfig, Zone, ZoneAlert, CalibrationPoint,\n    get_engine, get_session, get_db_session, init_db\n)\n\n__all__ = [\n    'Base', 'Building', 'Floor', 'Gateway', 'Beacon',\n    'RSSISignal', 'Position', 'MQTTConfig', 'Zone', 'ZoneAlert', 'CalibrationPoint',\n    'get_engine', 'get_session', 'get_db_session', 'init_db'\n]\n","path":null,"size_bytes":418,"size_tokens":null},"utils/mqtt_publisher.py":{"content":"import json\nimport os\nimport threading\nimport queue\nfrom datetime import datetime\nfrom typing import Optional, Dict, Any\nimport paho.mqtt.client as mqtt\nimport ssl\nfrom database import get_db_session, MQTTConfig\n\n\nclass MQTTPublisher:\n    \"\"\"Thread-safe singleton MQTT publisher for sending positions and alerts to external apps\"\"\"\n    \n    _instance = None\n    _instance_lock = threading.Lock()\n    \n    def __new__(cls):\n        if cls._instance is None:\n            with cls._instance_lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n                    cls._instance._initialized = False\n        return cls._instance\n    \n    def __init__(self):\n        if self._initialized:\n            return\n        \n        self._initialized = True\n        self._client: Optional[mqtt.Client] = None\n        self._publish_lock = threading.Lock()\n        self._config_lock = threading.Lock()\n        self.positions_topic: str = 'careflow/positions'\n        self.alerts_topic: str = 'careflow/alerts'\n        self.enabled: bool = False\n        self._connected: bool = False\n        self._publish_queue: queue.Queue = queue.Queue(maxsize=1000)\n        self._publish_thread: Optional[threading.Thread] = None\n        self._running: bool = False\n    \n    def configure(self, config: MQTTConfig) -> bool:\n        \"\"\"Configure the publisher from MQTT config (thread-safe)\"\"\"\n        with self._config_lock:\n            if not config.publish_enabled:\n                self.enabled = False\n                self._stop_publish_thread()\n                return True\n            \n            self.enabled = True\n            self.positions_topic = config.publish_positions_topic or 'careflow/positions'\n            self.alerts_topic = config.publish_alerts_topic or 'careflow/alerts'\n            \n            password = None\n            if config.password_env_key:\n                password = os.environ.get(config.password_env_key)\n            \n            try:\n                if self._client:\n                    try:\n                        self._client.loop_stop()\n                        self._client.disconnect()\n                    except:\n                        pass\n                \n                self._client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)\n                self._client.on_connect = self._on_connect\n                self._client.on_disconnect = self._on_disconnect\n                \n                if config.username and password:\n                    self._client.username_pw_set(config.username, password)\n                \n                if config.use_tls:\n                    ca_cert_path = config.ca_cert_path\n                    if ca_cert_path and os.path.exists(ca_cert_path):\n                        self._client.tls_set(\n                            ca_certs=ca_cert_path,\n                            cert_reqs=ssl.CERT_REQUIRED,\n                            tls_version=ssl.PROTOCOL_TLSv1_2\n                        )\n                    else:\n                        self._client.tls_set(\n                            cert_reqs=ssl.CERT_REQUIRED,\n                            tls_version=ssl.PROTOCOL_TLS\n                        )\n                    self._client.tls_insecure_set(False)\n                \n                self._client.connect(config.broker_host, config.broker_port, keepalive=60)\n                self._client.loop_start()\n                self._start_publish_thread()\n                print(f\"MQTT Publisher configured, publishing to {self.positions_topic} and {self.alerts_topic}\")\n                return True\n                    \n            except Exception as e:\n                print(f\"MQTT Publisher configuration error: {e}\")\n                self._connected = False\n                return False\n    \n    def _on_connect(self, client, userdata, flags, reason_code, properties=None):\n        \"\"\"Callback when connected to broker\"\"\"\n        if reason_code == 0:\n            self._connected = True\n            print(\"MQTT Publisher connected to broker\")\n        else:\n            self._connected = False\n            print(f\"MQTT Publisher connection failed: {reason_code}\")\n    \n    def _on_disconnect(self, client, userdata, flags, reason_code, properties=None):\n        \"\"\"Callback when disconnected from broker\"\"\"\n        self._connected = False\n        if reason_code != 0:\n            print(f\"MQTT Publisher disconnected unexpectedly: {reason_code}\")\n    \n    def _start_publish_thread(self):\n        \"\"\"Start the async publish thread\"\"\"\n        if not self._running:\n            self._running = True\n            self._publish_thread = threading.Thread(target=self._publish_loop, daemon=True)\n            self._publish_thread.start()\n    \n    def _stop_publish_thread(self):\n        \"\"\"Stop the async publish thread\"\"\"\n        self._running = False\n        if self._publish_thread:\n            self._publish_thread.join(timeout=2)\n            self._publish_thread = None\n    \n    def _publish_loop(self):\n        \"\"\"Background thread for publishing messages asynchronously\"\"\"\n        while self._running:\n            try:\n                msg = self._publish_queue.get(timeout=1)\n                if msg and self._connected and self._client:\n                    with self._publish_lock:\n                        try:\n                            result = self._client.publish(msg['topic'], json.dumps(msg['payload']))\n                            if result.rc != mqtt.MQTT_ERR_SUCCESS:\n                                print(f\"MQTT Publish failed for topic {msg['topic']}: rc={result.rc}\")\n                        except Exception as e:\n                            print(f\"MQTT Publish error: {e}\")\n            except queue.Empty:\n                continue\n            except Exception as e:\n                print(f\"MQTT Publish loop error: {e}\")\n    \n    def _enqueue_message(self, topic: str, payload: Dict[str, Any]) -> bool:\n        \"\"\"Enqueue a message for async publishing (non-blocking)\"\"\"\n        if not self.enabled:\n            return False\n        \n        try:\n            self._publish_queue.put_nowait({'topic': topic, 'payload': payload})\n            return True\n        except queue.Full:\n            print(f\"MQTT Publish queue full, dropping message for topic: {topic}\")\n            return False\n    \n    def publish_position(self, beacon_mac: str, beacon_name: str, resource_type: str,\n                         floor_id: int, floor_name: str, building_name: str,\n                         x: float, y: float, accuracy: float,\n                         speed: float = 0, heading: float = 0,\n                         velocity_x: float = 0, velocity_y: float = 0) -> bool:\n        \"\"\"Publish beacon position to MQTT (async, non-blocking)\"\"\"\n        if not self.enabled:\n            return False\n        \n        payload = {\n            \"type\": \"position\",\n            \"beacon\": {\n                \"mac\": beacon_mac,\n                \"name\": beacon_name,\n                \"resource_type\": resource_type\n            },\n            \"location\": {\n                \"floor_id\": floor_id,\n                \"floor_name\": floor_name,\n                \"building_name\": building_name,\n                \"x\": round(x, 2),\n                \"y\": round(y, 2),\n                \"accuracy\": round(accuracy, 2)\n            },\n            \"movement\": {\n                \"speed\": round(speed, 3),\n                \"heading\": round(heading, 1),\n                \"velocity_x\": round(velocity_x, 3),\n                \"velocity_y\": round(velocity_y, 3)\n            },\n            \"timestamp\": datetime.utcnow().isoformat() + \"Z\"\n        }\n        \n        topic = f\"{self.positions_topic}/{beacon_mac.replace(':', '')}\"\n        return self._enqueue_message(topic, payload)\n    \n    def publish_alert(self, alert_type: str, beacon_mac: str, beacon_name: str,\n                      zone_id: int, zone_name: str, floor_name: str,\n                      x: float, y: float, resource_type: str = None) -> bool:\n        \"\"\"Publish zone alert to MQTT (async, non-blocking)\"\"\"\n        if not self.enabled:\n            return False\n        \n        payload = {\n            \"type\": \"zone_alert\",\n            \"alert_type\": alert_type,\n            \"beacon\": {\n                \"mac\": beacon_mac,\n                \"name\": beacon_name,\n                \"resource_type\": resource_type\n            },\n            \"zone\": {\n                \"id\": zone_id,\n                \"name\": zone_name,\n                \"floor_name\": floor_name\n            },\n            \"position\": {\n                \"x\": round(x, 2),\n                \"y\": round(y, 2)\n            },\n            \"timestamp\": datetime.utcnow().isoformat() + \"Z\"\n        }\n        \n        topic = f\"{self.alerts_topic}/{alert_type}/{zone_id}\"\n        return self._enqueue_message(topic, payload)\n    \n    def is_connected(self) -> bool:\n        \"\"\"Check if publisher is connected\"\"\"\n        return self.enabled and self._connected and self._client is not None\n    \n    def disconnect(self):\n        \"\"\"Disconnect the publisher\"\"\"\n        self._stop_publish_thread()\n        if self._client:\n            try:\n                self._client.loop_stop()\n                self._client.disconnect()\n            except:\n                pass\n        self._connected = False\n\n\ndef get_mqtt_publisher() -> MQTTPublisher:\n    \"\"\"Get the singleton MQTT publisher instance\"\"\"\n    return MQTTPublisher()\n\n\ndef initialize_publisher() -> bool:\n    \"\"\"Initialize the publisher from database config\"\"\"\n    publisher = get_mqtt_publisher()\n    \n    try:\n        with get_db_session() as session:\n            config = session.query(MQTTConfig).filter(MQTTConfig.is_active == True).first()\n            if config and config.publish_enabled:\n                return publisher.configure(config)\n    except Exception as e:\n        print(f\"Failed to initialize MQTT publisher: {e}\")\n    \n    return False\n","path":null,"size_bytes":9865,"size_tokens":null},"views/live_tracking.py":{"content":"import streamlit as st\nfrom database import get_db_session, Building, Floor, Gateway, Beacon, Position, RSSISignal, MQTTConfig\nfrom utils.triangulation import GatewayReading, trilaterate_2d, calculate_velocity, filter_outlier_readings\nfrom utils.signal_processor import get_signal_processor\nfrom datetime import datetime, timedelta\nfrom io import BytesIO\nfrom PIL import Image\nimport plotly.graph_objects as go\nimport numpy as np\nimport time\nimport base64\nimport json\nimport math\n\n\ndef latlon_to_meters(lat, lon, origin_lat, origin_lon):\n    \"\"\"Convert lat/lon to local meter coordinates using equirectangular projection\"\"\"\n    dx = (lon - origin_lon) * math.cos(math.radians(origin_lat)) * 111000\n    dy = (lat - origin_lat) * 111000\n    return dx, dy\n\n\ndef render_dxf_floor_plan(fig, floor):\n    \"\"\"Render DXF floor plan (stored as GeoJSON) in local meter coordinates\"\"\"\n    if not floor.floor_plan_geojson:\n        return False\n    \n    try:\n        geojson_data = json.loads(floor.floor_plan_geojson)\n        \n        for feature in geojson_data.get('features', []):\n            props = feature.get('properties', {})\n            geom = feature.get('geometry', {})\n            geom_type = props.get('geomType', '')\n            entity_type = props.get('entityType', '')\n            \n            if geom.get('type') == 'Polygon':\n                coords = geom.get('coordinates', [[]])[0]\n                if coords:\n                    xs = [c[0] for c in coords]\n                    ys = [c[1] for c in coords]\n                    \n                    name = props.get('name', 'Unnamed')\n                    \n                    if geom_type == 'room':\n                        fill_color = 'rgba(46, 92, 191, 0.15)'\n                        line_color = '#2e5cbf'\n                    else:\n                        fill_color = 'rgba(200, 200, 200, 0.1)'\n                        line_color = '#666'\n                    \n                    fig.add_trace(go.Scatter(\n                        x=xs,\n                        y=ys,\n                        fill='toself',\n                        fillcolor=fill_color,\n                        line=dict(color=line_color, width=1),\n                        name=name,\n                        hovertemplate=f\"<b>{name}</b><extra></extra>\",\n                        mode='lines',\n                        showlegend=False\n                    ))\n            \n            elif geom.get('type') == 'LineString':\n                coords = geom.get('coordinates', [])\n                if coords:\n                    xs = [c[0] for c in coords]\n                    ys = [c[1] for c in coords]\n                    \n                    if geom_type == 'wall':\n                        line_width = 2\n                        line_color = '#333'\n                    else:\n                        line_width = 1\n                        line_color = '#666'\n                    \n                    fig.add_trace(go.Scatter(\n                        x=xs,\n                        y=ys,\n                        mode='lines',\n                        line=dict(color=line_color, width=line_width),\n                        showlegend=False,\n                        hoverinfo='skip'\n                    ))\n        \n        return True\n    except Exception as e:\n        return False\n\n\ndef render_geojson_floor_plan(fig, floor):\n    \"\"\"Render GeoJSON floor plan as Plotly traces in meter coordinates\"\"\"\n    if not floor.floor_plan_geojson or not floor.origin_lat or not floor.origin_lon:\n        return False\n    \n    try:\n        geojson_data = json.loads(floor.floor_plan_geojson)\n        \n        for feature in geojson_data.get('features', []):\n            props = feature.get('properties', {})\n            geom = feature.get('geometry', {})\n            geom_type = props.get('geomType', '')\n            \n            if geom_type == 'room' and geom.get('type') == 'Polygon':\n                coords = geom.get('coordinates', [[]])[0]\n                if coords:\n                    xs = []\n                    ys = []\n                    for c in coords:\n                        lon, lat = c[0], c[1]\n                        x, y = latlon_to_meters(lat, lon, floor.origin_lat, floor.origin_lon)\n                        xs.append(x)\n                        ys.append(y)\n                    \n                    name = props.get('name', 'Unnamed')\n                    \n                    fig.add_trace(go.Scatter(\n                        x=xs,\n                        y=ys,\n                        fill='toself',\n                        fillcolor='rgba(46, 92, 191, 0.15)',\n                        line=dict(color='#2e5cbf', width=1),\n                        name=name,\n                        hovertemplate=f\"<b>{name}</b><extra></extra>\",\n                        mode='lines',\n                        showlegend=False\n                    ))\n                    \n                    center_x = sum(xs) / len(xs)\n                    center_y = sum(ys) / len(ys)\n                    fig.add_annotation(\n                        x=center_x,\n                        y=center_y,\n                        text=name[:12],\n                        showarrow=False,\n                        font=dict(size=8, color='#1a1a1a')\n                    )\n            \n            elif geom_type == 'wall' and geom.get('type') == 'LineString':\n                coords = geom.get('coordinates', [])\n                if coords:\n                    xs = []\n                    ys = []\n                    for c in coords:\n                        lon, lat = c[0], c[1]\n                        x, y = latlon_to_meters(lat, lon, floor.origin_lat, floor.origin_lon)\n                        xs.append(x)\n                        ys.append(y)\n                    \n                    wall_type = props.get('subType', 'inner')\n                    line_width = 2 if wall_type == 'outer' else 1\n                    \n                    fig.add_trace(go.Scatter(\n                        x=xs,\n                        y=ys,\n                        mode='lines',\n                        line=dict(color='#333', width=line_width),\n                        showlegend=False,\n                        hoverinfo='skip'\n                    ))\n        \n        return True\n    except Exception as e:\n        return False\n\n\ndef create_floor_plan_base(floor):\n    \"\"\"Create base figure with floor plan image or GeoJSON if available\"\"\"\n    fig = go.Figure()\n    \n    has_floor_plan = False\n    \n    if floor.floor_plan_image:\n        try:\n            image = Image.open(BytesIO(floor.floor_plan_image))\n            buffered = BytesIO()\n            image.save(buffered, format=\"PNG\")\n            img_str = base64.b64encode(buffered.getvalue()).decode()\n            \n            fig.add_layout_image(\n                dict(\n                    source=f\"data:image/png;base64,{img_str}\",\n                    xref=\"x\",\n                    yref=\"y\",\n                    x=0,\n                    y=floor.height_meters,\n                    sizex=floor.width_meters,\n                    sizey=floor.height_meters,\n                    sizing=\"stretch\",\n                    opacity=0.9,\n                    layer=\"below\"\n                )\n            )\n            has_floor_plan = True\n        except Exception as e:\n            pass\n    \n    if not has_floor_plan and floor.floor_plan_geojson:\n        has_floor_plan = render_geojson_floor_plan(fig, floor)\n    \n    if not has_floor_plan and floor.floor_plan_type == 'dxf' and floor.floor_plan_geojson:\n        has_floor_plan = render_dxf_floor_plan(fig, floor)\n    \n    fig.update_layout(\n        xaxis=dict(\n            range=[0, floor.width_meters],\n            title=\"X (meters)\",\n            showgrid=not has_floor_plan,\n            zeroline=False,\n            constrain='domain'\n        ),\n        yaxis=dict(\n            range=[0, floor.height_meters],\n            title=\"Y (meters)\",\n            showgrid=not has_floor_plan,\n            zeroline=False,\n            scaleanchor=\"x\",\n            scaleratio=1\n        ),\n        showlegend=True,\n        legend=dict(x=1.02, y=1, bgcolor='rgba(255,255,255,0.8)'),\n        margin=dict(l=50, r=150, t=50, b=50),\n        height=600,\n        plot_bgcolor='rgba(240,240,240,0.3)' if not has_floor_plan else 'rgba(255,255,255,0)'\n    )\n    \n    return fig, has_floor_plan\n\n\ndef add_gateways_to_figure(fig, gateways_data):\n    \"\"\"Add gateway markers to the figure\"\"\"\n    for gw in gateways_data:\n        fig.add_trace(go.Scatter(\n            x=[gw['x']],\n            y=[gw['y']],\n            mode='markers+text',\n            marker=dict(size=18, color='#2e5cbf', symbol='square', \n                       line=dict(width=2, color='white')),\n            text=[gw['name']],\n            textposition='top center',\n            textfont=dict(size=10, color='#2e5cbf'),\n            name=f\"Gateway: {gw['name']}\",\n            hoverinfo='text',\n            hovertext=f\"<b>Gateway: {gw['name']}</b><br>Position: ({gw['x']:.1f}, {gw['y']:.1f})\"\n        ))\n\n\ndef create_current_location_figure(floor, positions_data, gateways_data, beacon_info):\n    \"\"\"Create figure showing current beacon locations\"\"\"\n    fig, has_image = create_floor_plan_base(floor)\n    add_gateways_to_figure(fig, gateways_data)\n    \n    colors = ['#e63946', '#2a9d8f', '#e76f51', '#9b59b6', '#3498db', '#f39c12', '#1abc9c', '#e74c3c']\n    \n    for idx, (beacon_name, pos_list) in enumerate(positions_data.items()):\n        if not pos_list:\n            continue\n            \n        color = colors[idx % len(colors)]\n        latest = pos_list[-1]\n        info = beacon_info.get(beacon_name, {})\n        \n        fig.add_trace(go.Scatter(\n            x=[latest['x']],\n            y=[latest['y']],\n            mode='markers',\n            marker=dict(size=16, color=color, symbol='circle',\n                       line=dict(width=2, color='white')),\n            name=beacon_name,\n            hoverinfo='text',\n            hovertext=f\"<b>{beacon_name}</b><br>Type: {info.get('type', 'Unknown')}<br>Position: ({latest['x']:.1f}, {latest['y']:.1f})<br>Speed: {latest.get('speed', 0):.2f} m/s\"\n        ))\n    \n    fig.update_layout(title=dict(text=\"Current Locations\", x=0.5, font=dict(size=16)))\n    return fig\n\n\ndef create_spaghetti_figure(floor, positions_data, gateways_data, beacon_info):\n    \"\"\"Create spaghetti map showing movement trails\"\"\"\n    fig, has_image = create_floor_plan_base(floor)\n    add_gateways_to_figure(fig, gateways_data)\n    \n    colors = ['#e63946', '#2a9d8f', '#e76f51', '#9b59b6', '#3498db', '#f39c12', '#1abc9c', '#e74c3c']\n    \n    for idx, (beacon_name, pos_list) in enumerate(positions_data.items()):\n        if not pos_list or len(pos_list) < 2:\n            continue\n            \n        color = colors[idx % len(colors)]\n        info = beacon_info.get(beacon_name, {})\n        \n        trail_x = [p['x'] for p in pos_list]\n        trail_y = [p['y'] for p in pos_list]\n        \n        fig.add_trace(go.Scatter(\n            x=trail_x,\n            y=trail_y,\n            mode='lines',\n            line=dict(color=color, width=3),\n            name=f\"{beacon_name} path\",\n            opacity=0.7,\n            hoverinfo='text',\n            hovertext=f\"<b>{beacon_name}</b><br>Type: {info.get('type', 'Unknown')}<br>Points: {len(pos_list)}\"\n        ))\n        \n        if pos_list:\n            fig.add_trace(go.Scatter(\n                x=[trail_x[0]],\n                y=[trail_y[0]],\n                mode='markers',\n                marker=dict(size=10, color=color, symbol='circle-open', line=dict(width=2)),\n                name=f\"{beacon_name} start\",\n                showlegend=False,\n                hoverinfo='text',\n                hovertext=f\"<b>{beacon_name} START</b><br>Time: {pos_list[0]['timestamp'].strftime('%H:%M:%S')}\"\n            ))\n            \n            fig.add_trace(go.Scatter(\n                x=[trail_x[-1]],\n                y=[trail_y[-1]],\n                mode='markers',\n                marker=dict(size=14, color=color, symbol='circle',\n                           line=dict(width=2, color='white')),\n                name=f\"{beacon_name} current\",\n                showlegend=False,\n                hoverinfo='text',\n                hovertext=f\"<b>{beacon_name} CURRENT</b><br>Time: {pos_list[-1]['timestamp'].strftime('%H:%M:%S')}\"\n            ))\n    \n    fig.update_layout(title=dict(text=\"Spaghetti Map - Movement Trails\", x=0.5, font=dict(size=16)))\n    return fig\n\n\ndef create_heatmap_figure(floor, positions_data, gateways_data):\n    \"\"\"Create heatmap showing dwell time density\"\"\"\n    fig, has_image = create_floor_plan_base(floor)\n    \n    all_x = []\n    all_y = []\n    for beacon_name, pos_list in positions_data.items():\n        for p in pos_list:\n            all_x.append(p['x'])\n            all_y.append(p['y'])\n    \n    if all_x and all_y:\n        grid_size = 30\n        x_bins = np.linspace(0, floor.width_meters, grid_size + 1)\n        y_bins = np.linspace(0, floor.height_meters, grid_size + 1)\n        \n        heatmap_data, x_edges, y_edges = np.histogram2d(\n            all_x, all_y, bins=[x_bins, y_bins]\n        )\n        \n        heatmap_data = heatmap_data.T\n        \n        x_centers = (x_edges[:-1] + x_edges[1:]) / 2\n        y_centers = (y_edges[:-1] + y_edges[1:]) / 2\n        \n        heatmap_data_masked = np.where(heatmap_data > 0, heatmap_data, np.nan)\n        \n        fig.add_trace(go.Heatmap(\n            x=x_centers,\n            y=y_centers,\n            z=heatmap_data_masked,\n            colorscale=[\n                [0, 'rgba(255,255,0,0.3)'],\n                [0.25, 'rgba(255,200,0,0.5)'],\n                [0.5, 'rgba(255,100,0,0.6)'],\n                [0.75, 'rgba(255,50,0,0.7)'],\n                [1, 'rgba(255,0,0,0.8)']\n            ],\n            showscale=True,\n            colorbar=dict(title=\"Density\", x=1.15),\n            hovertemplate='X: %{x:.1f}m<br>Y: %{y:.1f}m<br>Count: %{z}<extra></extra>',\n            zsmooth='best'\n        ))\n    \n    add_gateways_to_figure(fig, gateways_data)\n    \n    fig.update_layout(title=dict(text=\"Heatmap - Dwell Time Density\", x=0.5, font=dict(size=16)))\n    return fig\n\n\ndef render():\n    st.title(\"Live Tracking\")\n    st.markdown(\"Real-time beacon position tracking with floor plan visualization\")\n    \n    with get_db_session() as session:\n        mqtt_config = session.query(MQTTConfig).filter(MQTTConfig.is_active == True).first()\n        \n        if not mqtt_config:\n            st.warning(\"No MQTT broker configured. Please configure MQTT settings first.\")\n            return\n        \n        buildings = session.query(Building).all()\n        if not buildings:\n            st.warning(\"No buildings configured. Please add a building first.\")\n            return\n        \n        col1, col2 = st.columns([1, 3])\n        \n        with col1:\n            st.subheader(\"Location\")\n            \n            building_options = {b.name: b.id for b in buildings}\n            selected_building = st.selectbox(\"Building\", options=list(building_options.keys()))\n            \n            floors = session.query(Floor).filter(\n                Floor.building_id == building_options[selected_building]\n            ).order_by(Floor.floor_number).all()\n            \n            if not floors:\n                st.warning(\"No floor plans for this building.\")\n                return\n            \n            floor_options = {f\"Floor {f.floor_number}: {f.name or ''}\": f.id for f in floors}\n            selected_floor_name = st.selectbox(\"Floor\", options=list(floor_options.keys()))\n            selected_floor_id = floor_options[selected_floor_name]\n            \n            st.markdown(\"---\")\n            st.subheader(\"View Mode\")\n            \n            view_mode = st.radio(\n                \"Visualization\",\n                options=[\"Current Location\", \"Spaghetti Map\", \"Heatmap\"],\n                index=0,\n                help=\"Choose how to display beacon data\",\n                key=\"live_tracking_view_mode\"\n            )\n            \n            st.markdown(\"---\")\n            st.subheader(\"Time Frame\")\n            \n            time_presets = {\n                \"Last 5 minutes\": 5,\n                \"Last 15 minutes\": 15,\n                \"Last 30 minutes\": 30,\n                \"Last 1 hour\": 60,\n                \"Last 2 hours\": 120,\n                \"Last 4 hours\": 240\n            }\n            \n            time_selection = st.selectbox(\n                \"Time Range\",\n                options=list(time_presets.keys()),\n                index=1,\n                key=\"live_tracking_time_range\"\n            )\n            time_minutes = time_presets[time_selection]\n            \n            st.caption(f\"Data from last {time_minutes} min\")\n            \n            st.markdown(\"---\")\n            st.subheader(\"Beacons\")\n            \n            all_beacons = session.query(Beacon).order_by(Beacon.name).all()\n            \n            resource_types = list(set([b.resource_type for b in all_beacons if b.resource_type]))\n            resource_types.sort()\n            \n            if resource_types:\n                filter_by_type = st.multiselect(\n                    \"Filter by Type\",\n                    options=resource_types,\n                    default=[],\n                    help=\"Filter beacons by resource type\"\n                )\n                \n                if filter_by_type:\n                    filtered_beacons = [b for b in all_beacons if b.resource_type in filter_by_type]\n                else:\n                    filtered_beacons = all_beacons\n            else:\n                filtered_beacons = all_beacons\n            \n            beacon_options = {f\"{b.name} ({b.mac_address[-8:]})\": b.id for b in filtered_beacons}\n            \n            select_all = st.checkbox(\"Select All Beacons\", value=True, key=\"live_tracking_select_all\")\n            \n            if select_all:\n                selected_beacon_ids = [b.id for b in filtered_beacons]\n            else:\n                selected_beacon_names = st.multiselect(\n                    \"Select Beacons\",\n                    options=list(beacon_options.keys()),\n                    default=[],\n                    key=\"live_tracking_beacon_select\"\n                )\n                selected_beacon_ids = [beacon_options[name] for name in selected_beacon_names]\n            \n            st.caption(f\"{len(selected_beacon_ids)} beacon(s) selected\")\n            \n            st.markdown(\"---\")\n            st.subheader(\"Controls\")\n            \n            auto_refresh = st.checkbox(\"Auto-refresh\", value=view_mode == \"Current Location\")\n            if auto_refresh:\n                refresh_interval = st.slider(\"Refresh (sec)\", 2, 10, 3)\n            \n            processor = get_signal_processor()\n            processor.check_and_restart()\n            \n            if processor.is_running:\n                st.success(\"Processor: Running\")\n            else:\n                st.warning(\"Processor: Stopped\")\n                if st.button(\"Start Processor\", type=\"primary\"):\n                    if processor.start():\n                        st.rerun()\n            \n            if st.button(\"Refresh Now\"):\n                st.rerun()\n        \n        with col2:\n            floor = session.query(Floor).filter(Floor.id == selected_floor_id).first()\n            \n            if not floor.floor_plan_image and not floor.floor_plan_geojson:\n                st.warning(\"No floor plan uploaded for this floor. Please upload a floor plan in the Buildings section.\")\n                st.info(f\"Current floor dimensions: {floor.width_meters:.1f}m x {floor.height_meters:.1f}m\")\n            \n            gateways = session.query(Gateway).filter(\n                Gateway.floor_id == selected_floor_id,\n                Gateway.is_active == True\n            ).all()\n            \n            gateways_data = [\n                {'name': gw.name, 'x': gw.x_position, 'y': gw.y_position, 'id': gw.id}\n                for gw in gateways\n            ]\n            \n            cutoff_time = datetime.utcnow() - timedelta(minutes=time_minutes)\n            \n            if selected_beacon_ids:\n                beacons_map = {b.id: b for b in session.query(Beacon).filter(\n                    Beacon.id.in_(selected_beacon_ids)\n                ).all()}\n                \n                positions_query = session.query(Position).filter(\n                    Position.floor_id == selected_floor_id,\n                    Position.timestamp >= cutoff_time,\n                    Position.beacon_id.in_(selected_beacon_ids)\n                ).order_by(Position.timestamp.asc())\n                \n                max_points = 5000\n                recent_positions = positions_query.limit(max_points).all()\n            else:\n                beacons_map = {}\n                recent_positions = []\n            \n            positions_data = {}\n            beacon_info = {}\n            for pos in recent_positions:\n                beacon = beacons_map.get(pos.beacon_id)\n                if beacon:\n                    if beacon.name not in positions_data:\n                        positions_data[beacon.name] = []\n                        beacon_info[beacon.name] = {\n                            'mac': beacon.mac_address,\n                            'type': beacon.resource_type,\n                            'id': beacon.id\n                        }\n                    positions_data[beacon.name].append({\n                        'x': pos.x_position,\n                        'y': pos.y_position,\n                        'velocity_x': pos.velocity_x,\n                        'velocity_y': pos.velocity_y,\n                        'speed': pos.speed,\n                        'timestamp': pos.timestamp\n                    })\n            \n            st.subheader(f\"{floor.name or f'Floor {floor.floor_number}'}\")\n            \n            if view_mode == \"Current Location\":\n                fig = create_current_location_figure(floor, positions_data, gateways_data, beacon_info)\n            elif view_mode == \"Spaghetti Map\":\n                fig = create_spaghetti_figure(floor, positions_data, gateways_data, beacon_info)\n            else:\n                fig = create_heatmap_figure(floor, positions_data, gateways_data)\n            \n            st.plotly_chart(fig, key=\"floor_plan_chart\")\n            \n            col_stats1, col_stats2, col_stats3, col_stats4 = st.columns(4)\n            \n            with col_stats1:\n                st.metric(\"Gateways\", len(gateways))\n            \n            with col_stats2:\n                st.metric(\"Beacons Visible\", len(positions_data))\n            \n            with col_stats3:\n                total_points = sum(len(p) for p in positions_data.values())\n                st.metric(\"Data Points\", total_points)\n            \n            with col_stats4:\n                st.metric(\"Time Window\", f\"{time_minutes}m\")\n            \n            if positions_data and view_mode == \"Current Location\":\n                st.markdown(\"---\")\n                st.subheader(\"Beacon Details\")\n                \n                for beacon_name, pos_list in positions_data.items():\n                    if pos_list:\n                        latest = pos_list[-1]\n                        info = beacon_info.get(beacon_name, {})\n                        resource_icon = {\n                            'Staff': 'ðŸ‘¤', 'Patient': 'ðŸ¥', 'Asset': 'ðŸ“¦',\n                            'Device': 'ðŸ“±', 'Vehicle': 'ðŸš—', 'Equipment': 'ðŸ”§'\n                        }.get(info.get('type', ''), 'ðŸ“')\n                        \n                        with st.expander(f\"{resource_icon} {beacon_name}\", expanded=False):\n                            c1, c2, c3 = st.columns(3)\n                            with c1:\n                                st.write(f\"**Position:** ({latest['x']:.1f}, {latest['y']:.1f})\")\n                            with c2:\n                                st.write(f\"**Speed:** {latest.get('speed', 0):.2f} m/s\")\n                            with c3:\n                                st.write(f\"**Updated:** {latest['timestamp'].strftime('%H:%M:%S')}\")\n            \n            elif not positions_data:\n                if selected_beacon_ids:\n                    st.info(\"No position data found for the selected beacons in this time frame. Make sure the signal processor is running.\")\n                else:\n                    st.info(\"Select beacons to display on the floor plan.\")\n            \n            if auto_refresh:\n                time.sleep(refresh_interval)\n                st.rerun()\n","path":null,"size_bytes":24487,"size_tokens":null},"views/calibration.py":{"content":"import streamlit as st\nfrom database import get_db_session, Building, Floor, Gateway, Beacon, Position, CalibrationPoint\nfrom utils.triangulation import rssi_to_distance, GatewayReading, trilaterate_2d\nfrom datetime import datetime, timedelta\nfrom io import BytesIO\nfrom PIL import Image\nimport plotly.graph_objects as go\nimport numpy as np\nimport base64\n\n\ndef render():\n    st.title(\"Calibration Wizard\")\n    st.markdown(\"Improve triangulation accuracy using known beacon positions\")\n    \n    tab1, tab2, tab3 = st.tabs([\"Calibration Points\", \"Run Calibration\", \"Accuracy Analysis\"])\n    \n    with tab1:\n        render_calibration_points()\n    \n    with tab2:\n        render_run_calibration()\n    \n    with tab3:\n        render_accuracy_analysis()\n\n\ndef render_calibration_points():\n    with get_db_session() as session:\n        st.subheader(\"Define Calibration Points\")\n        st.info(\"Place beacons at known positions to create calibration reference points\")\n        \n        buildings = session.query(Building).all()\n        if not buildings:\n            st.warning(\"No buildings configured.\")\n            return\n        \n        with st.form(\"add_calibration_point\"):\n            col1, col2 = st.columns(2)\n            \n            with col1:\n                building_options = {b.name: b.id for b in buildings}\n                selected_building = st.selectbox(\"Building\", options=list(building_options.keys()))\n                \n                floors = session.query(Floor).filter(\n                    Floor.building_id == building_options[selected_building]\n                ).order_by(Floor.floor_number).all()\n                \n                if floors:\n                    floor_options = {f\"Floor {f.floor_number}\": f.id for f in floors}\n                    selected_floor = st.selectbox(\"Floor\", options=list(floor_options.keys()))\n                else:\n                    st.warning(\"No floor plans available.\")\n                    st.form_submit_button(\"Add Calibration Point\", disabled=True)\n                    return\n                \n                beacons = session.query(Beacon).filter(Beacon.is_active == True).all()\n                if beacons:\n                    beacon_options = {f\"{b.name} ({b.mac_address})\": b.id for b in beacons}\n                    selected_beacon = st.selectbox(\"Beacon\", options=list(beacon_options.keys()))\n                else:\n                    st.warning(\"No active beacons.\")\n                    st.form_submit_button(\"Add Calibration Point\", disabled=True)\n                    return\n            \n            with col2:\n                st.write(\"**Known Position (measured manually)**\")\n                known_x = st.number_input(\"X Position (meters)\", value=0.0, min_value=0.0, step=0.1)\n                known_y = st.number_input(\"Y Position (meters)\", value=0.0, min_value=0.0, step=0.1)\n            \n            submitted = st.form_submit_button(\"Add Calibration Point\", type=\"primary\")\n            \n            if submitted:\n                cal_point = CalibrationPoint(\n                    floor_id=floor_options[selected_floor],\n                    beacon_id=beacon_options[selected_beacon],\n                    known_x=known_x,\n                    known_y=known_y,\n                    is_verified=False\n                )\n                session.add(cal_point)\n                st.success(\"Calibration point added!\")\n                st.rerun()\n        \n        st.markdown(\"---\")\n        st.subheader(\"Existing Calibration Points\")\n        \n        cal_points = session.query(CalibrationPoint).all()\n        \n        if cal_points:\n            for cp in cal_points:\n                beacon = session.query(Beacon).filter(Beacon.id == cp.beacon_id).first()\n                floor = session.query(Floor).filter(Floor.id == cp.floor_id).first()\n                \n                status_icon = \"âœ“\" if cp.is_verified else \"?\"\n                error_str = f\"Error: {cp.error_distance:.2f}m\" if cp.error_distance else \"Not measured\"\n                \n                with st.expander(f\"[{status_icon}] {beacon.name if beacon else 'Unknown'} at ({cp.known_x}, {cp.known_y}) - {error_str}\"):\n                    col1, col2, col3 = st.columns([2, 2, 1])\n                    \n                    with col1:\n                        st.write(f\"**Beacon:** {beacon.name if beacon else 'Unknown'}\")\n                        st.write(f\"**Floor:** {floor.name if floor else 'Unknown'}\")\n                        st.write(f\"**Known Position:** ({cp.known_x}, {cp.known_y})\")\n                    \n                    with col2:\n                        if cp.measured_x is not None:\n                            st.write(f\"**Measured Position:** ({cp.measured_x:.2f}, {cp.measured_y:.2f})\")\n                            st.write(f\"**Error Distance:** {cp.error_distance:.2f} m\")\n                        else:\n                            st.write(\"**Measured Position:** Not yet measured\")\n                        st.write(f\"**Verified:** {'Yes' if cp.is_verified else 'No'}\")\n                    \n                    with col3:\n                        if st.button(\"Delete\", key=f\"del_cal_{cp.id}\"):\n                            session.delete(cp)\n                            st.rerun()\n        else:\n            st.info(\"No calibration points defined yet.\")\n\n\ndef render_run_calibration():\n    with get_db_session() as session:\n        st.subheader(\"Run Calibration Measurement\")\n        \n        buildings = session.query(Building).all()\n        if not buildings:\n            st.warning(\"No buildings configured.\")\n            return\n        \n        col1, col2 = st.columns([1, 2])\n        \n        with col1:\n            building_options = {b.name: b.id for b in buildings}\n            selected_building = st.selectbox(\"Building\", options=list(building_options.keys()), key=\"cal_building\")\n            \n            floors = session.query(Floor).filter(\n                Floor.building_id == building_options[selected_building]\n            ).order_by(Floor.floor_number).all()\n            \n            if not floors:\n                st.warning(\"No floor plans.\")\n                return\n            \n            floor_options = {f\"Floor {f.floor_number}\": f.id for f in floors}\n            selected_floor_name = st.selectbox(\"Floor\", options=list(floor_options.keys()), key=\"cal_floor\")\n            selected_floor_id = floor_options[selected_floor_name]\n            \n            cal_points = session.query(CalibrationPoint).filter(\n                CalibrationPoint.floor_id == selected_floor_id\n            ).all()\n            \n            if not cal_points:\n                st.warning(\"No calibration points on this floor. Add some in the 'Calibration Points' tab.\")\n                return\n            \n            st.write(f\"**Calibration points on this floor:** {len(cal_points)}\")\n            \n            measurement_duration = st.slider(\"Measurement Duration (seconds)\", 5, 60, 15)\n            \n            if st.button(\"Start Calibration Measurement\", type=\"primary\"):\n                st.session_state['calibration_running'] = True\n                st.session_state['calibration_start'] = datetime.utcnow()\n                st.session_state['calibration_duration'] = measurement_duration\n                st.rerun()\n        \n        with col2:\n            floor = session.query(Floor).filter(Floor.id == selected_floor_id).first()\n            \n            if st.session_state.get('calibration_running'):\n                start_time = st.session_state['calibration_start']\n                duration = st.session_state['calibration_duration']\n                elapsed = (datetime.utcnow() - start_time).total_seconds()\n                \n                if elapsed < duration:\n                    progress = elapsed / duration\n                    st.progress(progress, text=f\"Measuring... {int(elapsed)}/{duration} seconds\")\n                    \n                    import time\n                    time.sleep(1)\n                    st.rerun()\n                else:\n                    st.success(\"Measurement complete! Processing results...\")\n                    \n                    end_time = datetime.utcnow()\n                    \n                    for cp in cal_points:\n                        positions = session.query(Position).filter(\n                            Position.beacon_id == cp.beacon_id,\n                            Position.floor_id == cp.floor_id,\n                            Position.timestamp >= start_time,\n                            Position.timestamp <= end_time\n                        ).all()\n                        \n                        if positions:\n                            avg_x = np.mean([p.x_position for p in positions])\n                            avg_y = np.mean([p.y_position for p in positions])\n                            \n                            error = np.sqrt((avg_x - cp.known_x)**2 + (avg_y - cp.known_y)**2)\n                            \n                            cp.measured_x = avg_x\n                            cp.measured_y = avg_y\n                            cp.error_distance = error\n                            cp.timestamp = datetime.utcnow()\n                            cp.is_verified = True\n                    \n                    st.session_state['calibration_running'] = False\n                    st.rerun()\n            else:\n                gateways = session.query(Gateway).filter(\n                    Gateway.floor_id == selected_floor_id,\n                    Gateway.is_active == True\n                ).all()\n                \n                fig = go.Figure()\n                \n                if floor.floor_plan_image:\n                    try:\n                        image = Image.open(BytesIO(floor.floor_plan_image))\n                        buffered = BytesIO()\n                        image.save(buffered, format=\"PNG\")\n                        img_str = base64.b64encode(buffered.getvalue()).decode()\n                        \n                        fig.add_layout_image(\n                            dict(\n                                source=f\"data:image/png;base64,{img_str}\",\n                                xref=\"x\",\n                                yref=\"y\",\n                                x=0,\n                                y=floor.height_meters,\n                                sizex=floor.width_meters,\n                                sizey=floor.height_meters,\n                                sizing=\"stretch\",\n                                opacity=0.6,\n                                layer=\"below\"\n                            )\n                        )\n                    except Exception:\n                        pass\n                \n                for gw in gateways:\n                    fig.add_trace(go.Scatter(\n                        x=[gw.x_position],\n                        y=[gw.y_position],\n                        mode='markers',\n                        marker=dict(size=12, color='blue', symbol='square'),\n                        name=f\"Gateway: {gw.name}\"\n                    ))\n                \n                for cp in cal_points:\n                    beacon = session.query(Beacon).filter(Beacon.id == cp.beacon_id).first()\n                    \n                    fig.add_trace(go.Scatter(\n                        x=[cp.known_x],\n                        y=[cp.known_y],\n                        mode='markers+text',\n                        marker=dict(size=15, color='green', symbol='diamond'),\n                        text=[beacon.name if beacon else 'Unknown'],\n                        textposition='top center',\n                        name=f\"Known: {beacon.name if beacon else 'Unknown'}\"\n                    ))\n                    \n                    if cp.measured_x is not None:\n                        fig.add_trace(go.Scatter(\n                            x=[cp.measured_x],\n                            y=[cp.measured_y],\n                            mode='markers',\n                            marker=dict(size=12, color='red', symbol='x'),\n                            name=f\"Measured: {beacon.name if beacon else 'Unknown'}\"\n                        ))\n                        \n                        fig.add_shape(\n                            type=\"line\",\n                            x0=cp.known_x, y0=cp.known_y,\n                            x1=cp.measured_x, y1=cp.measured_y,\n                            line=dict(color=\"red\", width=2, dash=\"dash\")\n                        )\n                \n                fig.update_layout(\n                    xaxis=dict(range=[0, floor.width_meters], title=\"X (meters)\"),\n                    yaxis=dict(range=[0, floor.height_meters], title=\"Y (meters)\", scaleanchor=\"x\"),\n                    height=500,\n                    showlegend=True,\n                    title=\"Calibration Points Map\"\n                )\n                \n                st.plotly_chart(fig, use_container_width=True)\n\n\ndef render_accuracy_analysis():\n    with get_db_session() as session:\n        st.subheader(\"Accuracy Analysis & Recommendations\")\n        \n        verified_points = session.query(CalibrationPoint).filter(\n            CalibrationPoint.is_verified == True\n        ).all()\n        \n        if not verified_points:\n            st.info(\"No verified calibration measurements yet. Run calibration first.\")\n            return\n        \n        errors = [cp.error_distance for cp in verified_points if cp.error_distance]\n        \n        if not errors:\n            st.warning(\"No error measurements available.\")\n            return\n        \n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\"Calibration Points\", len(verified_points))\n        \n        with col2:\n            avg_error = np.mean(errors)\n            st.metric(\"Average Error\", f\"{avg_error:.2f} m\")\n        \n        with col3:\n            max_error = np.max(errors)\n            st.metric(\"Max Error\", f\"{max_error:.2f} m\")\n        \n        with col4:\n            min_error = np.min(errors)\n            st.metric(\"Min Error\", f\"{min_error:.2f} m\")\n        \n        fig = go.Figure()\n        \n        beacon_names = []\n        for cp in verified_points:\n            beacon = session.query(Beacon).filter(Beacon.id == cp.beacon_id).first()\n            beacon_names.append(beacon.name if beacon else f\"Beacon {cp.beacon_id}\")\n        \n        fig.add_trace(go.Bar(\n            x=beacon_names,\n            y=errors,\n            marker_color=['green' if e < 2 else 'orange' if e < 5 else 'red' for e in errors]\n        ))\n        \n        fig.update_layout(\n            title=\"Error Distance by Calibration Point\",\n            xaxis_title=\"Calibration Point\",\n            yaxis_title=\"Error (meters)\",\n            height=400\n        )\n        \n        st.plotly_chart(fig, use_container_width=True)\n        \n        st.subheader(\"Calibration Recommendations\")\n        \n        if avg_error > 5:\n            st.error(\"High average error detected. Consider the following:\")\n            st.markdown(\"\"\"\n            - **Increase the number of gateways** - More gateways improve triangulation accuracy\n            - **Adjust signal calibration values** - The TX power setting might be incorrect\n            - **Check for signal interference** - Metal objects or walls can affect RSSI readings\n            - **Increase path loss exponent** - Indoor environments typically need higher values (2.5-4.0)\n            \"\"\")\n        elif avg_error > 2:\n            st.warning(\"Moderate accuracy. Improvements possible:\")\n            st.markdown(\"\"\"\n            - **Fine-tune path loss exponent** - Try values between 2.5 and 3.5\n            - **Add more calibration points** - Better coverage improves overall accuracy\n            - **Consider gateway placement** - Ensure good coverage without obstructions\n            \"\"\")\n        else:\n            st.success(\"Good accuracy! Your system is well calibrated.\")\n            st.markdown(\"\"\"\n            - System is performing within acceptable parameters\n            - Continue monitoring for any degradation over time\n            - Consider adding more calibration points for even better accuracy\n            \"\"\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Suggested Gateway Adjustments\")\n        \n        gateways = session.query(Gateway).filter(Gateway.is_active == True).all()\n        \n        if gateways:\n            for gw in gateways:\n                with st.expander(f\"Gateway: {gw.name}\"):\n                    col1, col2 = st.columns(2)\n                    \n                    with col1:\n                        st.write(f\"**Current Calibration:** {gw.signal_strength_calibration} dBm\")\n                        st.write(f\"**Current Path Loss:** {gw.path_loss_exponent}\")\n                    \n                    with col2:\n                        new_calibration = st.number_input(\n                            \"Signal Calibration (dBm)\",\n                            value=float(gw.signal_strength_calibration),\n                            min_value=-100.0,\n                            max_value=0.0,\n                            key=f\"cal_{gw.id}\"\n                        )\n                        \n                        new_path_loss = st.number_input(\n                            \"Path Loss Exponent\",\n                            value=float(gw.path_loss_exponent),\n                            min_value=1.0,\n                            max_value=6.0,\n                            step=0.1,\n                            key=f\"pl_{gw.id}\"\n                        )\n                        \n                        if st.button(\"Update\", key=f\"update_{gw.id}\"):\n                            gw.signal_strength_calibration = new_calibration\n                            gw.path_loss_exponent = new_path_loss\n                            st.success(\"Gateway updated!\")\n                            st.rerun()\n","path":null,"size_bytes":17855,"size_tokens":null},"views/signal_monitor.py":{"content":"import streamlit as st\nfrom database import get_db_session, Gateway, Beacon, RSSISignal, Position, MQTTConfig, Floor\nfrom utils.triangulation import GatewayReading, trilaterate_2d, calculate_velocity, filter_outlier_readings\nfrom utils.signal_processor import get_signal_processor\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import func\nimport time\n\n\ndef render():\n    st.title(\"Signal Monitor\")\n    st.markdown(\"Monitor incoming RSSI signals and process beacon positions\")\n    \n    with get_db_session() as session:\n        mqtt_config = session.query(MQTTConfig).filter(MQTTConfig.is_active == True).first()\n        \n        col1, col2 = st.columns([1, 2])\n        \n        with col1:\n            st.subheader(\"MQTT Status\")\n            \n            if mqtt_config:\n                st.success(f\"Broker: {mqtt_config.broker_host}:{mqtt_config.broker_port}\")\n                st.write(f\"Topic: {mqtt_config.topic_prefix}#\")\n                \n                processor = get_signal_processor()\n                \n                st.markdown(\"---\")\n                st.subheader(\"Signal Processor\")\n                \n                if processor.is_running:\n                    st.success(\"ðŸŸ¢ Running\")\n                    stats = processor.stats\n                    st.write(f\"**Signals received:** {stats['signals_received']}\")\n                    st.write(f\"**Signals stored:** {stats['signals_stored']}\")\n                    st.write(f\"**Positions calculated:** {stats['positions_calculated']}\")\n                    if stats['errors'] > 0:\n                        st.warning(f\"**Errors:** {stats['errors']}\")\n                    if processor.last_error:\n                        st.error(f\"Last error: {processor.last_error}\")\n                    \n                    if st.button(\"Stop Processing\"):\n                        processor.stop()\n                        st.rerun()\n                else:\n                    st.warning(\"ðŸ”´ Stopped\")\n                    if processor.last_error:\n                        st.error(f\"Error: {processor.last_error}\")\n                    \n                    if st.button(\"Start Processing\", type=\"primary\"):\n                        if processor.start():\n                            st.success(\"Processor started!\")\n                            st.rerun()\n                        else:\n                            st.error(processor.last_error or \"Failed to start\")\n            else:\n                st.error(\"No MQTT broker configured\")\n                st.info(\"Go to MQTT Configuration to set up your broker\")\n            \n            st.markdown(\"---\")\n            st.subheader(\"Manual Signal Entry\")\n            st.caption(\"For testing without live gateways\")\n            \n            with st.form(\"manual_signal\"):\n                gateways = session.query(Gateway).filter(Gateway.is_active == True).all()\n                beacons = session.query(Beacon).filter(Beacon.is_active == True).all()\n                \n                if gateways and beacons:\n                    gateway_options = {f\"{g.name} ({g.mac_address})\": g.id for g in gateways}\n                    beacon_options = {f\"{b.name} ({b.mac_address})\": b.id for b in beacons}\n                    \n                    selected_gateway = st.selectbox(\"Gateway\", options=list(gateway_options.keys()))\n                    selected_beacon = st.selectbox(\"Beacon\", options=list(beacon_options.keys()))\n                    rssi_value = st.slider(\"RSSI (dBm)\", -100, -20, -65)\n                    tx_power = st.number_input(\"TX Power\", value=-59, min_value=-100, max_value=0)\n                    \n                    if st.form_submit_button(\"Add Signal\"):\n                        signal = RSSISignal(\n                            gateway_id=gateway_options[selected_gateway],\n                            beacon_id=beacon_options[selected_beacon],\n                            rssi=rssi_value,\n                            tx_power=tx_power,\n                            timestamp=datetime.utcnow()\n                        )\n                        session.add(signal)\n                        st.success(\"Signal added!\")\n                        st.rerun()\n                else:\n                    st.warning(\"Add gateways and beacons first\")\n                    st.form_submit_button(\"Add Signal\", disabled=True)\n        \n        with col2:\n            st.subheader(\"Recent Signals\")\n            \n            one_minute_ago = datetime.utcnow() - timedelta(minutes=1)\n            recent_signals = session.query(RSSISignal).filter(\n                RSSISignal.timestamp >= one_minute_ago\n            ).order_by(RSSISignal.timestamp.desc()).limit(50).all()\n            \n            if recent_signals:\n                signal_data = []\n                for sig in recent_signals:\n                    gateway = session.query(Gateway).filter(Gateway.id == sig.gateway_id).first()\n                    beacon = session.query(Beacon).filter(Beacon.id == sig.beacon_id).first()\n                    \n                    signal_data.append({\n                        'Time': sig.timestamp.strftime('%H:%M:%S'),\n                        'Gateway': gateway.name if gateway else 'Unknown',\n                        'Beacon': beacon.name if beacon else 'Unknown',\n                        'RSSI': f\"{sig.rssi} dBm\",\n                        'TX Power': f\"{sig.tx_power or -59} dBm\"\n                    })\n                \n                st.dataframe(signal_data, use_container_width=True, height=300)\n            else:\n                st.info(\"No signals received in the last minute\")\n            \n            st.markdown(\"---\")\n            st.subheader(\"Recent Positions\")\n            \n            recent_positions = session.query(Position).order_by(\n                Position.timestamp.desc()\n            ).limit(20).all()\n            \n            if recent_positions:\n                pos_data = []\n                for pos in recent_positions:\n                    beacon = session.query(Beacon).filter(Beacon.id == pos.beacon_id).first()\n                    floor = session.query(Floor).filter(Floor.id == pos.floor_id).first()\n                    \n                    pos_data.append({\n                        'Time': pos.timestamp.strftime('%H:%M:%S'),\n                        'Beacon': beacon.name if beacon else 'Unknown',\n                        'Floor': floor.name if floor else 'Unknown',\n                        'X': f\"{pos.x_position:.2f}m\",\n                        'Y': f\"{pos.y_position:.2f}m\",\n                        'Speed': f\"{pos.speed:.2f} m/s\",\n                        'Accuracy': f\"Â±{pos.accuracy:.2f}m\"\n                    })\n                \n                st.dataframe(pos_data, use_container_width=True)\n            else:\n                st.info(\"No positions calculated yet\")\n        \n        st.markdown(\"---\")\n        \n        st.subheader(\"Signal Statistics\")\n        \n        col_stat1, col_stat2, col_stat3, col_stat4 = st.columns(4)\n        \n        one_hour_ago = datetime.utcnow() - timedelta(hours=1)\n        one_minute_ago = datetime.utcnow() - timedelta(minutes=1)\n        \n        with col_stat1:\n            total_signals = session.query(func.count(RSSISignal.id)).filter(\n                RSSISignal.timestamp >= one_hour_ago\n            ).scalar()\n            st.metric(\"Signals (1 hour)\", total_signals)\n        \n        with col_stat2:\n            total_positions = session.query(func.count(Position.id)).filter(\n                Position.timestamp >= one_hour_ago\n            ).scalar()\n            st.metric(\"Positions (1 hour)\", total_positions)\n        \n        with col_stat3:\n            active_gateways = session.query(func.count(func.distinct(RSSISignal.gateway_id))).filter(\n                RSSISignal.timestamp >= one_minute_ago\n            ).scalar()\n            st.metric(\"Active Gateways\", active_gateways)\n        \n        with col_stat4:\n            active_beacons = session.query(func.count(func.distinct(RSSISignal.beacon_id))).filter(\n                RSSISignal.timestamp >= one_minute_ago\n            ).scalar()\n            st.metric(\"Active Beacons\", active_beacons)\n        \n        if st.button(\"Refresh Page\"):\n            st.rerun()\n","path":null,"size_bytes":8179,"size_tokens":null},"utils/mqtt_handler.py":{"content":"import json\nimport os\nimport threading\nimport time\nimport ssl\nfrom datetime import datetime\nfrom typing import Callable, Optional, Dict, Any\nimport paho.mqtt.client as mqtt\nfrom dataclasses import dataclass\nimport queue\n\n\n@dataclass\nclass MQTTMessage:\n    \"\"\"Parsed MQTT message from gateway\"\"\"\n    gateway_mac: str\n    beacon_mac: str\n    rssi: int\n    tx_power: int\n    timestamp: datetime\n    raw_data: str\n\n\nclass MQTTHandler:\n    \"\"\"MQTT client handler for receiving BLE gateway data\"\"\"\n    \n    def __init__(\n        self,\n        broker_host: str,\n        broker_port: int = 1883,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        topic_prefix: str = \"ble/gateway/\",\n        use_tls: bool = False,\n        ca_cert_path: Optional[str] = None\n    ):\n        self.broker_host = broker_host\n        self.broker_port = broker_port\n        self.username = username\n        self.password = password\n        self.topic_prefix = topic_prefix\n        self.use_tls = use_tls\n        self.ca_cert_path = ca_cert_path\n        \n        self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)\n        self.client.on_connect = self._on_connect\n        self.client.on_disconnect = self._on_disconnect\n        self.client.on_message = self._on_message\n        \n        if username and password:\n            self.client.username_pw_set(username, password)\n        \n        if use_tls:\n            if ca_cert_path and os.path.exists(ca_cert_path):\n                self.client.tls_set(\n                    ca_certs=ca_cert_path,\n                    cert_reqs=ssl.CERT_REQUIRED,\n                    tls_version=ssl.PROTOCOL_TLSv1_2\n                )\n            else:\n                self.client.tls_set(\n                    cert_reqs=ssl.CERT_REQUIRED,\n                    tls_version=ssl.PROTOCOL_TLS\n                )\n            self.client.tls_insecure_set(False)\n        \n        self.is_connected = False\n        self.message_queue = queue.Queue(maxsize=10000)\n        self.callbacks: list[Callable[[MQTTMessage], None]] = []\n        self._running = False\n        self._thread: Optional[threading.Thread] = None\n        self.last_error: Optional[str] = None\n    \n    def _on_connect(self, client, userdata, flags, reason_code, properties=None):\n        \"\"\"Callback when connected to broker\"\"\"\n        if reason_code == 0:\n            self.is_connected = True\n            self.last_error = None\n            if self.topic_prefix and self.topic_prefix.strip():\n                topic = self.topic_prefix.strip()\n                \n                if ',' in topic:\n                    topics = [t.strip() for t in topic.split(',') if t.strip()]\n                    for t in topics:\n                        try:\n                            client.subscribe(t)\n                            print(f\"Subscribed to topic: {t}\")\n                        except ValueError as e:\n                            print(f\"Invalid subscription topic '{t}': {e}\")\n                else:\n                    if '+' in topic or '#' in topic:\n                        pass\n                    elif not topic.endswith('/') and not topic.endswith('#'):\n                        topic = f\"{topic}/#\"\n                    elif topic.endswith('/'):\n                        topic = f\"{topic}#\"\n                    try:\n                        client.subscribe(topic)\n                        print(f\"Connected to MQTT broker, subscribed to {topic}\")\n                    except ValueError as e:\n                        print(f\"Invalid subscription topic '{topic}': {e}\")\n            else:\n                print(f\"Connected to MQTT broker (no subscription - publish only)\")\n        else:\n            self.is_connected = False\n            self.last_error = f\"Connection failed with code: {reason_code}\"\n            print(f\"Failed to connect: {reason_code}\")\n    \n    def _on_disconnect(self, client, userdata, flags, reason_code, properties=None):\n        \"\"\"Callback when disconnected from broker\"\"\"\n        self.is_connected = False\n        if reason_code != 0:\n            self.last_error = f\"Unexpected disconnection: {reason_code}\"\n            print(f\"Disconnected unexpectedly: {reason_code}\")\n    \n    def _on_message(self, client, userdata, msg):\n        \"\"\"Callback when message received\"\"\"\n        try:\n            parsed_message = self._parse_message(msg.topic, msg.payload)\n            if parsed_message:\n                try:\n                    self.message_queue.put_nowait(parsed_message)\n                except queue.Full:\n                    self.message_queue.get()\n                    self.message_queue.put_nowait(parsed_message)\n                \n                for callback in self.callbacks:\n                    try:\n                        callback(parsed_message)\n                    except Exception:\n                        pass\n        except Exception:\n            pass\n    \n    def _parse_message(self, topic: str, payload: bytes) -> Optional[MQTTMessage]:\n        \"\"\"\n        Parse incoming MQTT message from Moko MKGW-mini03 gateway (CFS/Careflow).\n        \n        Topic format: /cfs1/{gateway_mac}/send or /cfs2/{gateway_mac}/send\n        \n        Moko MKGW-mini03 format (JSON):\n        {\n            \"msg_id\": \"12345\",\n            \"device_info\": {\n                \"mac\": \"00E04C006BF1\",  # gateway MAC (no colons)\n                \"timestamp\": 1699999999\n            },\n            \"beacons\": [\n                {\n                    \"type\": \"iBeacon\",\n                    \"mac\": \"AABBCCDDEEFF\",  # beacon MAC (no colons)\n                    \"rssi\": -65,\n                    \"raw_data\": \"0201061AFF4C000215...\",\n                    \"uuid\": \"FDA50693-A4E2-4FB1-AFCF-C6EB07647825\",\n                    \"major\": 100,\n                    \"minor\": 1,\n                    \"tx_power\": -59\n                }\n            ]\n        }\n        \n        Also supports simple format:\n        {\n            \"gatewayMac\": \"AA:BB:CC:DD:EE:FF\",\n            \"mac\": \"11:22:33:44:55:66\",\n            \"rssi\": -65,\n            \"txPower\": -59,\n            \"timestamp\": 1699999999\n        }\n        \"\"\"\n        try:\n            raw_data = payload.decode('utf-8')\n            data = json.loads(raw_data)\n            \n            topic_parts = topic.split('/')\n            gateway_mac_from_topic = \"\"\n            for i, part in enumerate(topic_parts):\n                if len(part) == 12 and all(c in '0123456789abcdefABCDEF' for c in part):\n                    gateway_mac_from_topic = ':'.join(part[j:j+2].upper() for j in range(0, 12, 2))\n                    break\n            \n            if 'device_info' in data and ('beacons' in data or 'data' in data):\n                device_info = data.get('device_info', {})\n                gateway_mac_raw = device_info.get('mac', '')\n                if len(gateway_mac_raw) == 12:\n                    gateway_mac = ':'.join(gateway_mac_raw[j:j+2].upper() for j in range(0, 12, 2))\n                else:\n                    gateway_mac = gateway_mac_raw.upper()\n                \n                if not gateway_mac and gateway_mac_from_topic:\n                    gateway_mac = gateway_mac_from_topic\n                \n                device_timestamp = device_info.get('timestamp')\n                if device_timestamp:\n                    if isinstance(device_timestamp, (int, float)):\n                        if device_timestamp > 1e12:\n                            base_timestamp = datetime.fromtimestamp(device_timestamp / 1000)\n                        else:\n                            base_timestamp = datetime.fromtimestamp(device_timestamp)\n                    else:\n                        base_timestamp = datetime.utcnow()\n                else:\n                    base_timestamp = datetime.utcnow()\n                \n                beacons = data.get('beacons', []) or data.get('data', [])\n                \n                if not isinstance(beacons, list):\n                    return None\n                \n                if not beacons:\n                    return None\n                \n                # Debug: Log all beacon MACs in this message\n                beacon_macs = [b.get('mac', 'unknown') for b in beacons if isinstance(b, dict)]\n                if len(beacon_macs) > 0:\n                    print(f\"[MQTT DEBUG] Gateway {gateway_mac} sent {len(beacon_macs)} beacons: {beacon_macs}\")\n                \n                messages = []\n                for beacon in beacons:\n                    if not isinstance(beacon, dict):\n                        continue\n                    beacon_mac_raw = beacon.get('mac', '')\n                    if len(beacon_mac_raw) == 12:\n                        beacon_mac = ':'.join(beacon_mac_raw[j:j+2].upper() for j in range(0, 12, 2))\n                    else:\n                        beacon_mac = beacon_mac_raw.upper().replace('-', ':')\n                    \n                    if not beacon_mac:\n                        continue\n                    \n                    rssi = int(beacon.get('rssi', beacon.get('RSSI', -100)))\n                    tx_power = int(beacon.get('tx_power', beacon.get('txPower', beacon.get('measured_power', -59))))\n                    \n                    msg = MQTTMessage(\n                        gateway_mac=gateway_mac,\n                        beacon_mac=beacon_mac,\n                        rssi=rssi,\n                        tx_power=tx_power,\n                        timestamp=base_timestamp,\n                        raw_data=json.dumps(beacon)\n                    )\n                    messages.append(msg)\n                \n                if messages:\n                    for msg in messages[1:]:\n                        try:\n                            self.message_queue.put_nowait(msg)\n                        except queue.Full:\n                            self.message_queue.get()\n                            self.message_queue.put_nowait(msg)\n                        for callback in self.callbacks:\n                            try:\n                                callback(msg)\n                            except Exception as e:\n                                print(f\"Callback error: {e}\")\n                    \n                    return messages[0] if messages else None\n                return None\n            \n            gateway_mac = data.get('gatewayMac') or data.get('gateway_mac', '')\n            beacon_mac = data.get('mac') or data.get('bleMAC') or data.get('beacon_mac', '')\n            \n            if 'gatewayMac' not in data and 'gateway_mac' not in data:\n                if 'type' in data and data.get('type') == 'Gateway':\n                    gateway_mac = data.get('mac', '')\n                    beacon_mac = data.get('bleMAC', '')\n                elif gateway_mac_from_topic:\n                    gateway_mac = gateway_mac_from_topic\n            \n            if not gateway_mac and gateway_mac_from_topic:\n                gateway_mac = gateway_mac_from_topic\n            \n            rssi = int(data.get('rssi', data.get('RSSI', -100)))\n            tx_power = int(data.get('txPower', data.get('txpower', data.get('tx_power', -59))))\n            \n            timestamp_val = data.get('timestamp') or data.get('time')\n            if timestamp_val:\n                if isinstance(timestamp_val, (int, float)):\n                    if timestamp_val > 1e12:\n                        timestamp = datetime.fromtimestamp(timestamp_val / 1000)\n                    else:\n                        timestamp = datetime.fromtimestamp(timestamp_val)\n                else:\n                    timestamp = datetime.utcnow()\n            else:\n                timestamp = datetime.utcnow()\n            \n            if not beacon_mac:\n                print(f\"[MQTT DEBUG] No beacon MAC found in message: {raw_data[:200]}\")\n                return None\n            \n            return MQTTMessage(\n                gateway_mac=gateway_mac.upper() if gateway_mac else \"\",\n                beacon_mac=beacon_mac.upper(),\n                rssi=rssi,\n                tx_power=tx_power,\n                timestamp=timestamp,\n                raw_data=raw_data\n            )\n        except json.JSONDecodeError as e:\n            print(f\"[MQTT DEBUG] JSON decode error: {e}, payload: {payload[:200]}\")\n            return None\n        except Exception as e:\n            print(f\"Parse error: {e}\")\n            import traceback\n            traceback.print_exc()\n            return None\n    \n    def add_callback(self, callback: Callable[[MQTTMessage], None]):\n        \"\"\"Add a callback function to be called on each message\"\"\"\n        self.callbacks.append(callback)\n    \n    def remove_callback(self, callback: Callable[[MQTTMessage], None]):\n        \"\"\"Remove a callback function\"\"\"\n        if callback in self.callbacks:\n            self.callbacks.remove(callback)\n    \n    def connect(self, timeout: int = 10) -> bool:\n        \"\"\"Connect to the MQTT broker with timeout\"\"\"\n        try:\n            self.client.connect(self.broker_host, self.broker_port, keepalive=60)\n            self.client.loop_start()\n            \n            import time\n            start_time = time.time()\n            while not self.is_connected and (time.time() - start_time) < timeout:\n                time.sleep(0.1)\n            \n            if not self.is_connected:\n                self.client.loop_stop()\n                self.last_error = self.last_error or \"Connection timeout - broker did not confirm connection\"\n                return False\n            \n            return True\n        except ssl.SSLCertVerificationError as e:\n            self.last_error = f\"SSL certificate error: {e}. Try enabling 'Use TLS/SSL' in config.\"\n            print(f\"SSL error: {e}\")\n            return False\n        except ConnectionRefusedError as e:\n            self.last_error = f\"Connection refused. Check host/port and firewall settings.\"\n            print(f\"Connection refused: {e}\")\n            return False\n        except OSError as e:\n            if \"timed out\" in str(e).lower():\n                self.last_error = f\"Connection timed out. Ensure broker is reachable and port {self.broker_port} is correct.\"\n            else:\n                self.last_error = f\"Network error: {e}\"\n            print(f\"Connection error: {e}\")\n            return False\n        except Exception as e:\n            self.last_error = str(e)\n            print(f\"Connection error: {e}\")\n            return False\n    \n    def disconnect(self):\n        \"\"\"Disconnect from the broker\"\"\"\n        self._running = False\n        self.client.disconnect()\n        if self._thread and self._thread.is_alive():\n            self._thread.join(timeout=2)\n    \n    def start(self):\n        \"\"\"Start the MQTT client in a background thread\"\"\"\n        if not self._running:\n            self._running = True\n            self.client.loop_start()\n    \n    def stop(self):\n        \"\"\"Stop the MQTT client\"\"\"\n        self._running = False\n        self.client.loop_stop()\n    \n    def get_messages(self, max_count: int = 100) -> list[MQTTMessage]:\n        \"\"\"Get pending messages from the queue\"\"\"\n        messages = []\n        while len(messages) < max_count:\n            try:\n                msg = self.message_queue.get_nowait()\n                messages.append(msg)\n            except queue.Empty:\n                break\n        return messages\n    \n    def publish(self, topic: str, payload: Dict[str, Any]) -> bool:\n        \"\"\"Publish a message to a topic\"\"\"\n        try:\n            result = self.client.publish(topic, json.dumps(payload))\n            return result.rc == mqtt.MQTT_ERR_SUCCESS\n        except Exception as e:\n            print(f\"Publish error: {e}\")\n            return False\n\n\ndef create_mqtt_handler_from_config(config: dict) -> MQTTHandler:\n    \"\"\"Create an MQTT handler from configuration dictionary\"\"\"\n    return MQTTHandler(\n        broker_host=config.get('broker_host', 'localhost'),\n        broker_port=config.get('broker_port', 1883),\n        username=config.get('username'),\n        password=config.get('password'),\n        topic_prefix=config.get('topic_prefix', 'ble/gateway/'),\n        use_tls=config.get('use_tls', False),\n        ca_cert_path=config.get('ca_cert_path')\n    )\n","path":null,"size_bytes":16157,"size_tokens":null},"views/dashboard.py":{"content":"import streamlit as st\nfrom database import get_db_session, Building, Floor, Gateway, Beacon, Position, RSSISignal, MQTTConfig\nfrom utils.signal_processor import get_signal_processor\nfrom sqlalchemy import func\nfrom datetime import datetime, timedelta\n\n\ndef render():\n    st.title(\"Dashboard\")\n    st.caption(\"Overview of your BLE Indoor Positioning System\")\n    \n    with get_db_session() as session:\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            building_count = session.query(func.count(Building.id)).scalar()\n            st.metric(\"Buildings\", building_count)\n        \n        with col2:\n            gateway_count = session.query(func.count(Gateway.id)).scalar()\n            active_gateways = session.query(func.count(Gateway.id)).filter(Gateway.is_active == True).scalar()\n            st.metric(\"Gateways\", f\"{active_gateways}/{gateway_count}\", help=\"Active/Total\")\n        \n        with col3:\n            beacon_count = session.query(func.count(Beacon.id)).scalar()\n            active_beacons = session.query(func.count(Beacon.id)).filter(Beacon.is_active == True).scalar()\n            st.metric(\"Beacons\", f\"{active_beacons}/{beacon_count}\", help=\"Active/Total\")\n        \n        with col4:\n            floor_count = session.query(func.count(Floor.id)).scalar()\n            st.metric(\"Floor Plans\", floor_count)\n        \n        st.markdown(\"---\")\n        \n        col_left, col_right = st.columns(2)\n        \n        with col_left:\n            with st.container(border=True):\n                st.subheader(\"Signal Processing Status\")\n                processor = get_signal_processor()\n                \n                if processor.is_running:\n                    st.success(\"Running\")\n                    stats = processor.stats\n                    col_a, col_b, col_c = st.columns(3)\n                    col_a.metric(\"Received\", stats['signals_received'])\n                    col_b.metric(\"Stored\", stats['signals_stored'])\n                    col_c.metric(\"Positions\", stats['positions_calculated'])\n                    if stats['errors'] > 0:\n                        st.warning(f\"Errors: {stats['errors']}\")\n                else:\n                    st.warning(\"Stopped\")\n                    if processor.last_error:\n                        st.error(f\"Last error: {processor.last_error}\")\n                    st.info(\"Go to Signal Monitor to start processing\")\n            \n            with st.container(border=True):\n                st.subheader(\"Recent Activity\")\n                \n                one_hour_ago = datetime.utcnow() - timedelta(hours=1)\n                recent_signals = session.query(func.count(RSSISignal.id)).filter(\n                    RSSISignal.timestamp >= one_hour_ago\n                ).scalar()\n                \n                recent_positions = session.query(func.count(Position.id)).filter(\n                    Position.timestamp >= one_hour_ago\n                ).scalar()\n                \n                col_a, col_b = st.columns(2)\n                col_a.metric(\"Signals (1h)\", recent_signals)\n                col_b.metric(\"Positions (1h)\", recent_positions)\n                \n                mqtt_config = session.query(MQTTConfig).filter(MQTTConfig.is_active == True).first()\n                if mqtt_config:\n                    st.success(f\"MQTT: {mqtt_config.broker_host}:{mqtt_config.broker_port}\")\n                else:\n                    st.warning(\"No MQTT broker configured\")\n        \n        with col_right:\n            with st.container(border=True):\n                st.subheader(\"Gateway Status\")\n                gateways = session.query(Gateway).filter(Gateway.is_active == True).limit(5).all()\n                \n                if gateways:\n                    for gw in gateways:\n                        five_min_ago = datetime.utcnow() - timedelta(minutes=5)\n                        recent = session.query(func.count(RSSISignal.id)).filter(\n                            RSSISignal.gateway_id == gw.id,\n                            RSSISignal.timestamp >= five_min_ago\n                        ).scalar()\n                        \n                        status = \"ðŸŸ¢\" if recent > 0 else \"ðŸ”´\"\n                        st.write(f\"{status} **{gw.name}** â€” {recent} signals (5 min)\")\n                else:\n                    st.info(\"No gateways configured yet.\")\n        \n        st.markdown(\"---\")\n        \n        with st.container(border=True):\n            st.subheader(\"Quick Setup Guide\")\n            \n            if building_count == 0:\n                st.write(\"1ï¸âƒ£ Create a building and upload floor plans\")\n            else:\n                st.write(\"~~1ï¸âƒ£ Create a building and upload floor plans~~ âœ…\")\n            \n            if gateway_count == 0:\n                st.write(\"2ï¸âƒ£ Add your Careflow BLE Gateways\")\n            else:\n                st.write(\"~~2ï¸âƒ£ Add your Careflow BLE Gateways~~ âœ…\")\n            \n            if beacon_count == 0:\n                st.write(\"3ï¸âƒ£ Register your BLE Beacons\")\n            else:\n                st.write(\"~~3ï¸âƒ£ Register your BLE Beacons~~ âœ…\")\n            \n            if not mqtt_config:\n                st.write(\"4ï¸âƒ£ Configure the MQTT broker connection\")\n            else:\n                st.write(\"~~4ï¸âƒ£ Configure the MQTT broker connection~~ âœ…\")\n            \n            st.write(\"5ï¸âƒ£ Start live tracking to see beacon positions\")\n","path":null,"size_bytes":5427,"size_tokens":null},"views/history_playback.py":{"content":"import streamlit as st\nfrom database import get_db_session, Building, Floor, Gateway, Beacon, Position\nfrom datetime import datetime, timedelta\nfrom io import BytesIO\nfrom PIL import Image\nimport plotly.graph_objects as go\nimport base64\nimport time\n\n\ndef get_playback_figure(floor, positions_at_time, gateways_data, trail_positions=None):\n    \"\"\"Create a plotly figure with floor plan and positions at a specific time\"\"\"\n    \n    fig = go.Figure()\n    \n    if floor.floor_plan_image:\n        try:\n            image = Image.open(BytesIO(floor.floor_plan_image))\n            \n            buffered = BytesIO()\n            image.save(buffered, format=\"PNG\")\n            img_str = base64.b64encode(buffered.getvalue()).decode()\n            \n            fig.add_layout_image(\n                dict(\n                    source=f\"data:image/png;base64,{img_str}\",\n                    xref=\"x\",\n                    yref=\"y\",\n                    x=0,\n                    y=floor.height_meters,\n                    sizex=floor.width_meters,\n                    sizey=floor.height_meters,\n                    sizing=\"stretch\",\n                    opacity=0.8,\n                    layer=\"below\"\n                )\n            )\n        except Exception as e:\n            pass\n    \n    for gw in gateways_data:\n        fig.add_trace(go.Scatter(\n            x=[gw['x']],\n            y=[gw['y']],\n            mode='markers+text',\n            marker=dict(size=12, color='blue', symbol='square'),\n            text=[gw['name']],\n            textposition='top center',\n            name=f\"Gateway: {gw['name']}\",\n            hoverinfo='text',\n            hovertext=f\"Gateway: {gw['name']}\"\n        ))\n    \n    colors = ['red', 'green', 'orange', 'purple', 'cyan', 'magenta', 'yellow', 'lime']\n    \n    for idx, (beacon_name, pos) in enumerate(positions_at_time.items()):\n        color = colors[idx % len(colors)]\n        \n        if trail_positions and beacon_name in trail_positions:\n            trail = trail_positions[beacon_name]\n            if len(trail) > 1:\n                trail_x = [p['x'] for p in trail]\n                trail_y = [p['y'] for p in trail]\n                \n                fig.add_trace(go.Scatter(\n                    x=trail_x,\n                    y=trail_y,\n                    mode='lines',\n                    line=dict(color=color, width=2, dash='dot'),\n                    opacity=0.5,\n                    showlegend=False\n                ))\n        \n        fig.add_trace(go.Scatter(\n            x=[pos['x']],\n            y=[pos['y']],\n            mode='markers+text',\n            marker=dict(size=14, color=color),\n            text=[beacon_name],\n            textposition='bottom center',\n            name=beacon_name,\n            hoverinfo='text',\n            hovertext=f\"{beacon_name}<br>Position: ({pos['x']:.1f}, {pos['y']:.1f})<br>Time: {pos['timestamp'].strftime('%H:%M:%S')}\"\n        ))\n    \n    fig.update_layout(\n        xaxis=dict(\n            range=[0, floor.width_meters],\n            title=\"X (meters)\",\n            constrain='domain'\n        ),\n        yaxis=dict(\n            range=[0, floor.height_meters],\n            title=\"Y (meters)\",\n            scaleanchor=\"x\",\n            scaleratio=1\n        ),\n        showlegend=True,\n        legend=dict(x=1.02, y=1),\n        margin=dict(l=50, r=150, t=50, b=50),\n        height=600\n    )\n    \n    return fig\n\n\ndef render():\n    st.title(\"Historical Playback\")\n    st.markdown(\"Replay beacon movement patterns from historical data\")\n    \n    with get_db_session() as session:\n        buildings = session.query(Building).all()\n        if not buildings:\n            st.warning(\"No buildings configured. Please add a building first.\")\n            return\n        \n        col1, col2 = st.columns([1, 3])\n        \n        with col1:\n            st.subheader(\"Playback Settings\")\n            \n            building_options = {b.name: b.id for b in buildings}\n            selected_building = st.selectbox(\"Building\", options=list(building_options.keys()))\n            \n            floors = session.query(Floor).filter(\n                Floor.building_id == building_options[selected_building]\n            ).order_by(Floor.floor_number).all()\n            \n            if not floors:\n                st.warning(\"No floor plans for this building.\")\n                return\n            \n            floor_options = {f\"Floor {f.floor_number}: {f.name or ''}\": f.id for f in floors}\n            selected_floor_name = st.selectbox(\"Floor\", options=list(floor_options.keys()))\n            selected_floor_id = floor_options[selected_floor_name]\n            \n            st.markdown(\"---\")\n            st.subheader(\"Time Range\")\n            \n            today = datetime.now().date()\n            \n            col_date1, col_date2 = st.columns(2)\n            with col_date1:\n                start_date = st.date_input(\"Start Date\", value=today - timedelta(days=1))\n            with col_date2:\n                end_date = st.date_input(\"End Date\", value=today)\n            \n            col_time1, col_time2 = st.columns(2)\n            with col_time1:\n                start_time = st.time_input(\"Start Time\", value=datetime.strptime(\"00:00\", \"%H:%M\").time())\n            with col_time2:\n                end_time = st.time_input(\"End Time\", value=datetime.strptime(\"23:59\", \"%H:%M\").time())\n            \n            start_datetime = datetime.combine(start_date, start_time)\n            end_datetime = datetime.combine(end_date, end_time)\n            \n            st.markdown(\"---\")\n            st.subheader(\"Playback Controls\")\n            \n            playback_speed = st.select_slider(\n                \"Speed\",\n                options=[\"0.5x\", \"1x\", \"2x\", \"5x\", \"10x\", \"50x\"],\n                value=\"1x\"\n            )\n            \n            speed_multiplier = {\n                \"0.5x\": 0.5,\n                \"1x\": 1,\n                \"2x\": 2,\n                \"5x\": 5,\n                \"10x\": 10,\n                \"50x\": 50\n            }[playback_speed]\n            \n            show_trail = st.checkbox(\"Show movement trail\", value=True)\n            trail_length = st.slider(\"Trail length (points)\", 5, 100, 20) if show_trail else 0\n            \n            beacons = session.query(Beacon).filter(Beacon.is_active == True).all()\n            beacon_options = [\"All Beacons\"] + [b.name for b in beacons]\n            selected_beacon_filter = st.selectbox(\"Filter Beacon\", options=beacon_options)\n        \n        with col2:\n            floor = session.query(Floor).filter(Floor.id == selected_floor_id).first()\n            \n            gateways = session.query(Gateway).filter(\n                Gateway.floor_id == selected_floor_id,\n                Gateway.is_active == True\n            ).all()\n            \n            gateways_data = [\n                {'name': gw.name, 'x': gw.x_position, 'y': gw.y_position}\n                for gw in gateways\n            ]\n            \n            query = session.query(Position).filter(\n                Position.floor_id == selected_floor_id,\n                Position.timestamp >= start_datetime,\n                Position.timestamp <= end_datetime\n            )\n            \n            if selected_beacon_filter != \"All Beacons\":\n                beacon = session.query(Beacon).filter(Beacon.name == selected_beacon_filter).first()\n                if beacon:\n                    query = query.filter(Position.beacon_id == beacon.id)\n            \n            all_positions = query.order_by(Position.timestamp.asc()).all()\n            \n            if not all_positions:\n                st.warning(\"No position data found for the selected time range and filters.\")\n                st.info(\"Try expanding the date range or check if the signal processor has been running.\")\n                \n                fig = get_playback_figure(floor, {}, gateways_data)\n                st.plotly_chart(fig, use_container_width=True)\n                return\n            \n            positions_by_time = {}\n            for pos in all_positions:\n                beacon = session.query(Beacon).filter(Beacon.id == pos.beacon_id).first()\n                if beacon:\n                    time_key = pos.timestamp.replace(microsecond=0)\n                    if time_key not in positions_by_time:\n                        positions_by_time[time_key] = {}\n                    positions_by_time[time_key][beacon.name] = {\n                        'x': pos.x_position,\n                        'y': pos.y_position,\n                        'speed': pos.speed,\n                        'timestamp': pos.timestamp\n                    }\n            \n            sorted_times = sorted(positions_by_time.keys())\n            \n            if not sorted_times:\n                st.warning(\"No valid position data to display.\")\n                return\n            \n            st.subheader(f\"Playback: {floor.name or f'Floor {floor.floor_number}'}\")\n            \n            total_frames = len(sorted_times)\n            st.write(f\"**Data points:** {total_frames} | **Time span:** {sorted_times[0].strftime('%Y-%m-%d %H:%M')} to {sorted_times[-1].strftime('%Y-%m-%d %H:%M')}\")\n            \n            if 'playback_frame' not in st.session_state:\n                st.session_state['playback_frame'] = 0\n            if 'is_playing' not in st.session_state:\n                st.session_state['is_playing'] = False\n            \n            col_ctrl1, col_ctrl2, col_ctrl3, col_ctrl4 = st.columns(4)\n            \n            with col_ctrl1:\n                if st.button(\"â®ï¸ Start\"):\n                    st.session_state['playback_frame'] = 0\n                    st.session_state['is_playing'] = False\n            \n            with col_ctrl2:\n                if st.session_state['is_playing']:\n                    if st.button(\"â¸ï¸ Pause\"):\n                        st.session_state['is_playing'] = False\n                else:\n                    if st.button(\"â–¶ï¸ Play\"):\n                        st.session_state['is_playing'] = True\n            \n            with col_ctrl3:\n                if st.button(\"â­ï¸ End\"):\n                    st.session_state['playback_frame'] = total_frames - 1\n                    st.session_state['is_playing'] = False\n            \n            with col_ctrl4:\n                step_size = st.number_input(\"Step\", min_value=1, max_value=100, value=1, label_visibility=\"collapsed\")\n            \n            current_frame = st.slider(\n                \"Timeline\",\n                min_value=0,\n                max_value=total_frames - 1,\n                value=st.session_state['playback_frame'],\n                key=\"timeline_slider\"\n            )\n            st.session_state['playback_frame'] = current_frame\n            \n            current_time = sorted_times[current_frame]\n            st.write(f\"**Current time:** {current_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n            \n            positions_at_time = positions_by_time[current_time]\n            \n            trail_positions = {}\n            if show_trail:\n                start_idx = max(0, current_frame - trail_length)\n                for i in range(start_idx, current_frame + 1):\n                    frame_time = sorted_times[i]\n                    for beacon_name, pos in positions_by_time[frame_time].items():\n                        if beacon_name not in trail_positions:\n                            trail_positions[beacon_name] = []\n                        trail_positions[beacon_name].append(pos)\n            \n            fig = get_playback_figure(floor, positions_at_time, gateways_data, trail_positions if show_trail else None)\n            st.plotly_chart(fig, use_container_width=True)\n            \n            if positions_at_time:\n                st.subheader(\"Beacon Status at Current Time\")\n                \n                cols = st.columns(min(len(positions_at_time), 4))\n                for idx, (beacon_name, pos) in enumerate(positions_at_time.items()):\n                    with cols[idx % 4]:\n                        st.metric(\n                            beacon_name,\n                            f\"({pos['x']:.1f}, {pos['y']:.1f})\",\n                            f\"{pos['speed']:.2f} m/s\" if pos.get('speed') else None\n                        )\n            \n            if st.session_state['is_playing']:\n                next_frame = current_frame + int(step_size * speed_multiplier)\n                if next_frame < total_frames:\n                    st.session_state['playback_frame'] = next_frame\n                    time.sleep(0.5 / speed_multiplier)\n                    st.rerun()\n                else:\n                    st.session_state['is_playing'] = False\n                    st.session_state['playback_frame'] = total_frames - 1\n","path":null,"size_bytes":12685,"size_tokens":null},"views/__init__.py":{"content":"# Pages module\n","path":null,"size_bytes":15,"size_tokens":null},"utils/triangulation.py":{"content":"import numpy as np\nfrom typing import List, Tuple, Optional\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass GatewayReading:\n    \"\"\"RSSI reading from a single gateway\"\"\"\n    gateway_id: int\n    x: float\n    y: float\n    rssi: int\n    tx_power: int = -59\n    path_loss_exponent: float = 2.0\n\n\ndef rssi_to_distance(rssi: int, tx_power: int = -59, path_loss_exponent: float = 2.0) -> float:\n    \"\"\"\n    Convert RSSI value to estimated distance using the log-distance path loss model.\n    \n    Args:\n        rssi: Received signal strength indicator (dBm)\n        tx_power: Signal strength at 1 meter (dBm), typically -59 for BLE\n        path_loss_exponent: Environment-specific path loss exponent (2.0 for free space)\n    \n    Returns:\n        Estimated distance in meters\n    \"\"\"\n    if rssi >= tx_power:\n        return 0.1\n    \n    ratio = (tx_power - rssi) / (10 * path_loss_exponent)\n    distance = pow(10, ratio)\n    \n    return max(0.1, min(distance, 100))\n\n\ndef trilaterate_2d(readings: List[GatewayReading]) -> Tuple[float, float, float]:\n    \"\"\"\n    Calculate position using trilateration from multiple gateway readings.\n    \n    Uses weighted least squares optimization for better accuracy.\n    \n    Args:\n        readings: List of gateway readings with positions and RSSI values\n    \n    Returns:\n        Tuple of (x, y, accuracy) where accuracy is estimated error in meters\n    \"\"\"\n    if len(readings) < 3:\n        if len(readings) == 1:\n            distance = rssi_to_distance(\n                readings[0].rssi, \n                readings[0].tx_power, \n                readings[0].path_loss_exponent\n            )\n            return readings[0].x, readings[0].y, distance\n        elif len(readings) == 2:\n            d1 = rssi_to_distance(\n                readings[0].rssi, \n                readings[0].tx_power, \n                readings[0].path_loss_exponent\n            )\n            d2 = rssi_to_distance(\n                readings[1].rssi, \n                readings[1].tx_power, \n                readings[1].path_loss_exponent\n            )\n            weight1 = 1 / max(d1, 0.1)\n            weight2 = 1 / max(d2, 0.1)\n            total_weight = weight1 + weight2\n            \n            x = (readings[0].x * weight1 + readings[1].x * weight2) / total_weight\n            y = (readings[0].y * weight1 + readings[1].y * weight2) / total_weight\n            accuracy = (d1 + d2) / 2\n            return x, y, accuracy\n    \n    positions = np.array([[r.x, r.y] for r in readings])\n    distances = np.array([\n        rssi_to_distance(r.rssi, r.tx_power, r.path_loss_exponent) \n        for r in readings\n    ])\n    \n    weights = 1 / np.maximum(distances, 0.1)\n    weights = weights / np.sum(weights)\n    \n    n = len(readings)\n    A = np.zeros((n - 1, 2))\n    b = np.zeros(n - 1)\n    \n    for i in range(n - 1):\n        A[i, 0] = 2 * (positions[i, 0] - positions[n-1, 0])\n        A[i, 1] = 2 * (positions[i, 1] - positions[n-1, 1])\n        b[i] = (distances[n-1]**2 - distances[i]**2 + \n                positions[i, 0]**2 - positions[n-1, 0]**2 +\n                positions[i, 1]**2 - positions[n-1, 1]**2)\n    \n    W = np.diag(weights[:-1])\n    \n    try:\n        AtWA = A.T @ W @ A\n        AtWb = A.T @ W @ b\n        \n        if np.linalg.det(AtWA) < 1e-10:\n            x = np.sum(positions[:, 0] * weights)\n            y = np.sum(positions[:, 1] * weights)\n        else:\n            result = np.linalg.solve(AtWA, AtWb)\n            x, y = result[0], result[1]\n    except np.linalg.LinAlgError:\n        x = np.sum(positions[:, 0] * weights)\n        y = np.sum(positions[:, 1] * weights)\n    \n    estimated_distances = np.sqrt((positions[:, 0] - x)**2 + (positions[:, 1] - y)**2)\n    accuracy = np.sqrt(np.mean((estimated_distances - distances)**2))\n    \n    return float(x), float(y), float(accuracy)\n\n\ndef calculate_velocity(\n    current_pos: Tuple[float, float],\n    previous_pos: Tuple[float, float],\n    time_delta_seconds: float\n) -> Tuple[float, float, float, float]:\n    \"\"\"\n    Calculate velocity vector and speed from two positions.\n    \n    Args:\n        current_pos: Current (x, y) position\n        previous_pos: Previous (x, y) position\n        time_delta_seconds: Time difference in seconds\n    \n    Returns:\n        Tuple of (velocity_x, velocity_y, speed, heading_degrees)\n    \"\"\"\n    if time_delta_seconds <= 0:\n        return 0.0, 0.0, 0.0, 0.0\n    \n    dx = current_pos[0] - previous_pos[0]\n    dy = current_pos[1] - previous_pos[1]\n    \n    velocity_x = dx / time_delta_seconds\n    velocity_y = dy / time_delta_seconds\n    \n    speed = np.sqrt(velocity_x**2 + velocity_y**2)\n    \n    heading = np.degrees(np.arctan2(dy, dx))\n    if heading < 0:\n        heading += 360\n    \n    return float(velocity_x), float(velocity_y), float(speed), float(heading)\n\n\ndef smooth_position(\n    current_pos: Tuple[float, float],\n    previous_positions: List[Tuple[float, float]],\n    alpha: float = 0.3\n) -> Tuple[float, float]:\n    \"\"\"\n    Apply simple exponential smoothing to reduce position jitter.\n    \n    Uses single-step smoothing for more responsive movement detection.\n    \n    Args:\n        current_pos: Current calculated position\n        previous_positions: List of previous positions (most recent last)\n        alpha: Smoothing factor (0-1), higher = more responsive\n    \n    Returns:\n        Smoothed (x, y) position\n    \"\"\"\n    if not previous_positions:\n        return current_pos\n    \n    last_pos = previous_positions[-1]\n    smoothed_x = alpha * current_pos[0] + (1 - alpha) * last_pos[0]\n    smoothed_y = alpha * current_pos[1] + (1 - alpha) * last_pos[1]\n    \n    return smoothed_x, smoothed_y\n\n\ndef filter_outlier_readings(\n    readings: List[GatewayReading],\n    max_distance: float = 50.0\n) -> List[GatewayReading]:\n    \"\"\"\n    Filter out readings that suggest unrealistic distances.\n    \n    Args:\n        readings: List of gateway readings\n        max_distance: Maximum believable distance in meters\n    \n    Returns:\n        Filtered list of readings\n    \"\"\"\n    filtered = []\n    for reading in readings:\n        distance = rssi_to_distance(\n            reading.rssi, \n            reading.tx_power, \n            reading.path_loss_exponent\n        )\n        if distance <= max_distance:\n            filtered.append(reading)\n    \n    return filtered if filtered else readings\n","path":null,"size_bytes":6316,"size_tokens":null},"utils/signal_processor.py":{"content":"import threading\nimport time\nimport os\nimport atexit\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any, List, Tuple\nimport streamlit as st\n\nfrom database import get_db_session, Gateway, Beacon, RSSISignal, Position, MQTTConfig, Floor, Building\nfrom utils.mqtt_handler import MQTTHandler, MQTTMessage\nfrom utils.triangulation import GatewayReading, trilaterate_2d, calculate_velocity, filter_outlier_readings, smooth_position\nfrom utils.mqtt_publisher import get_mqtt_publisher\n\n\nclass SignalProcessor:\n    \"\"\"Signal processor that stores signals via MQTT callback and calculates positions on demand.\n    \n    Key architecture: Uses Paho MQTT's internal thread for signal storage (persistent),\n    while position calculation is triggered by Streamlit page loads (on-demand).\n    \"\"\"\n    \n    _instance = None\n    _lock = threading.Lock()\n    \n    def __new__(cls):\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = super().__new__(cls)\n                cls._instance._initialized = False\n            return cls._instance\n    \n    def __init__(self):\n        if self._initialized:\n            return\n        \n        self._initialized = True\n        self._mqtt_handler: Optional[MQTTHandler] = None\n        self._running = False\n        self._last_error: Optional[str] = None\n        self._stats = {\n            'signals_received': 0,\n            'signals_stored': 0,\n            'positions_calculated': 0,\n            'positions_published': 0,\n            'errors': 0\n        }\n        self._publisher = None\n        self._refresh_interval = 1.0\n        self._signal_window_seconds = 3.0\n        self._rssi_smoothing_enabled = True\n        self._position_smoothing_alpha = 0.4\n        self._position_history: Dict[int, List[Tuple[float, float]]] = {}\n        self._last_heartbeat: Optional[datetime] = None\n        self._last_position_calc: Optional[datetime] = None\n        self._signal_lock = threading.Lock()\n        self._scheduler_thread: Optional[threading.Thread] = None\n        self._stop_event = threading.Event()\n        self._calc_lock = threading.Lock()\n        atexit.register(self._cleanup)\n    \n    @property\n    def is_running(self) -> bool:\n        \"\"\"Check if processor is running (MQTT handler connected and scheduler active)\"\"\"\n        mqtt_ok = self._running and self._mqtt_handler and self._mqtt_handler.is_connected\n        scheduler_ok = self._scheduler_thread and self._scheduler_thread.is_alive()\n        return mqtt_ok and scheduler_ok\n    \n    @property\n    def last_heartbeat(self) -> Optional[datetime]:\n        return self._last_heartbeat\n    \n    def _cleanup(self):\n        \"\"\"Cleanup handler for atexit\"\"\"\n        if self._running:\n            self.stop()\n    \n    def check_and_restart(self) -> bool:\n        \"\"\"Check if the processor should be running but isn't, and restart if needed.\n        Returns True if processor is now running, False if restart failed.\n        \"\"\"\n        needs_restart = False\n        \n        if self._running:\n            if self._mqtt_handler and not self._mqtt_handler.is_connected:\n                needs_restart = True\n            if not self._scheduler_thread or not self._scheduler_thread.is_alive():\n                needs_restart = True\n        \n        if needs_restart:\n            self.stop()\n            return self.start()\n        \n        return self.is_running\n    \n    @property\n    def stats(self) -> Dict[str, int]:\n        return self._stats.copy()\n    \n    @property\n    def last_error(self) -> Optional[str]:\n        return self._last_error\n    \n    def _get_mqtt_password(self, password_env_key: Optional[str]) -> Optional[str]:\n        \"\"\"Retrieve MQTT password from environment variable\"\"\"\n        if password_env_key:\n            return os.environ.get(password_env_key)\n        return None\n    \n    def start(self) -> bool:\n        \"\"\"Start the signal processor with MQTT connection.\n        \n        Uses Paho's internal thread for signal storage (via callback),\n        which persists across Streamlit reruns.\n        \"\"\"\n        if self.is_running:\n            return True\n        \n        try:\n            with get_db_session() as session:\n                mqtt_config = session.query(MQTTConfig).filter(MQTTConfig.is_active == True).first()\n                \n                if not mqtt_config:\n                    self._last_error = \"No active MQTT configuration found\"\n                    return False\n                \n                password = self._get_mqtt_password(mqtt_config.password_env_key)\n                \n                ca_cert_path = getattr(mqtt_config, 'ca_cert_path', None)\n                \n                self._mqtt_handler = MQTTHandler(\n                    broker_host=mqtt_config.broker_host,\n                    broker_port=mqtt_config.broker_port,\n                    username=mqtt_config.username,\n                    password=password,\n                    topic_prefix=mqtt_config.topic_prefix,\n                    use_tls=mqtt_config.use_tls,\n                    ca_cert_path=ca_cert_path\n                )\n            \n            self._mqtt_handler.add_callback(self._on_mqtt_message)\n            \n            if not self._mqtt_handler.connect():\n                self._last_error = self._mqtt_handler.last_error or \"Failed to connect to MQTT broker\"\n                return False\n            \n            self._publisher = get_mqtt_publisher()\n            with get_db_session() as session:\n                mqtt_config = session.query(MQTTConfig).filter(MQTTConfig.is_active == True).first()\n                if mqtt_config:\n                    if getattr(mqtt_config, 'publish_enabled', False):\n                        self._publisher.configure(mqtt_config)\n                    self._refresh_interval = getattr(mqtt_config, 'refresh_interval', 1.0) or 1.0\n                    self._signal_window_seconds = getattr(mqtt_config, 'signal_window_seconds', 3.0) or 3.0\n                    self._rssi_smoothing_enabled = getattr(mqtt_config, 'rssi_smoothing_enabled', True)\n                    self._position_smoothing_alpha = getattr(mqtt_config, 'position_smoothing_alpha', 0.4) or 0.4\n            \n            self._running = True\n            self._last_heartbeat = datetime.utcnow()\n            self._stop_event.clear()\n            \n            self._scheduler_thread = threading.Thread(\n                target=self._scheduler_loop, \n                daemon=False, \n                name=\"SignalProcessorScheduler\"\n            )\n            self._scheduler_thread.start()\n            \n            print(\"[SignalProcessor] Started with callback-based signal storage and position scheduler\")\n            self._last_error = None\n            return True\n            \n        except Exception as e:\n            self._last_error = str(e)\n            print(f\"[SignalProcessor] Start error: {e}\")\n            return False\n    \n    def stop(self):\n        \"\"\"Stop the signal processor\"\"\"\n        self._running = False\n        self._stop_event.set()\n        \n        if self._scheduler_thread and self._scheduler_thread.is_alive():\n            self._scheduler_thread.join(timeout=5)\n            self._scheduler_thread = None\n        \n        if self._mqtt_handler:\n            self._mqtt_handler.stop()\n            self._mqtt_handler.disconnect()\n            self._mqtt_handler = None\n    \n    def _on_mqtt_message(self, msg: MQTTMessage):\n        \"\"\"Callback for MQTT messages - runs in Paho's thread.\n        \n        This is the key to persistence: Paho's internal thread survives\n        Streamlit reruns, so signals are stored continuously.\n        \"\"\"\n        with self._signal_lock:\n            try:\n                self._stats['signals_received'] += 1\n                self._store_signal(msg)\n                self._last_heartbeat = datetime.utcnow()\n            except Exception as e:\n                self._stats['errors'] += 1\n                self._last_error = str(e)\n    \n    def _scheduler_loop(self):\n        \"\"\"Scheduler loop for position calculation - runs in dedicated thread.\n        \n        This thread calculates positions at fixed intervals independent of the UI.\n        Uses Event.wait() for graceful shutdown.\n        \"\"\"\n        print(\"[SignalProcessor] Scheduler thread started\")\n        last_heartbeat_log = datetime.utcnow()\n        \n        while self._running and not self._stop_event.is_set():\n            try:\n                if (datetime.utcnow() - last_heartbeat_log).total_seconds() >= 30:\n                    stats = self._stats\n                    print(f\"[SignalProcessor] Heartbeat - Signals: {stats['signals_received']}, Stored: {stats['signals_stored']}, Positions: {stats['positions_calculated']}, Errors: {stats['errors']}\")\n                    last_heartbeat_log = datetime.utcnow()\n                \n                with self._calc_lock:\n                    self._calculate_positions()\n                    self._last_position_calc = datetime.utcnow()\n                \n                self._stop_event.wait(timeout=self._refresh_interval)\n                \n            except Exception as e:\n                self._last_error = f\"Scheduler error: {e}\"\n                self._stats['errors'] += 1\n                print(f\"[SignalProcessor] Scheduler error: {e}\")\n                self._stop_event.wait(timeout=1.0)\n        \n        print(\"[SignalProcessor] Scheduler thread stopped\")\n    \n    def _store_signal(self, msg: MQTTMessage):\n        \"\"\"Store an RSSI signal in the database\"\"\"\n        try:\n            with get_db_session() as session:\n                gateway = session.query(Gateway).filter(\n                    Gateway.mac_address == msg.gateway_mac,\n                    Gateway.is_active == True\n                ).first()\n                \n                if not gateway:\n                    return\n                \n                beacon = session.query(Beacon).filter(\n                    Beacon.mac_address == msg.beacon_mac\n                ).first()\n                \n                if not beacon:\n                    mqtt_config = session.query(MQTTConfig).filter(MQTTConfig.is_active == True).first()\n                    if mqtt_config and mqtt_config.auto_discover_beacons:\n                        beacon = Beacon(\n                            mac_address=msg.beacon_mac,\n                            name=f\"Auto-{msg.beacon_mac[-8:]}\",\n                            resource_type=\"Device\",\n                            is_active=True\n                        )\n                        session.add(beacon)\n                        session.flush()\n                    else:\n                        return\n                \n                if not beacon.is_active:\n                    return\n                \n                signal = RSSISignal(\n                    gateway_id=gateway.id,\n                    beacon_id=beacon.id,\n                    rssi=msg.rssi,\n                    tx_power=msg.tx_power,\n                    timestamp=msg.timestamp,\n                    raw_data=msg.raw_data\n                )\n                session.add(signal)\n                session.commit()\n                self._stats['signals_stored'] += 1\n                \n        except Exception as e:\n            error_str = str(e)\n            if 'ForeignKeyViolation' in error_str or 'foreign key constraint' in error_str.lower():\n                pass\n            else:\n                self._last_error = f\"Signal storage error: {e}\"\n                self._stats['errors'] += 1\n    \n    def _calculate_positions(self):\n        \"\"\"Calculate positions for all beacons with recent signals\"\"\"\n        try:\n            with get_db_session() as session:\n                window_start = datetime.utcnow() - timedelta(seconds=self._signal_window_seconds)\n                \n                beacon_signals: Dict[int, Dict[int, List[RSSISignal]]] = {}\n                \n                recent_signals = session.query(RSSISignal).filter(\n                    RSSISignal.timestamp >= window_start\n                ).order_by(RSSISignal.timestamp.desc()).all()\n                \n                for signal in recent_signals:\n                    beacon_id = signal.beacon_id\n                    gateway_id = signal.gateway_id\n                    \n                    if beacon_id not in beacon_signals:\n                        beacon_signals[beacon_id] = {}\n                    \n                    if gateway_id not in beacon_signals[beacon_id]:\n                        beacon_signals[beacon_id][gateway_id] = []\n                    \n                    beacon_signals[beacon_id][gateway_id].append(signal)\n                \n                for beacon_id, gateway_signals in beacon_signals.items():\n                    beacon = session.query(Beacon).filter(\n                        Beacon.id == beacon_id,\n                        Beacon.is_active == True\n                    ).first()\n                    \n                    if not beacon:\n                        continue\n                    \n                    readings = []\n                    floor_id = None\n                    \n                    for gateway_id, signals in gateway_signals.items():\n                        gateway = session.query(Gateway).filter(\n                            Gateway.id == gateway_id,\n                            Gateway.is_active == True\n                        ).first()\n                        \n                        if gateway and signals:\n                            if self._rssi_smoothing_enabled and len(signals) > 1:\n                                weights = []\n                                rssi_values = []\n                                for i, s in enumerate(signals):\n                                    weight = 1.0 / (i + 1)\n                                    weights.append(weight)\n                                    rssi_values.append(s.rssi)\n                                total_weight = sum(weights)\n                                avg_rssi = sum(r * w for r, w in zip(rssi_values, weights)) / total_weight\n                                rssi = int(round(avg_rssi))\n                                tx_power = signals[0].tx_power or -59\n                            else:\n                                rssi = signals[0].rssi\n                                tx_power = signals[0].tx_power or -59\n                            \n                            readings.append(GatewayReading(\n                                gateway_id=gateway.id,\n                                x=gateway.x_position,\n                                y=gateway.y_position,\n                                rssi=rssi,\n                                tx_power=tx_power,\n                                path_loss_exponent=gateway.path_loss_exponent or 2.0\n                            ))\n                            floor_id = gateway.floor_id\n                    \n                    if len(readings) >= 1 and floor_id:\n                        readings = filter_outlier_readings(readings)\n                        x, y, accuracy = trilaterate_2d(readings)\n                        \n                        if self._position_smoothing_alpha < 1.0 and beacon_id in self._position_history:\n                            prev_positions = self._position_history[beacon_id]\n                            if prev_positions:\n                                x, y = smooth_position((x, y), prev_positions, self._position_smoothing_alpha)\n                        \n                        if beacon_id not in self._position_history:\n                            self._position_history[beacon_id] = []\n                        self._position_history[beacon_id].append((x, y))\n                        if len(self._position_history[beacon_id]) > 5:\n                            self._position_history[beacon_id] = self._position_history[beacon_id][-5:]\n                        \n                        previous_position = session.query(Position).filter(\n                            Position.beacon_id == beacon_id\n                        ).order_by(Position.timestamp.desc()).first()\n                        \n                        velocity_x, velocity_y, speed, heading = 0, 0, 0, 0\n                        \n                        if previous_position:\n                            time_delta = (datetime.utcnow() - previous_position.timestamp).total_seconds()\n                            if 0 < time_delta < 60:\n                                velocity_x, velocity_y, speed, heading = calculate_velocity(\n                                    (x, y),\n                                    (previous_position.x_position, previous_position.y_position),\n                                    time_delta\n                                )\n                        \n                        position = Position(\n                            beacon_id=beacon_id,\n                            floor_id=floor_id,\n                            x_position=x,\n                            y_position=y,\n                            accuracy=accuracy,\n                            velocity_x=velocity_x,\n                            velocity_y=velocity_y,\n                            speed=speed,\n                            heading=heading,\n                            timestamp=datetime.utcnow(),\n                            calculation_method='triangulation'\n                        )\n                        session.add(position)\n                        session.commit()\n                        self._stats['positions_calculated'] += 1\n                        \n                        if self._publisher and self._publisher.is_connected():\n                            floor = session.query(Floor).filter(Floor.id == floor_id).first()\n                            building_name = \"\"\n                            floor_name = \"\"\n                            if floor:\n                                floor_name = floor.name or f\"Floor {floor.floor_number}\"\n                                if floor.building:\n                                    building_name = floor.building.name\n                            \n                            if self._publisher.publish_position(\n                                beacon_mac=beacon.mac_address,\n                                beacon_name=beacon.name,\n                                resource_type=beacon.resource_type or \"Device\",\n                                floor_id=floor_id,\n                                floor_name=floor_name,\n                                building_name=building_name,\n                                x=x,\n                                y=y,\n                                accuracy=accuracy,\n                                speed=speed,\n                                heading=heading,\n                                velocity_x=velocity_x,\n                                velocity_y=velocity_y\n                            ):\n                                self._stats['positions_published'] += 1\n                \n        except Exception as e:\n            self._last_error = f\"Position calculation error: {e}\"\n            self._stats['errors'] += 1\n\n\n@st.cache_resource\ndef get_signal_processor() -> SignalProcessor:\n    \"\"\"Get the singleton signal processor instance.\n    Using st.cache_resource keeps the processor alive across Streamlit reruns.\n    \"\"\"\n    return SignalProcessor()\n","path":null,"size_bytes":19281,"size_tokens":null},"utils/__init__.py":{"content":"from utils.triangulation import (\n    GatewayReading,\n    rssi_to_distance,\n    trilaterate_2d,\n    calculate_velocity,\n    smooth_position,\n    filter_outlier_readings\n)\nfrom utils.mqtt_handler import (\n    MQTTHandler,\n    MQTTMessage,\n    create_mqtt_handler_from_config\n)\nfrom utils.signal_processor import (\n    SignalProcessor,\n    get_signal_processor\n)\n\n__all__ = [\n    'GatewayReading',\n    'rssi_to_distance',\n    'trilaterate_2d',\n    'calculate_velocity',\n    'smooth_position',\n    'filter_outlier_readings',\n    'MQTTHandler',\n    'MQTTMessage',\n    'create_mqtt_handler_from_config',\n    'SignalProcessor',\n    'get_signal_processor'\n]\n","path":null,"size_bytes":651,"size_tokens":null},"replit.md":{"content":"# Careflow Setup\n\n## Overview\nA Streamlit-based indoor positioning system for managing Careflow BLE Gateway devices, BLE beacons, and real-time location tracking with triangulation on floor plans.\n\n## Features\n\n### Core Features\n- **Building Management**: Create buildings with GPS coordinates and multi-story floor plans\n- **Gateway Configuration**: Set up Careflow BLE gateways with precise positioning and calibration\n- **Beacon Registration**: Register BLE beacons with resource types (Device, Staff, Asset, etc.)\n- **MQTT Integration**: Connect to MQTT broker for receiving real-time RSSI signals\n- **Triangulation Engine**: Calculate beacon positions from multiple gateway signals using weighted least squares\n- **Live Tracking**: Visualize beacon positions and movement vectors on floor plans\n- **Signal Monitor**: Debug and monitor incoming signals with manual testing capability\n- **Background Processing**: Automatic signal ingestion and position calculation in background thread\n\n### Phase 2 Features\n- **Historical Playback**: Replay beacon movement patterns from historical data with adjustable speed\n- **Zones & Alerts**: Define geofencing zones and monitor entry/exit alerts with acknowledgment\n- **Analytics Dashboard**: Heatmaps, dwell time analysis, and traffic patterns by hour\n- **Import/Export**: Bulk import and export of gateway, beacon, and zone configurations (JSON/CSV)\n- **Calibration Wizard**: Improve triangulation accuracy using known beacon positions\n\n## Project Structure\n```\nâ”œâ”€â”€ app.py                    # Main Streamlit application\nâ”œâ”€â”€ database/\nâ”‚   â”œâ”€â”€ __init__.py          # Database exports\nâ”‚   â””â”€â”€ models.py            # SQLAlchemy models with context manager\nâ”œâ”€â”€ views/                    # Named 'views' to avoid Streamlit multipage detection\nâ”‚   â”œâ”€â”€ dashboard.py         # System overview\nâ”‚   â”œâ”€â”€ buildings.py         # Building and floor plan management\nâ”‚   â”œâ”€â”€ gateways.py          # Gateway configuration\nâ”‚   â”œâ”€â”€ beacons.py           # Beacon registration\nâ”‚   â”œâ”€â”€ mqtt_config.py       # MQTT broker settings\nâ”‚   â”œâ”€â”€ live_tracking.py     # Real-time visualization\nâ”‚   â”œâ”€â”€ history_playback.py  # Historical playback with timeline controls\nâ”‚   â”œâ”€â”€ zones_alerts.py      # Geofencing zones and alert management\nâ”‚   â”œâ”€â”€ analytics.py         # Heatmaps, dwell time, traffic patterns\nâ”‚   â”œâ”€â”€ import_export.py     # Bulk import/export functionality\nâ”‚   â”œâ”€â”€ calibration.py       # Calibration wizard and accuracy analysis\nâ”‚   â””â”€â”€ signal_monitor.py    # Signal debugging\nâ””â”€â”€ utils/\n    â”œâ”€â”€ triangulation.py     # Position calculation algorithms\n    â”œâ”€â”€ mqtt_handler.py      # MQTT client handler (subscription)\n    â”œâ”€â”€ mqtt_publisher.py    # MQTT publisher for positions/alerts\n    â””â”€â”€ signal_processor.py  # Background signal processing\n```\n\n## Database Schema\n- **Buildings**: Building information with GPS coordinates\n- **Floors**: Floor plans with dimensions and images\n- **Gateways**: Careflow BLE gateway configurations with positions\n- **Beacons**: BLE beacon registrations with resource types\n- **RSSISignals**: Raw RSSI signal data from gateways\n- **Positions**: Calculated beacon positions with velocity vectors\n- **MQTTConfig**: MQTT broker connection settings (password stored as env var reference)\n- **Zones**: Geofencing zone definitions with alert configuration\n- **ZoneAlerts**: Zone entry/exit alert events with acknowledgment status\n- **CalibrationPoints**: Reference points for accuracy improvement\n\n## Setup Steps\n1. Add a building with floor plans\n2. Configure Careflow BLE gateways with their positions on floor plans\n3. Register BLE beacons to track\n4. Configure MQTT broker connection (set password in Secrets tab)\n5. Start signal processor and begin live tracking\n6. (Optional) Define zones for geofencing alerts\n7. (Optional) Create calibration points to improve accuracy\n\n## MQTT Publishing\nThe system can publish beacon positions and zone alerts to MQTT for integration with other applications:\n\n### Position Messages (Topic: careflow/positions/{beacon_mac})\n```json\n{\n  \"type\": \"position\",\n  \"beacon\": {\"mac\": \"AA:BB:CC:DD:EE:FF\", \"name\": \"Beacon Name\", \"resource_type\": \"Staff\"},\n  \"location\": {\"floor_id\": 1, \"floor_name\": \"Floor 1\", \"building_name\": \"Building A\", \"x\": 10.5, \"y\": 20.3, \"accuracy\": 2.5},\n  \"movement\": {\"speed\": 0.5, \"heading\": 45.0, \"velocity_x\": 0.3, \"velocity_y\": 0.4},\n  \"timestamp\": \"2025-12-02T14:00:00.000Z\"\n}\n```\n\n### Alert Messages (Topic: careflow/alerts/{alert_type}/{zone_id})\n```json\n{\n  \"type\": \"zone_alert\",\n  \"alert_type\": \"entry\",\n  \"beacon\": {\"mac\": \"AA:BB:CC:DD:EE:FF\", \"name\": \"Beacon Name\", \"resource_type\": \"Staff\"},\n  \"zone\": {\"id\": 1, \"name\": \"Restricted Area\", \"floor_name\": \"Floor 1\"},\n  \"position\": {\"x\": 10.5, \"y\": 20.3},\n  \"timestamp\": \"2025-12-02T14:00:00.000Z\"\n}\n```\n\n### Publisher Architecture\n- Thread-safe singleton with async message queue\n- Separate paho-mqtt client from subscription handler\n- Non-blocking publish calls (queue with 1000 message capacity)\n- Automatic connection management with callbacks\n\n## MQTT Subscription (Moko MKGW-mini03 Gateways)\nThe system is configured to receive data from Moko MKGW-mini03 gateways (CFS/Careflow branded):\n\n### Gateway Topic Structure\n- **Publish (gateway sends data)**: `/cfs1/{gateway_mac}/send` or `/cfs2/{gateway_mac}/send`\n- **Subscribe (gateway receives commands)**: `/cfs1/{gateway_mac}/receive` or `/cfs2/{gateway_mac}/receive`\n\n### Gateway Message Format\n```json\n{\n  \"msg_id\": 3070,\n  \"device_info\": {\n    \"mac\": \"00e04c006bf1\"\n  },\n  \"data\": [\n    {\n      \"timestamp\": 1764768812262,\n      \"timezone\": 0,\n      \"type_code\": 0,\n      \"type\": \"ibeacon\",\n      \"rssi\": -61,\n      \"connectable\": 0,\n      \"mac\": \"b081845989f1\",\n      \"uuid\": \"00000000000000000000000000000000\",\n      \"major\": 0,\n      \"minor\": 0,\n      \"rssi_1m\": 0\n    }\n  ]\n}\n```\n\n### Multiple Gateway Subscription\nUse comma-separated topics to subscribe to multiple gateways:\n```\n/cfs1/+/send, /cfs2/+/send\n```\n\n## Processing Settings\nThe system supports configurable position calculation settings in MQTT Configuration:\n- **Refresh Rate**: 0.5s, 1s, or 2s intervals for position calculation\n- **Signal Window**: How far back to look for RSSI signals (default 10s, max 30s)\n  - Longer window = more stable but less responsive\n  - Shorter window = more responsive but may miss intermittent signals\n- **RSSI Smoothing**: Weighted average of multiple readings from same gateway\n- **Position Smoothing**: Exponential smoothing to reduce jitter (alpha 0.1-1.0)\n\n## Technical Notes\n- Database sessions use context managers to prevent connection leaks\n- **Signal Processor Architecture** (Streamlit-compatible):\n  - Uses Paho MQTT's internal thread for signal storage via callback (persistent across Streamlit reruns)\n  - Dedicated scheduler thread for continuous position calculation\n  - Singleton pattern with @st.cache_resource decorator\n  - Heartbeat monitoring and auto-restart mechanism\n- Triangulation uses weighted least squares for position calculation\n- Path loss model: RSSI to distance conversion with configurable calibration\n- Movement vectors calculated from sequential position updates\n- Floor plans support image overlay with coordinate mapping\n- MQTT passwords stored securely via environment variable references\n- Zone alerts are deduplicated within 30-second windows\n- MQTT publisher uses async queue to avoid blocking DB transactions\n- MQTT handler supports both `beacons` and `data` arrays in gateway messages\n- Signal window should be at least 10 seconds for reliable position calculation with intermittent MQTT signals\n\n## Security\n- MQTT passwords are NOT stored in database\n- Password is referenced by environment variable name (e.g., MQTT_PASSWORD)\n- Set the actual password as a Secret in the Secrets tab\n\n## Branding\n- Logo: Careflow horizontal logo displayed in sidebar (attached_assets/CAREFLOW LOGO-Color_1764612034940.png)\n- Color Scheme: Careflow Blue (#2e5cbf, #008ed3)\n- Font: Inter (Google Fonts)\n- Theme configured in .streamlit/config.toml\n\n## Recent Changes\n- December 2025: Initial implementation with full feature set\n- December 2025: Fixed database session management with context managers\n- December 2025: Added background signal processor for automatic data ingestion\n- December 2025: Improved MQTT credential security using environment variables\n- December 2025: Added Phase 2 features (history playback, zones/alerts, analytics, import/export, calibration)\n- December 2025: Updated branding from Moko to Careflow with logo and color scheme\n- December 2025: Added MQTT publishing for beacon positions and zone alerts with async queue architecture\n- December 2025: Fixed signal processor architecture - replaced thread-based with callback + scheduler for Streamlit compatibility\n- December 2025: Improved position smoothing to be more responsive (single-step smoothing with alpha=0.7)\n- December 2025: Added DXF floor plan support using ezdxf library for CAD file parsing\n","path":null,"size_bytes":9110,"size_tokens":null},"views/mqtt_config.py":{"content":"import streamlit as st\nimport os\nfrom database import get_db_session, MQTTConfig\nfrom utils.mqtt_handler import MQTTHandler\nfrom utils.signal_processor import get_signal_processor\nimport time\n\n\ndef show_pending_message():\n    \"\"\"Display any pending success message from session state\"\"\"\n    if 'mqtt_success_msg' in st.session_state:\n        st.success(st.session_state['mqtt_success_msg'])\n        del st.session_state['mqtt_success_msg']\n\n\ndef set_success_and_rerun(message):\n    \"\"\"Store success message in session state and rerun\"\"\"\n    st.session_state['mqtt_success_msg'] = message\n    st.rerun()\n\n\ndef render():\n    st.title(\"MQTT Broker Configuration\")\n    st.markdown(\"Configure the connection to your MQTT broker for receiving gateway data\")\n    \n    show_pending_message()\n    \n    with get_db_session() as session:\n        existing_config = session.query(MQTTConfig).filter(MQTTConfig.is_active == True).first()\n        \n        st.subheader(\"Broker Settings\")\n        \n        with st.form(\"mqtt_config\"):\n            col1, col2 = st.columns(2)\n            \n            with col1:\n                broker_host = st.text_input(\n                    \"Broker Host*\",\n                    value=existing_config.broker_host if existing_config else \"\",\n                    placeholder=\"e.g., mqtt.example.com or 192.168.1.100\",\n                    help=\"MQTT broker hostname or IP address\"\n                )\n                \n                broker_port = st.number_input(\n                    \"Broker Port*\",\n                    value=existing_config.broker_port if existing_config else 1883,\n                    min_value=1,\n                    max_value=65535,\n                    help=\"Default: 1883 for non-TLS, 8883 for TLS\"\n                )\n                \n                topic_prefix = st.text_input(\n                    \"Topic Prefix\",\n                    value=existing_config.topic_prefix if existing_config else \"ble/gateway/\",\n                    placeholder=\"ble/gateway/\",\n                    help=\"Prefix for MQTT topics from gateways\"\n                )\n            \n            with col2:\n                username = st.text_input(\n                    \"Username\",\n                    value=existing_config.username if existing_config else \"\",\n                    placeholder=\"Leave empty if not required\"\n                )\n                \n                password_env_key = st.text_input(\n                    \"Password Environment Variable Name\",\n                    value=existing_config.password_env_key if existing_config else \"MQTT_PASSWORD\",\n                    placeholder=\"MQTT_PASSWORD\",\n                    help=\"Name of the secret/environment variable containing the password\"\n                )\n                \n                has_password = False\n                if password_env_key:\n                    has_password = os.environ.get(password_env_key) is not None\n                \n                if password_env_key:\n                    if has_password:\n                        st.success(f\"Password is set in environment variable '{password_env_key}'\")\n                    else:\n                        st.warning(f\"Environment variable '{password_env_key}' is not set\")\n                \n                use_tls = st.checkbox(\n                    \"Use TLS/SSL\",\n                    value=existing_config.use_tls if existing_config else False,\n                    help=\"Enable secure connection (required for EMQ X Cloud on port 8883)\"\n                )\n                \n                ca_cert_path = st.text_input(\n                    \"CA Certificate Path\",\n                    value=existing_config.ca_cert_path if existing_config and existing_config.ca_cert_path else \"certs/emqxsl-ca.crt\",\n                    placeholder=\"certs/emqxsl-ca.crt\",\n                    help=\"Path to CA certificate file for TLS (required for EMQ X Cloud)\"\n                )\n                \n                if ca_cert_path and os.path.exists(ca_cert_path):\n                    st.success(f\"CA certificate found: {ca_cert_path}\")\n                elif use_tls and ca_cert_path:\n                    st.warning(f\"CA certificate not found at: {ca_cert_path}\")\n            \n            st.info(\"Set the MQTT password as a secret (via Secrets tab in Tools) using the environment variable name specified above. This keeps your password secure.\")\n            \n            col3, col4 = st.columns(2)\n            \n            with col3:\n                submitted = st.form_submit_button(\"Save Configuration\", type=\"primary\")\n            \n            with col4:\n                test_connection = st.form_submit_button(\"Test Connection\")\n            \n            if submitted:\n                if not broker_host:\n                    st.error(\"Broker host is required\")\n                else:\n                    if existing_config:\n                        existing_config.broker_host = broker_host\n                        existing_config.broker_port = broker_port\n                        existing_config.topic_prefix = topic_prefix\n                        existing_config.username = username or None\n                        existing_config.password_env_key = password_env_key or None\n                        existing_config.use_tls = use_tls\n                        existing_config.ca_cert_path = ca_cert_path or None\n                    else:\n                        config = MQTTConfig(\n                            broker_host=broker_host,\n                            broker_port=broker_port,\n                            topic_prefix=topic_prefix,\n                            username=username or None,\n                            password_env_key=password_env_key or None,\n                            use_tls=use_tls,\n                            ca_cert_path=ca_cert_path or None,\n                            is_active=True\n                        )\n                        session.add(config)\n                    \n                    session.commit()\n                    \n                    processor = get_signal_processor()\n                    if processor.is_running:\n                        processor.stop()\n                        time.sleep(0.5)\n                        processor.start()\n                    \n                    set_success_and_rerun(\"Configuration saved successfully!\")\n            \n            if test_connection:\n                if not broker_host:\n                    st.error(\"Please enter broker host first\")\n                else:\n                    with st.spinner(\"Testing connection...\"):\n                        try:\n                            password = os.environ.get(password_env_key) if password_env_key else None\n                            \n                            handler = MQTTHandler(\n                                broker_host=broker_host,\n                                broker_port=broker_port,\n                                username=username or None,\n                                password=password,\n                                topic_prefix=topic_prefix,\n                                use_tls=use_tls,\n                                ca_cert_path=ca_cert_path if use_tls else None\n                            )\n                            \n                            if handler.connect():\n                                handler.start()\n                                time.sleep(2)\n                                \n                                if handler.is_connected:\n                                    st.success(\"Connection successful!\")\n                                else:\n                                    st.error(f\"Connection failed: {handler.last_error}\")\n                                \n                                handler.stop()\n                                handler.disconnect()\n                            else:\n                                st.error(f\"Failed to connect: {handler.last_error}\")\n                        except Exception as e:\n                            st.error(f\"Connection error: {str(e)}\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Publish Settings (to Careflow App)\")\n        st.markdown(\"Enable publishing of position and alert data to another application via MQTT\")\n        \n        with st.form(\"mqtt_publish_config\"):\n            publish_enabled = st.checkbox(\n                \"Enable Publishing\",\n                value=getattr(existing_config, 'publish_enabled', False) if existing_config else False,\n                help=\"Enable publishing of position and alert data to MQTT\"\n            )\n            \n            col_pub1, col_pub2 = st.columns(2)\n            \n            with col_pub1:\n                positions_topic = st.text_input(\n                    \"Positions Topic\",\n                    value=getattr(existing_config, 'publish_positions_topic', 'careflow/positions') if existing_config else 'careflow/positions',\n                    placeholder=\"careflow/positions\",\n                    help=\"Topic for publishing beacon positions (beacon MAC will be appended)\"\n                )\n            \n            with col_pub2:\n                alerts_topic = st.text_input(\n                    \"Alerts Topic\",\n                    value=getattr(existing_config, 'publish_alerts_topic', 'careflow/alerts') if existing_config else 'careflow/alerts',\n                    placeholder=\"careflow/alerts\",\n                    help=\"Topic for publishing zone alerts (alert type and zone ID will be appended)\"\n                )\n            \n            publish_submitted = st.form_submit_button(\"Save Publish Settings\", type=\"primary\")\n            \n            if publish_submitted:\n                if existing_config:\n                    existing_config.publish_enabled = publish_enabled\n                    existing_config.publish_positions_topic = positions_topic\n                    existing_config.publish_alerts_topic = alerts_topic\n                    session.commit()\n                    \n                    if publish_enabled:\n                        from utils.mqtt_publisher import get_mqtt_publisher\n                        publisher = get_mqtt_publisher()\n                        if publisher.configure(existing_config):\n                            set_success_and_rerun(\"Publish settings saved and publisher connected!\")\n                        else:\n                            set_success_and_rerun(\"Publish settings saved (publisher will connect when processor starts)\")\n                    else:\n                        set_success_and_rerun(\"Publishing disabled\")\n                else:\n                    st.warning(\"Please save broker configuration first\")\n        \n        if existing_config and getattr(existing_config, 'publish_enabled', False):\n            from utils.mqtt_publisher import get_mqtt_publisher\n            publisher = get_mqtt_publisher()\n            if publisher.is_connected():\n                st.success(\"Publisher Status: Connected\")\n            else:\n                st.warning(\"Publisher Status: Not connected (will connect when processor starts)\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Beacon Discovery Settings\")\n        \n        auto_discover = st.checkbox(\n            \"Auto-Discover New Beacons\",\n            value=getattr(existing_config, 'auto_discover_beacons', False) if existing_config else False,\n            help=\"When enabled, automatically register new BLE devices detected by gateways. Disable this to only track manually registered beacons.\"\n        )\n        \n        if existing_config:\n            current_auto_discover = getattr(existing_config, 'auto_discover_beacons', False)\n            if auto_discover != current_auto_discover:\n                existing_config.auto_discover_beacons = auto_discover\n                session.commit()\n                if auto_discover:\n                    st.success(\"Auto-discovery enabled - new beacons will be registered automatically\")\n                else:\n                    st.info(\"Auto-discovery disabled - only registered beacons will be tracked\")\n                st.rerun()\n        \n        st.markdown(\"---\")\n        st.subheader(\"Processing Settings\")\n        st.markdown(\"Configure position calculation speed and precision\")\n        \n        with st.form(\"processing_settings\"):\n            col_ps1, col_ps2 = st.columns(2)\n            \n            with col_ps1:\n                refresh_options = {\n                    \"0.5 seconds (Fast)\": 0.5,\n                    \"1.0 second (Default)\": 1.0,\n                    \"2.0 seconds (Battery Saver)\": 2.0\n                }\n                current_refresh = getattr(existing_config, 'refresh_interval', 1.0) if existing_config else 1.0\n                current_option = next((k for k, v in refresh_options.items() if v == current_refresh), \"1.0 second (Default)\")\n                \n                refresh_rate = st.selectbox(\n                    \"Position Refresh Rate\",\n                    options=list(refresh_options.keys()),\n                    index=list(refresh_options.keys()).index(current_option),\n                    help=\"How often to calculate beacon positions. Faster = more responsive but more CPU usage\"\n                )\n                \n                signal_window = st.slider(\n                    \"Signal Window (seconds)\",\n                    min_value=1.0,\n                    max_value=30.0,\n                    value=getattr(existing_config, 'signal_window_seconds', 10.0) if existing_config else 10.0,\n                    step=1.0,\n                    help=\"How far back to look for RSSI signals. Longer = more stable, shorter = more responsive\"\n                )\n            \n            with col_ps2:\n                rssi_smoothing = st.checkbox(\n                    \"Enable RSSI Smoothing\",\n                    value=getattr(existing_config, 'rssi_smoothing_enabled', True) if existing_config else True,\n                    help=\"Average multiple RSSI readings to reduce noise\"\n                )\n                \n                position_alpha = st.slider(\n                    \"Position Smoothing Factor\",\n                    min_value=0.1,\n                    max_value=1.0,\n                    value=getattr(existing_config, 'position_smoothing_alpha', 0.4) if existing_config else 0.4,\n                    step=0.1,\n                    help=\"0.1 = very smooth (slow response), 1.0 = no smoothing (instant but jittery)\"\n                )\n            \n            processing_submitted = st.form_submit_button(\"Save Processing Settings\", type=\"primary\")\n            \n            if processing_submitted:\n                if existing_config:\n                    existing_config.refresh_interval = refresh_options[refresh_rate]\n                    existing_config.signal_window_seconds = signal_window\n                    existing_config.rssi_smoothing_enabled = rssi_smoothing\n                    existing_config.position_smoothing_alpha = position_alpha\n                    session.commit()\n                    \n                    processor = get_signal_processor()\n                    if processor.is_running:\n                        processor.stop()\n                        time.sleep(0.3)\n                        processor.start()\n                    \n                    set_success_and_rerun(\"Processing settings saved! Signal processor restarted with new settings.\")\n                else:\n                    st.warning(\"Please save broker configuration first\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Signal Processor Control\")\n        \n        processor = get_signal_processor()\n        \n        col_proc1, col_proc2 = st.columns(2)\n        \n        with col_proc1:\n            if processor.is_running:\n                st.success(\"Signal Processor: Running\")\n                if st.button(\"Stop Processor\"):\n                    processor.stop()\n                    st.rerun()\n            else:\n                st.warning(\"Signal Processor: Stopped\")\n                if processor.last_error:\n                    st.error(f\"Last error: {processor.last_error}\")\n                if st.button(\"Start Processor\", type=\"primary\"):\n                    if processor.start():\n                        st.success(\"Processor started!\")\n                        st.rerun()\n                    else:\n                        st.error(processor.last_error or \"Failed to start\")\n        \n        with col_proc2:\n            if processor.is_running:\n                stats = processor.stats\n                st.write(f\"**Signals received:** {stats['signals_received']}\")\n                st.write(f\"**Signals stored:** {stats['signals_stored']}\")\n                st.write(f\"**Positions calculated:** {stats['positions_calculated']}\")\n                if 'positions_published' in stats:\n                    st.write(f\"**Positions published:** {stats['positions_published']}\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Expected Message Format\")\n        \n        st.markdown(\"\"\"\n        **Moko MKGW-mini03 Gateway Format** (CFS/Careflow):\n        \n        ```json\n        {\n            \"msg_id\": \"12345\",\n            \"device_info\": {\n                \"mac\": \"00E04C006BF1\",\n                \"timestamp\": 1699999999\n            },\n            \"beacons\": [\n                {\n                    \"type\": \"iBeacon\",\n                    \"mac\": \"AABBCCDDEEFF\",\n                    \"rssi\": -65,\n                    \"raw_data\": \"0201061AFF4C000215...\",\n                    \"tx_power\": -59\n                }\n            ]\n        }\n        ```\n        \n        **Topic Structure for Moko Gateways:**\n        - Gateway publishes to: `/cfs1/{gateway_mac}/send`\n        - Gateway subscribes to: `/cfs1/{gateway_mac}/receive`\n        \n        **Multiple Gateway Topics:**\n        Use comma-separated topics to subscribe to multiple gateways:\n        ```\n        /cfs1/+/send, /cfs2/+/send\n        ```\n        \n        **Wildcard Patterns:**\n        - `+` matches one level (e.g., `/cfs1/+/send` matches any gateway MAC)\n        - `#` matches multiple levels (e.g., `#` matches all topics)\n        \"\"\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Configuration History\")\n        \n        all_configs = session.query(MQTTConfig).order_by(MQTTConfig.created_at.desc()).all()\n        \n        if all_configs:\n            for config in all_configs:\n                status = \"ðŸŸ¢ Active\" if config.is_active else \"âšª Inactive\"\n                with st.expander(f\"{status} - {config.broker_host}:{config.broker_port}\"):\n                    st.write(f\"**Topic Prefix:** {config.topic_prefix}\")\n                    st.write(f\"**TLS:** {'Yes' if config.use_tls else 'No'}\")\n                    st.write(f\"**Username:** {config.username or 'Not set'}\")\n                    st.write(f\"**Password Env Key:** {config.password_env_key or 'Not set'}\")\n                    st.write(f\"**Created:** {config.created_at}\")\n                    \n                    if not config.is_active:\n                        if st.button(\"Set Active\", key=f\"activate_{config.id}\"):\n                            for c in all_configs:\n                                c.is_active = False\n                            config.is_active = True\n                            session.commit()\n                            set_success_and_rerun(\"Configuration activated\")\n                        \n                        if st.button(\"Delete\", key=f\"delete_{config.id}\", type=\"secondary\"):\n                            session.delete(config)\n                            session.commit()\n                            set_success_and_rerun(\"Configuration deleted\")\n        else:\n            st.info(\"No MQTT configurations saved yet.\")\n","path":null,"size_bytes":19646,"size_tokens":null},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"ezdxf>=1.4.3\",\n    \"numpy>=2.3.5\",\n    \"paho-mqtt>=2.1.0\",\n    \"pandas>=2.3.3\",\n    \"pillow>=12.0.0\",\n    \"plotly>=6.5.0\",\n    \"psycopg2-binary>=2.9.11\",\n    \"pymupdf>=1.26.6\",\n    \"sqlalchemy>=2.0.44\",\n    \"streamlit>=1.51.0\",\n    \"streamlit-drawable-canvas>=0.9.3\",\n    \"streamlit-plotly-events>=0.0.6\",\n]\n","path":null,"size_bytes":455,"size_tokens":null},"views/buildings.py":{"content":"import streamlit as st\nfrom database import get_db_session, Building, Floor\nfrom datetime import datetime\nimport base64\nfrom io import BytesIO\nfrom PIL import Image\nimport json\nimport re\nfrom utils.dwg_parser import parse_dxf_file, dxf_to_geojson, get_dxf_dimensions, detect_dxf_scale\n\n\ndef show_pending_message():\n    \"\"\"Display any pending success message from session state\"\"\"\n    if 'buildings_success_msg' in st.session_state:\n        st.success(st.session_state['buildings_success_msg'])\n        del st.session_state['buildings_success_msg']\n\n\ndef set_success_and_rerun(message):\n    \"\"\"Store success message in session state and rerun\"\"\"\n    st.session_state['buildings_success_msg'] = message\n    st.rerun()\n\n\ndef parse_gps_coordinates(coord_string):\n    \"\"\"\n    Parse GPS coordinates in various formats:\n    - \"53.8578Â°,10.6712Â° 53.8580Â°,10.6706Â°\" (pairs separated by space)\n    - \"53.8578,10.6712 53.8580,10.6706\" (without degree symbols)\n    - \"53.8578Â°, 10.6712Â°; 53.8580Â°, 10.6706Â°\" (semicolon separated)\n    \n    Returns list of (lat, lon) tuples and calculates centroid\n    \"\"\"\n    if not coord_string or not coord_string.strip():\n        return [], None, None\n    \n    cleaned = coord_string.replace('Â°', '').replace(';', ' ').strip()\n    cleaned = re.sub(r'\\s+', ' ', cleaned)\n    \n    pairs = []\n    parts = cleaned.split(' ')\n    \n    i = 0\n    while i < len(parts):\n        part = parts[i].strip()\n        if not part:\n            i += 1\n            continue\n            \n        if ',' in part:\n            coords = part.split(',')\n            if len(coords) == 2:\n                try:\n                    lat = float(coords[0].strip())\n                    lon = float(coords[1].strip())\n                    if -90 <= lat <= 90 and -180 <= lon <= 180:\n                        pairs.append((lat, lon))\n                except ValueError:\n                    pass\n        i += 1\n    \n    if not pairs:\n        return [], None, None\n    \n    avg_lat = sum(p[0] for p in pairs) / len(pairs)\n    avg_lon = sum(p[1] for p in pairs) / len(pairs)\n    \n    return pairs, avg_lat, avg_lon\n\n\ndef format_coords_for_display(boundary_coords):\n    \"\"\"Format stored coordinates for display\"\"\"\n    if not boundary_coords:\n        return \"Not set\"\n    try:\n        coords = json.loads(boundary_coords)\n        formatted = \" \".join([f\"{lat:.4f}Â°,{lon:.4f}Â°\" for lat, lon in coords])\n        return formatted\n    except:\n        return boundary_coords\n\n\ndef parse_geojson(content):\n    \"\"\"Parse and validate GeoJSON content\"\"\"\n    try:\n        data = json.loads(content)\n        if data.get('type') != 'FeatureCollection':\n            return None, \"GeoJSON must be a FeatureCollection\"\n        if 'features' not in data:\n            return None, \"GeoJSON must contain features\"\n        return data, None\n    except json.JSONDecodeError as e:\n        return None, f\"Invalid JSON: {str(e)}\"\n\n\ndef extract_geojson_bounds(geojson_data):\n    \"\"\"Extract bounding box from GeoJSON features\"\"\"\n    min_lat, max_lat = 90, -90\n    min_lon, max_lon = 180, -180\n    \n    def process_coords(coords):\n        nonlocal min_lat, max_lat, min_lon, max_lon\n        if isinstance(coords[0], (int, float)):\n            lon, lat = coords[0], coords[1]\n            min_lat = min(min_lat, lat)\n            max_lat = max(max_lat, lat)\n            min_lon = min(min_lon, lon)\n            max_lon = max(max_lon, lon)\n        else:\n            for c in coords:\n                process_coords(c)\n    \n    for feature in geojson_data.get('features', []):\n        geometry = feature.get('geometry', {})\n        coords = geometry.get('coordinates', [])\n        if coords:\n            process_coords(coords)\n    \n    if min_lat == 90:\n        return None\n    \n    return {\n        'min_lat': min_lat,\n        'max_lat': max_lat,\n        'min_lon': min_lon,\n        'max_lon': max_lon,\n        'center_lat': (min_lat + max_lat) / 2,\n        'center_lon': (min_lon + max_lon) / 2\n    }\n\n\ndef extract_geojson_rooms(geojson_data):\n    \"\"\"Extract room names and types from GeoJSON\"\"\"\n    rooms = []\n    for feature in geojson_data.get('features', []):\n        props = feature.get('properties', {})\n        geom_type = props.get('geomType', '')\n        name = props.get('name', '')\n        sub_type = props.get('subType', '')\n        \n        if geom_type == 'room' and name:\n            rooms.append({\n                'name': name,\n                'type': sub_type or 'room'\n            })\n    return rooms\n\n\ndef render():\n    st.title(\"Buildings & Floor Plans\")\n    st.markdown(\"Manage buildings and upload architectural floor plans\")\n    \n    show_pending_message()\n    \n    tab1, tab2 = st.tabs([\"Buildings\", \"Floor Plans\"])\n    \n    with tab1:\n        render_buildings()\n    \n    with tab2:\n        render_floor_plans()\n\n\ndef render_buildings():\n    with get_db_session() as session:\n        st.subheader(\"Add New Building\")\n        \n        with st.form(\"add_building\"):\n            col1, col2 = st.columns(2)\n            \n            with col1:\n                name = st.text_input(\"Building Name*\", placeholder=\"e.g., Main Office\")\n                address = st.text_input(\"Address\", placeholder=\"123 Main Street\")\n            \n            with col2:\n                st.markdown(\"**GPS Boundary Coordinates**\")\n                gps_coords = st.text_area(\n                    \"Enter GPS coordinates\",\n                    placeholder=\"53.8578Â°,10.6712Â° 53.8580Â°,10.6706Â°\\n(lat,lon pairs separated by spaces)\",\n                    help=\"Enter latitude,longitude pairs with optional Â° symbols. Pairs separated by spaces or semicolons. Example: 53.8578Â°,10.6712Â° 53.8580Â°,10.6706Â°\",\n                    height=100\n                )\n            \n            description = st.text_area(\"Description\", placeholder=\"Describe the building...\")\n            \n            submitted = st.form_submit_button(\"Add Building\", type=\"primary\")\n            \n            if submitted:\n                if name:\n                    coord_pairs, center_lat, center_lon = parse_gps_coordinates(gps_coords)\n                    \n                    boundary_json = json.dumps(coord_pairs) if coord_pairs else None\n                    \n                    building = Building(\n                        name=name,\n                        description=description,\n                        address=address,\n                        latitude=center_lat,\n                        longitude=center_lon,\n                        boundary_coords=boundary_json\n                    )\n                    session.add(building)\n                    session.commit()\n                    \n                    if coord_pairs:\n                        set_success_and_rerun(f\"Building '{name}' added with {len(coord_pairs)} boundary points!\")\n                    else:\n                        set_success_and_rerun(f\"Building '{name}' added successfully!\")\n                else:\n                    st.error(\"Building name is required\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Existing Buildings\")\n        \n        buildings = session.query(Building).order_by(Building.name).all()\n        \n        if buildings:\n            for building in buildings:\n                with st.expander(f\"ðŸ“ {building.name}\", expanded=False):\n                    col1, col2, col3 = st.columns([2, 2, 1])\n                    \n                    with col1:\n                        st.write(f\"**Address:** {building.address or 'Not specified'}\")\n                        st.write(f\"**Description:** {building.description or 'No description'}\")\n                    \n                    with col2:\n                        if building.latitude and building.longitude:\n                            st.write(f\"**Center GPS:** {building.latitude:.6f}, {building.longitude:.6f}\")\n                        else:\n                            st.write(\"**GPS:** Not set\")\n                        \n                        if building.boundary_coords:\n                            try:\n                                coords = json.loads(building.boundary_coords)\n                                st.write(f\"**Boundary Points:** {len(coords)}\")\n                            except:\n                                pass\n                        \n                        floor_count = session.query(Floor).filter(Floor.building_id == building.id).count()\n                        st.write(f\"**Floors:** {floor_count}\")\n                    \n                    with col3:\n                        if st.button(\"Delete\", key=f\"del_building_{building.id}\", type=\"secondary\"):\n                            building_name = building.name\n                            session.delete(building)\n                            session.commit()\n                            set_success_and_rerun(f\"Building '{building_name}' deleted\")\n                    \n                    if building.boundary_coords:\n                        with st.container():\n                            st.write(\"**Boundary Coordinates:**\")\n                            st.code(format_coords_for_display(building.boundary_coords), language=None)\n        else:\n            st.info(\"No buildings added yet. Add your first building above.\")\n\n\ndef render_floor_plans():\n    with get_db_session() as session:\n        buildings = session.query(Building).order_by(Building.name).all()\n        \n        if not buildings:\n            st.warning(\"Please add a building first before uploading floor plans.\")\n            return\n        \n        st.subheader(\"Upload Floor Plan\")\n        \n        building_options = {b.name: b.id for b in buildings}\n        \n        plan_type = st.radio(\n            \"Floor Plan Type\",\n            [\"Image (PNG/JPG)\", \"DXF (AutoCAD)\", \"GeoJSON\"],\n            horizontal=True,\n            help=\"Choose between uploading an image, DXF CAD file, or GeoJSON architectural file\",\n            key=\"floor_plan_type_selector\"\n        )\n        \n        if plan_type == \"Image (PNG/JPG)\":\n            with st.form(\"add_floor_image\"):\n                selected_building = st.selectbox(\"Select Building*\", options=list(building_options.keys()), key=\"img_building\")\n                \n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    floor_number = st.number_input(\"Floor Number*\", value=0, step=1, help=\"Use 0 for ground floor, negative for basement\", key=\"img_floor_num\")\n                    floor_name = st.text_input(\"Floor Name\", placeholder=\"e.g., Ground Floor, Level 1\", key=\"img_floor_name\")\n                \n                with col2:\n                    width_meters = st.number_input(\"Floor Width (meters)\", value=50.0, min_value=1.0, max_value=1000.0, key=\"img_width\")\n                    height_meters = st.number_input(\"Floor Height (meters)\", value=50.0, min_value=1.0, max_value=1000.0, key=\"img_height\")\n                \n                floor_plan_file = st.file_uploader(\n                    \"Upload Floor Plan Image*\",\n                    type=['png', 'jpg', 'jpeg'],\n                    help=\"Upload an architectural floor plan image\",\n                    key=\"img_uploader\"\n                )\n                \n                submitted = st.form_submit_button(\"Add Floor Plan\", type=\"primary\")\n                \n                if submitted:\n                    if not selected_building:\n                        st.error(\"Please select a building\")\n                    elif not floor_plan_file:\n                        st.error(\"Please upload a floor plan image\")\n                    else:\n                        image_data = floor_plan_file.read()\n                        \n                        floor = Floor(\n                            building_id=building_options[selected_building],\n                            floor_number=floor_number,\n                            name=floor_name or f\"Floor {floor_number}\",\n                            floor_plan_image=image_data,\n                            floor_plan_filename=floor_plan_file.name,\n                            floor_plan_type='image',\n                            width_meters=width_meters,\n                            height_meters=height_meters\n                        )\n                        session.add(floor)\n                        session.commit()\n                        set_success_and_rerun(\"Floor plan image uploaded successfully!\")\n        \n        elif plan_type == \"DXF (AutoCAD)\":\n            st.info(\"Upload a DXF file exported from AutoCAD, ArchiCAD, or other CAD software. For DWG files, please export to DXF first (File â†’ Save As â†’ DXF in AutoCAD).\")\n            \n            with st.form(\"add_floor_dxf\"):\n                selected_building = st.selectbox(\"Select Building*\", options=list(building_options.keys()), key=\"dxf_building\")\n                \n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    floor_number = st.number_input(\"Floor Number*\", value=0, step=1, help=\"Use 0 for ground floor, negative for basement\", key=\"dxf_floor_num\")\n                    floor_name = st.text_input(\"Floor Name\", placeholder=\"e.g., Ground Floor, Level 1\", key=\"dxf_floor_name\")\n                \n                with col2:\n                    scale_option = st.selectbox(\n                        \"Scale\",\n                        [\"Auto-detect\", \"Millimeters\", \"Centimeters\", \"Meters\", \"Inches\", \"Feet\"],\n                        help=\"Select the unit used in your DXF file\",\n                        key=\"dxf_scale\"\n                    )\n                \n                dxf_file = st.file_uploader(\n                    \"Upload DXF Floor Plan*\",\n                    type=['dxf'],\n                    help=\"Upload a DXF file from AutoCAD or similar CAD software\",\n                    key=\"dxf_uploader\"\n                )\n                \n                with st.expander(\"Advanced Settings\"):\n                    wall_layers = st.text_input(\n                        \"Wall Layer Names (comma-separated)\",\n                        value=\"WALL,WALLS,A-WALL,S-WALL,PARTITION\",\n                        help=\"Layer names that contain walls\"\n                    )\n                    room_layers = st.text_input(\n                        \"Room Layer Names (comma-separated)\",\n                        value=\"ROOM,ROOMS,A-AREA,A-ROOM,SPACE,ZONE\",\n                        help=\"Layer names that contain rooms/spaces\"\n                    )\n                \n                submitted = st.form_submit_button(\"Add Floor Plan\", type=\"primary\")\n                \n                if submitted:\n                    if not selected_building:\n                        st.error(\"Please select a building\")\n                    elif not dxf_file:\n                        st.error(\"Please upload a DXF file\")\n                    else:\n                        try:\n                            dxf_content = dxf_file.read()\n                            dxf_data = parse_dxf_file(dxf_content)\n                            \n                            if scale_option == \"Auto-detect\":\n                                scale = detect_dxf_scale(dxf_data)\n                            else:\n                                scale_map = {\n                                    \"Millimeters\": 0.001,\n                                    \"Centimeters\": 0.01,\n                                    \"Meters\": 1.0,\n                                    \"Inches\": 0.0254,\n                                    \"Feet\": 0.3048\n                                }\n                                scale = scale_map.get(scale_option, 1.0)\n                            \n                            wall_layer_list = [l.strip() for l in wall_layers.split(',')]\n                            room_layer_list = [l.strip() for l in room_layers.split(',')]\n                            \n                            bounds = dxf_data.get('bounds')\n                            origin_x = bounds['min_x'] if bounds else 0\n                            origin_y = bounds['min_y'] if bounds else 0\n                            \n                            geojson_str = dxf_to_geojson(\n                                dxf_data, \n                                scale=scale, \n                                origin_x=origin_x,\n                                origin_y=origin_y,\n                                wall_layers=wall_layer_list,\n                                room_layers=room_layer_list\n                            )\n                            \n                            width, height = get_dxf_dimensions(dxf_data, scale)\n                            \n                            floor = Floor(\n                                building_id=building_options[selected_building],\n                                floor_number=floor_number,\n                                name=floor_name or f\"Floor {floor_number}\",\n                                floor_plan_geojson=geojson_str,\n                                floor_plan_filename=dxf_file.name,\n                                floor_plan_type='dxf',\n                                width_meters=round(width, 2),\n                                height_meters=round(height, 2),\n                                origin_lat=0,\n                                origin_lon=0\n                            )\n                            session.add(floor)\n                            session.commit()\n                            \n                            entity_count = dxf_data.get('entity_count', 0)\n                            layers = dxf_data.get('layers', [])\n                            set_success_and_rerun(f\"DXF floor plan uploaded! Found {entity_count} entities across {len(layers)} layers. Dimensions: {width:.1f}m x {height:.1f}m\")\n                            \n                        except Exception as e:\n                            st.error(f\"Error parsing DXF file: {str(e)}\")\n        \n        else:\n            selected_building = st.selectbox(\"Select Building*\", options=list(building_options.keys()), key=\"geo_building\")\n            \n            col1, col2 = st.columns(2)\n            \n            with col1:\n                floor_number = st.number_input(\"Floor Number*\", value=0, step=1, help=\"Use 0 for ground floor, negative for basement\", key=\"geo_floor_num\")\n                floor_name = st.text_input(\"Floor Name\", placeholder=\"e.g., Ground Floor, Level 1\", key=\"geo_floor_name\")\n            \n            with col2:\n                st.info(\"Dimensions will be calculated from GeoJSON bounds\")\n            \n            input_method = st.radio(\n                \"Input Method\",\n                [\"Paste GeoJSON\", \"Upload File\"],\n                horizontal=True,\n                help=\"Choose how to provide your GeoJSON floor plan\"\n            )\n            \n            geojson_content = None\n            filename = \"floor_plan.geojson\"\n            \n            if input_method == \"Paste GeoJSON\":\n                geojson_text = st.text_area(\n                    \"Paste GeoJSON Content*\",\n                    height=300,\n                    placeholder='{\"type\": \"FeatureCollection\", \"features\": [...]}',\n                    help=\"Paste the complete GeoJSON content here\"\n                )\n                if geojson_text:\n                    geojson_content = geojson_text.strip()\n            else:\n                geojson_file = st.file_uploader(\n                    \"Upload GeoJSON Floor Plan*\",\n                    type=None,\n                    help=\"Upload a GeoJSON file (.geojson or .json)\",\n                    key=\"geo_uploader\"\n                )\n                if geojson_file:\n                    geojson_content = geojson_file.read().decode('utf-8')\n                    filename = geojson_file.name\n            \n            if st.button(\"Add Floor Plan\", type=\"primary\", key=\"add_geojson_btn\"):\n                if not selected_building:\n                    st.error(\"Please select a building\")\n                elif not geojson_content:\n                    st.error(\"Please provide GeoJSON content (paste or upload)\")\n                else:\n                    geojson_data, error = parse_geojson(geojson_content)\n                    \n                    if error:\n                        st.error(f\"GeoJSON Error: {error}\")\n                    else:\n                        bounds = extract_geojson_bounds(geojson_data)\n                        \n                        if bounds:\n                            lat_range = bounds['max_lat'] - bounds['min_lat']\n                            lon_range = bounds['max_lon'] - bounds['min_lon']\n                            calc_height = lat_range * 111000\n                            calc_width = lon_range * 111000 * abs(cos_deg(bounds['center_lat']))\n                            \n                            floor = Floor(\n                                building_id=building_options[selected_building],\n                                floor_number=floor_number,\n                                name=floor_name or f\"Floor {floor_number}\",\n                                floor_plan_geojson=geojson_content,\n                                floor_plan_filename=filename,\n                                floor_plan_type='geojson',\n                                width_meters=round(calc_width, 2),\n                                height_meters=round(calc_height, 2),\n                                origin_lat=bounds['min_lat'],\n                                origin_lon=bounds['min_lon']\n                            )\n                            session.add(floor)\n                            session.commit()\n                            \n                            rooms = extract_geojson_rooms(geojson_data)\n                            room_count = len(rooms)\n                            set_success_and_rerun(f\"GeoJSON floor plan uploaded! Found {room_count} named rooms. Dimensions: {calc_width:.1f}m x {calc_height:.1f}m\")\n                        else:\n                            st.error(\"Could not extract bounds from GeoJSON\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Existing Floor Plans\")\n        \n        for building in buildings:\n            floors = session.query(Floor).filter(\n                Floor.building_id == building.id\n            ).order_by(Floor.floor_number).all()\n            \n            if floors:\n                st.write(f\"**{building.name}**\")\n                \n                for floor in floors:\n                    plan_type_label = f\"[{floor.floor_plan_type or 'image'}]\" if floor.floor_plan_type else \"\"\n                    with st.expander(f\"Floor {floor.floor_number}: {floor.name or ''} {plan_type_label}\", expanded=False):\n                        col1, col2 = st.columns([2, 1])\n                        \n                        with col1:\n                            if floor.floor_plan_type == 'geojson' and floor.floor_plan_geojson:\n                                render_geojson_preview(floor)\n                            elif floor.floor_plan_image:\n                                try:\n                                    image = Image.open(BytesIO(floor.floor_plan_image))\n                                    st.image(image, caption=f\"{floor.name or f'Floor {floor.floor_number}'}\", use_container_width=True)\n                                except Exception as e:\n                                    st.error(f\"Error displaying image: {e}\")\n                        \n                        with col2:\n                            st.write(f\"**Type:** {floor.floor_plan_type or 'image'}\")\n                            st.write(f\"**Dimensions:** {floor.width_meters:.1f}m x {floor.height_meters:.1f}m\")\n                            st.write(f\"**Filename:** {floor.floor_plan_filename}\")\n                            \n                            if floor.origin_lat and floor.origin_lon:\n                                st.write(f\"**Origin:** {floor.origin_lat:.6f}, {floor.origin_lon:.6f}\")\n                            \n                            if floor.floor_plan_type == 'geojson' and floor.floor_plan_geojson:\n                                try:\n                                    geojson_data = json.loads(floor.floor_plan_geojson)\n                                    rooms = extract_geojson_rooms(geojson_data)\n                                    if rooms:\n                                        st.write(f\"**Rooms:** {len(rooms)}\")\n                                        with st.popover(\"View Rooms\"):\n                                            for room in rooms[:20]:\n                                                st.write(f\"â€¢ {room['name']} ({room['type']})\")\n                                            if len(rooms) > 20:\n                                                st.write(f\"... and {len(rooms) - 20} more\")\n                                except:\n                                    pass\n                            \n                            if st.button(\"Delete\", key=f\"del_floor_{floor.id}\", type=\"secondary\"):\n                                session.delete(floor)\n                                session.commit()\n                                set_success_and_rerun(\"Floor plan deleted\")\n                \n                st.markdown(\"---\")\n\n\ndef cos_deg(degrees):\n    \"\"\"Calculate cosine of angle in degrees\"\"\"\n    import math\n    return math.cos(math.radians(degrees))\n\n\ndef render_geojson_preview(floor):\n    \"\"\"Render a preview of GeoJSON floor plan\"\"\"\n    try:\n        geojson_data = json.loads(floor.floor_plan_geojson)\n        \n        st.markdown(\"**GeoJSON Floor Plan Preview**\")\n        \n        feature_count = len(geojson_data.get('features', []))\n        rooms = extract_geojson_rooms(geojson_data)\n        \n        col_a, col_b, col_c = st.columns(3)\n        with col_a:\n            st.metric(\"Features\", feature_count)\n        with col_b:\n            st.metric(\"Named Rooms\", len(rooms))\n        with col_c:\n            bounds = extract_geojson_bounds(geojson_data)\n            if bounds:\n                st.metric(\"Center\", f\"{bounds['center_lat']:.4f}, {bounds['center_lon']:.4f}\")\n        \n        geom_types = {}\n        for feature in geojson_data.get('features', []):\n            props = feature.get('properties', {})\n            geom_type = props.get('geomType', 'unknown')\n            geom_types[geom_type] = geom_types.get(geom_type, 0) + 1\n        \n        if geom_types:\n            st.write(\"**Feature Types:**\")\n            types_str = \", \".join([f\"{k}: {v}\" for k, v in geom_types.items()])\n            st.write(types_str)\n        \n        with st.popover(\"View Raw GeoJSON\"):\n            st.json(geojson_data)\n            \n    except Exception as e:\n        st.error(f\"Error rendering GeoJSON: {e}\")\n","path":null,"size_bytes":26659,"size_tokens":null},"app.py":{"content":"import streamlit as st\nfrom database import init_db\nimport base64\nfrom pathlib import Path\n\nst.set_page_config(\n    page_title=\"Careflow Setup\",\n    page_icon=\"ðŸ“\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\nst.markdown(\"\"\"\n<style>\n    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');\n    \n    :root {\n        --cf-primary: #2563eb;\n        --cf-primary-dark: #1d4ed8;\n        --cf-primary-light: #3b82f6;\n        --cf-accent: #0ea5e9;\n        --cf-text: #1e293b;\n        --cf-text-light: #64748b;\n        --cf-bg: #ffffff;\n        --cf-bg-subtle: #f8fafc;\n        --cf-border: #e2e8f0;\n        --cf-success: #10b981;\n        --cf-warning: #f59e0b;\n        --cf-error: #ef4444;\n    }\n    \n    .stApp {\n        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;\n    }\n    \n    /* Sidebar styling */\n    section[data-testid=\"stSidebar\"] {\n        background: linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%);\n        border-right: 1px solid var(--cf-border);\n    }\n    \n    section[data-testid=\"stSidebar\"] .stRadio > label {\n        font-family: 'Inter', sans-serif;\n        font-weight: 500;\n    }\n    \n    div[data-testid=\"stSidebarHeader\"] {\n        padding-top: 1rem;\n    }\n    \n    /* Logo container */\n    .logo-container {\n        padding: 10px 0;\n        margin-bottom: 5px;\n        text-align: center;\n    }\n    \n    .logo-container img {\n        width: 100%;\n        max-width: 180px;\n        height: auto;\n        display: inline-block;\n    }\n    \n    .careflow-subtitle {\n        font-family: 'Inter', sans-serif;\n        font-size: 0.7rem;\n        color: var(--cf-text-light);\n        margin-top: 8px;\n        letter-spacing: 1.5px;\n        font-weight: 600;\n    }\n    \n    /* Headers */\n    h1, h2, h3 {\n        font-family: 'Inter', sans-serif;\n        color: var(--cf-text);\n        font-weight: 600;\n    }\n    \n    h1 {\n        font-size: 1.875rem;\n        margin-bottom: 0.5rem;\n    }\n    \n    /* Card styling */\n    .cf-card {\n        background: var(--cf-bg);\n        border: 1px solid var(--cf-border);\n        border-radius: 12px;\n        padding: 1.5rem;\n        margin-bottom: 1rem;\n        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);\n        transition: box-shadow 0.2s ease;\n    }\n    \n    .cf-card:hover {\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);\n    }\n    \n    .cf-card-header {\n        font-family: 'Inter', sans-serif;\n        font-size: 1rem;\n        font-weight: 600;\n        color: var(--cf-text);\n        margin-bottom: 1rem;\n        padding-bottom: 0.75rem;\n        border-bottom: 1px solid var(--cf-border);\n    }\n    \n    /* Metric cards */\n    .cf-metric {\n        background: var(--cf-bg);\n        border: 1px solid var(--cf-border);\n        border-radius: 12px;\n        padding: 1.25rem;\n        text-align: center;\n        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);\n    }\n    \n    .cf-metric-value {\n        font-family: 'Inter', sans-serif;\n        font-size: 2rem;\n        font-weight: 700;\n        color: var(--cf-primary);\n        line-height: 1.2;\n    }\n    \n    .cf-metric-label {\n        font-family: 'Inter', sans-serif;\n        font-size: 0.8rem;\n        color: var(--cf-text-light);\n        font-weight: 500;\n        margin-top: 0.5rem;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n    }\n    \n    /* Streamlit metric override */\n    div[data-testid=\"stMetric\"] {\n        background: var(--cf-bg);\n        border: 1px solid var(--cf-border);\n        border-radius: 12px;\n        padding: 1rem 1.25rem;\n        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);\n    }\n    \n    div[data-testid=\"stMetric\"] label {\n        font-family: 'Inter', sans-serif;\n        font-weight: 500;\n        color: var(--cf-text-light);\n    }\n    \n    div[data-testid=\"stMetric\"] div[data-testid=\"stMetricValue\"] {\n        font-family: 'Inter', sans-serif;\n        font-weight: 700;\n        color: var(--cf-primary);\n    }\n    \n    /* Buttons */\n    .stButton > button {\n        font-family: 'Inter', sans-serif;\n        font-weight: 500;\n        border-radius: 8px;\n        padding: 0.5rem 1.25rem;\n        transition: all 0.2s ease;\n        border: none;\n    }\n    \n    .stButton > button:hover {\n        transform: translateY(-1px);\n        box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);\n    }\n    \n    .stButton > button[kind=\"primary\"] {\n        background: linear-gradient(135deg, var(--cf-primary) 0%, var(--cf-primary-dark) 100%);\n    }\n    \n    /* Form inputs */\n    .stTextInput > div > div > input,\n    .stNumberInput > div > div > input,\n    .stSelectbox > div > div > div {\n        font-family: 'Inter', sans-serif;\n        border-radius: 8px;\n        border: 1px solid var(--cf-border);\n    }\n    \n    .stTextInput > div > div > input:focus,\n    .stNumberInput > div > div > input:focus {\n        border-color: var(--cf-primary);\n        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);\n    }\n    \n    /* Tables */\n    .stDataFrame {\n        border-radius: 12px;\n        overflow: hidden;\n        border: 1px solid var(--cf-border);\n    }\n    \n    /* Expander */\n    .streamlit-expanderHeader {\n        font-family: 'Inter', sans-serif;\n        font-weight: 500;\n        background: var(--cf-bg-subtle);\n        border-radius: 8px;\n    }\n    \n    /* Tabs */\n    .stTabs [data-baseweb=\"tab-list\"] {\n        gap: 8px;\n    }\n    \n    .stTabs [data-baseweb=\"tab\"] {\n        font-family: 'Inter', sans-serif;\n        font-weight: 500;\n        border-radius: 8px 8px 0 0;\n        padding: 0.75rem 1.25rem;\n    }\n    \n    /* Status indicators */\n    .cf-status {\n        display: inline-flex;\n        align-items: center;\n        gap: 6px;\n        padding: 4px 12px;\n        border-radius: 20px;\n        font-family: 'Inter', sans-serif;\n        font-size: 0.8rem;\n        font-weight: 500;\n    }\n    \n    .cf-status-success {\n        background: rgba(16, 185, 129, 0.1);\n        color: var(--cf-success);\n    }\n    \n    .cf-status-warning {\n        background: rgba(245, 158, 11, 0.1);\n        color: var(--cf-warning);\n    }\n    \n    .cf-status-error {\n        background: rgba(239, 68, 68, 0.1);\n        color: var(--cf-error);\n    }\n    \n    /* Dividers */\n    hr {\n        border: none;\n        border-top: 1px solid var(--cf-border);\n        margin: 1.5rem 0;\n    }\n    \n    /* Info boxes */\n    .stAlert {\n        border-radius: 10px;\n        font-family: 'Inter', sans-serif;\n    }\n    \n    /* Scrollbar styling */\n    ::-webkit-scrollbar {\n        width: 8px;\n        height: 8px;\n    }\n    \n    ::-webkit-scrollbar-track {\n        background: var(--cf-bg-subtle);\n        border-radius: 4px;\n    }\n    \n    ::-webkit-scrollbar-thumb {\n        background: var(--cf-border);\n        border-radius: 4px;\n    }\n    \n    ::-webkit-scrollbar-thumb:hover {\n        background: var(--cf-text-light);\n    }\n    \n    /* Section headers */\n    .cf-section-header {\n        font-family: 'Inter', sans-serif;\n        font-size: 1.25rem;\n        font-weight: 600;\n        color: var(--cf-text);\n        margin: 1.5rem 0 1rem 0;\n        padding-bottom: 0.5rem;\n        border-bottom: 2px solid var(--cf-primary);\n        display: inline-block;\n    }\n    \n    /* Badge styling */\n    .cf-badge {\n        display: inline-block;\n        padding: 2px 8px;\n        border-radius: 4px;\n        font-family: 'Inter', sans-serif;\n        font-size: 0.7rem;\n        font-weight: 600;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n    }\n    \n    .cf-badge-primary {\n        background: var(--cf-primary);\n        color: white;\n    }\n    \n    .cf-badge-secondary {\n        background: var(--cf-bg-subtle);\n        color: var(--cf-text-light);\n        border: 1px solid var(--cf-border);\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\ntry:\n    init_db()\nexcept Exception as e:\n    st.error(f\"Database initialization error: {e}\")\n\n# Signal processor is manually started from MQTT Configuration page\n# This prevents auto-connection attempts that could slow down the app\n\nlogo_path = Path(\"attached_assets/CAREFLOW LOGO-Color_1764612034940.png\")\nif logo_path.exists():\n    with open(logo_path, \"rb\") as f:\n        logo_data = base64.b64encode(f.read()).decode()\n    st.sidebar.markdown(\n        f'<div class=\"logo-container\"><img src=\"data:image/png;base64,{logo_data}\" alt=\"Careflow\"></div>',\n        unsafe_allow_html=True\n    )\nelse:\n    st.sidebar.markdown(\n        '<div style=\"font-family: Inter, sans-serif; font-size: 1.8rem; font-weight: 700; '\n        'background: linear-gradient(135deg, #2e5cbf 0%, #008ed3 100%); '\n        '-webkit-background-clip: text; -webkit-text-fill-color: transparent; '\n        'background-clip: text; margin-bottom: 0.5rem;\">CareFlow</div>',\n        unsafe_allow_html=True\n    )\n\nst.sidebar.markdown('<div class=\"careflow-subtitle\" style=\"font-weight: 700; text-transform: uppercase; text-align: center;\">CAREFLOW SETUP</div>', unsafe_allow_html=True)\nst.sidebar.markdown(\"---\")\n\npage = st.sidebar.radio(\n    \"Navigation\",\n    [\n        \"Dashboard\",\n        \"Buildings & Floor Plans\",\n        \"Coverage Zones\",\n        \"Gateway Planning\",\n        \"Gateways\",\n        \"Beacons\",\n        \"MQTT Configuration\",\n        \"Live Tracking\",\n        \"History Playback\",\n        \"Import/Export\",\n        \"Calibration\",\n        \"Signal Monitor\"\n    ],\n    index=0,\n    key=\"main_navigation\"\n)\n\nst.sidebar.markdown(\"---\")\n\ntry:\n    from utils.signal_processor import get_signal_processor\n    from datetime import datetime, timedelta\n    processor = get_signal_processor()\n    processor.check_and_restart()\n    if processor.is_running:\n        heartbeat = processor.last_heartbeat\n        if heartbeat and (datetime.utcnow() - heartbeat).total_seconds() < 10:\n            st.sidebar.success(\"Signal Processor: Running\")\n        elif heartbeat:\n            st.sidebar.warning(f\"Signal Processor: Stale ({int((datetime.utcnow() - heartbeat).total_seconds())}s)\")\n        else:\n            st.sidebar.success(\"Signal Processor: Running\")\n    else:\n        st.sidebar.warning(\"Signal Processor: Stopped\")\nexcept Exception:\n    st.sidebar.info(\"Signal Processor: Not initialized\")\n\n\nif page == \"Dashboard\":\n    from views import dashboard\n    dashboard.render()\nelif page == \"Buildings & Floor Plans\":\n    from views import buildings\n    buildings.render()\nelif page == \"Coverage Zones\":\n    from views import coverage_zones\n    coverage_zones.show()\nelif page == \"Gateway Planning\":\n    from views import gateway_planning\n    gateway_planning.render_gateway_planning()\nelif page == \"Gateways\":\n    from views import gateways\n    gateways.render()\nelif page == \"Beacons\":\n    from views import beacons\n    beacons.render()\nelif page == \"MQTT Configuration\":\n    from views import mqtt_config\n    mqtt_config.render()\nelif page == \"Live Tracking\":\n    from views import live_tracking\n    live_tracking.render()\nelif page == \"History Playback\":\n    from views import history_playback\n    history_playback.render()\nelif page == \"Import/Export\":\n    from views import import_export\n    import_export.render()\nelif page == \"Calibration\":\n    from views import calibration\n    calibration.render()\nelif page == \"Signal Monitor\":\n    from views import signal_monitor\n    signal_monitor.render()\n","path":null,"size_bytes":11253,"size_tokens":null},"views/gateways.py":{"content":"import streamlit as st\nfrom database import get_db_session, Building, Floor, Gateway\nfrom datetime import datetime\nimport re\nimport json\nimport plotly.graph_objects as go\n\n\ndef validate_mac_address(mac: str) -> bool:\n    \"\"\"Validate MAC address format\"\"\"\n    pattern = re.compile(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$')\n    return bool(pattern.match(mac))\n\n\ndef show_pending_message():\n    \"\"\"Display any pending success message from session state\"\"\"\n    if 'gateways_success_msg' in st.session_state:\n        st.success(st.session_state['gateways_success_msg'])\n        del st.session_state['gateways_success_msg']\n\n\ndef set_success_and_rerun(message):\n    \"\"\"Store success message in session state and rerun\"\"\"\n    st.session_state['gateways_success_msg'] = message\n    st.rerun()\n\n\ndef extract_rooms_from_geojson(geojson_str):\n    \"\"\"Extract room names and their center coordinates from GeoJSON\"\"\"\n    rooms = []\n    try:\n        geojson_data = json.loads(geojson_str)\n        for feature in geojson_data.get('features', []):\n            props = feature.get('properties', {})\n            geom = feature.get('geometry', {})\n            \n            if props.get('geomType') == 'room':\n                name = props.get('name', '')\n                if name:\n                    coords = geom.get('coordinates', [])\n                    if coords and geom.get('type') == 'Polygon':\n                        ring = coords[0] if coords else []\n                        if ring:\n                            lons = [c[0] for c in ring]\n                            lats = [c[1] for c in ring]\n                            center_lon = sum(lons) / len(lons)\n                            center_lat = sum(lats) / len(lats)\n                            rooms.append({\n                                'name': name,\n                                'type': props.get('subType', 'room'),\n                                'center_lat': center_lat,\n                                'center_lon': center_lon\n                            })\n    except:\n        pass\n    return rooms\n\n\ndef create_floor_plan_figure(floor, gateways=None, rooms=None):\n    \"\"\"Create a Plotly figure showing the floor plan with rooms and gateways\"\"\"\n    fig = go.Figure()\n    \n    if floor.floor_plan_geojson:\n        try:\n            geojson_data = json.loads(floor.floor_plan_geojson)\n            \n            for feature in geojson_data.get('features', []):\n                props = feature.get('properties', {})\n                geom = feature.get('geometry', {})\n                geom_type = props.get('geomType', '')\n                \n                if geom_type == 'room' and geom.get('type') == 'Polygon':\n                    coords = geom.get('coordinates', [[]])[0]\n                    if coords:\n                        lons = [c[0] for c in coords]\n                        lats = [c[1] for c in coords]\n                        name = props.get('name', 'Unnamed')\n                        \n                        fig.add_trace(go.Scatter(\n                            x=lons,\n                            y=lats,\n                            fill='toself',\n                            fillcolor='rgba(46, 92, 191, 0.2)',\n                            line=dict(color='#2e5cbf', width=1),\n                            name=name,\n                            hovertemplate=f\"<b>{name}</b><br>Click to place gateway here<extra></extra>\",\n                            mode='lines'\n                        ))\n                        \n                        center_lon = sum(lons) / len(lons)\n                        center_lat = sum(lats) / len(lats)\n                        fig.add_annotation(\n                            x=center_lon,\n                            y=center_lat,\n                            text=name[:15],\n                            showarrow=False,\n                            font=dict(size=8, color='#1a1a1a')\n                        )\n                \n                elif geom_type == 'wall' and geom.get('type') == 'LineString':\n                    coords = geom.get('coordinates', [])\n                    if coords:\n                        lons = [c[0] for c in coords]\n                        lats = [c[1] for c in coords]\n                        wall_type = props.get('subType', 'inner')\n                        line_width = 2 if wall_type == 'outer' else 1\n                        \n                        fig.add_trace(go.Scatter(\n                            x=lons,\n                            y=lats,\n                            mode='lines',\n                            line=dict(color='#333', width=line_width),\n                            showlegend=False,\n                            hoverinfo='skip'\n                        ))\n        except Exception as e:\n            st.warning(f\"Error rendering floor plan: {e}\")\n    \n    if gateways:\n        gw_lons = []\n        gw_lats = []\n        gw_names = []\n        for gw in gateways:\n            if gw.latitude and gw.longitude:\n                gw_lons.append(gw.longitude)\n                gw_lats.append(gw.latitude)\n                gw_names.append(gw.name)\n        \n        if gw_lons:\n            fig.add_trace(go.Scatter(\n                x=gw_lons,\n                y=gw_lats,\n                mode='markers+text',\n                marker=dict(symbol='square', size=12, color='#e74c3c'),\n                text=gw_names,\n                textposition='top center',\n                name='Gateways',\n                hovertemplate=\"<b>%{text}</b><br>Gateway<extra></extra>\"\n            ))\n    \n    fig.update_layout(\n        showlegend=False,\n        xaxis=dict(\n            scaleanchor='y',\n            scaleratio=1,\n            showgrid=False,\n            zeroline=False,\n            showticklabels=False,\n            title=''\n        ),\n        yaxis=dict(\n            showgrid=False,\n            zeroline=False,\n            showticklabels=False,\n            title=''\n        ),\n        margin=dict(l=10, r=10, t=10, b=10),\n        height=400,\n        plot_bgcolor='white'\n    )\n    \n    return fig\n\n\ndef render():\n    st.title(\"Gateway Configuration\")\n    st.markdown(\"Configure Careflow BLE Gateway devices\")\n    \n    show_pending_message()\n    \n    with get_db_session() as session:\n        buildings = session.query(Building).order_by(Building.name).all()\n        \n        if not buildings:\n            st.warning(\"Please add a building first before configuring gateways.\")\n            st.info(\"Go to 'Buildings & Floor Plans' to add a building.\")\n            return\n        \n        st.subheader(\"Add New Gateway\")\n        \n        building_options = {b.name: b.id for b in buildings}\n        selected_building_name = st.selectbox(\"Select Building*\", options=list(building_options.keys()))\n        selected_building_id = building_options[selected_building_name]\n        \n        floors = session.query(Floor).filter(\n            Floor.building_id == selected_building_id\n        ).order_by(Floor.floor_number).all()\n        \n        if not floors:\n            st.warning(\"Please upload a floor plan for this building first.\")\n            return\n        \n        floor_options = {f\"{f.floor_number}: {f.name or 'Floor ' + str(f.floor_number)}\": f.id for f in floors}\n        selected_floor_key = st.selectbox(\"Select Floor*\", options=list(floor_options.keys()))\n        selected_floor_id = floor_options[selected_floor_key]\n        \n        selected_floor = session.query(Floor).filter(Floor.id == selected_floor_id).first()\n        \n        existing_gateways = session.query(Gateway).filter(\n            Gateway.floor_id == selected_floor_id\n        ).all()\n        \n        rooms = []\n        if selected_floor and selected_floor.floor_plan_geojson:\n            rooms = extract_rooms_from_geojson(selected_floor.floor_plan_geojson)\n            \n            st.markdown(\"#### Floor Plan - Select Room for Gateway Position\")\n            st.caption(\"View the floor plan below. Select a room from the dropdown to auto-fill coordinates.\")\n            \n            fig = create_floor_plan_figure(selected_floor, existing_gateways, rooms)\n            st.plotly_chart(fig, use_container_width=True, key=\"gateway_floor_plan\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            mac_address = st.text_input(\n                \"MAC Address*\",\n                placeholder=\"AA:BB:CC:DD:EE:FF\",\n                help=\"The MAC address of the Careflow gateway\"\n            ).upper()\n            \n            name = st.text_input(\n                \"Gateway Name*\",\n                placeholder=\"e.g., Entrance Gateway\"\n            )\n            \n            wifi_ssid = st.text_input(\n                \"WiFi SSID\",\n                placeholder=\"Network name the gateway connects to\"\n            )\n        \n        with col2:\n            mqtt_topic = st.text_input(\n                \"MQTT Topic\",\n                placeholder=\"ble/gateway/entrance\",\n                help=\"Custom MQTT topic for this gateway\"\n            )\n            \n            signal_calibration = st.number_input(\n                \"Signal Calibration (dBm)\",\n                value=-59,\n                min_value=-100,\n                max_value=0,\n                help=\"RSSI at 1 meter distance\"\n            )\n            \n            path_loss = st.number_input(\n                \"Path Loss Exponent\",\n                value=2.0,\n                min_value=1.0,\n                max_value=6.0,\n                help=\"2.0 for free space, 2.5-4 for indoor\"\n            )\n        \n        st.markdown(\"#### Gateway Position\")\n        \n        position_method = st.radio(\n            \"Position Method\",\n            [\"Select Room\", \"Enter Coordinates Manually\"],\n            horizontal=True,\n            help=\"Choose how to specify the gateway position\"\n        )\n        \n        latitude = 0.0\n        longitude = 0.0\n        x_position = 0.0\n        y_position = 0.0\n        \n        if position_method == \"Select Room\" and rooms:\n            room_options = [\"-- Select a room --\"] + [r['name'] for r in rooms]\n            selected_room = st.selectbox(\"Select Room*\", options=room_options)\n            \n            if selected_room != \"-- Select a room --\":\n                room_data = next((r for r in rooms if r['name'] == selected_room), None)\n                if room_data:\n                    latitude = room_data['center_lat']\n                    longitude = room_data['center_lon']\n                    \n                    if selected_floor.origin_lat and selected_floor.origin_lon:\n                        import math\n                        lat_diff = latitude - selected_floor.origin_lat\n                        lon_diff = longitude - selected_floor.origin_lon\n                        y_position = lat_diff * 111000\n                        x_position = lon_diff * 111000 * abs(math.cos(math.radians(latitude)))\n                    \n                    st.info(f\"Room center: {latitude:.6f}, {longitude:.6f}\")\n        \n        elif position_method == \"Select Room\" and not rooms:\n            st.warning(\"No rooms found in floor plan. Please enter coordinates manually.\")\n            position_method = \"Enter Coordinates Manually\"\n        \n        if position_method == \"Enter Coordinates Manually\":\n            col3, col4 = st.columns(2)\n            \n            with col3:\n                latitude = st.number_input(\n                    \"Latitude (GPS)*\",\n                    value=selected_floor.origin_lat if selected_floor and selected_floor.origin_lat else 0.0,\n                    format=\"%.6f\",\n                    min_value=-90.0,\n                    max_value=90.0\n                )\n                \n                x_position = st.number_input(\n                    \"X Position (meters)\",\n                    value=0.0,\n                    min_value=0.0,\n                    max_value=1000.0,\n                    help=\"Position from left edge of floor plan\"\n                )\n            \n            with col4:\n                longitude = st.number_input(\n                    \"Longitude (GPS)*\",\n                    value=selected_floor.origin_lon if selected_floor and selected_floor.origin_lon else 0.0,\n                    format=\"%.6f\",\n                    min_value=-180.0,\n                    max_value=180.0\n                )\n                \n                y_position = st.number_input(\n                    \"Y Position (meters)\",\n                    value=0.0,\n                    min_value=0.0,\n                    max_value=1000.0,\n                    help=\"Position from bottom edge of floor plan\"\n                )\n        \n        description = st.text_area(\n            \"Description\",\n            placeholder=\"Describe the gateway location...\"\n        )\n        \n        is_active = st.checkbox(\"Gateway is active\", value=True)\n        \n        if st.button(\"Add Gateway\", type=\"primary\"):\n            if not name:\n                st.error(\"Gateway name is required\")\n            elif not mac_address:\n                st.error(\"MAC address is required\")\n            elif not validate_mac_address(mac_address):\n                st.error(\"Invalid MAC address format. Use AA:BB:CC:DD:EE:FF\")\n            elif position_method == \"Select Room\" and (latitude == 0 and longitude == 0):\n                st.error(\"Please select a room for the gateway position\")\n            else:\n                existing = session.query(Gateway).filter(\n                    Gateway.mac_address == mac_address\n                ).first()\n                \n                if existing:\n                    st.error(\"A gateway with this MAC address already exists\")\n                else:\n                    gateway = Gateway(\n                        building_id=selected_building_id,\n                        floor_id=selected_floor_id,\n                        mac_address=mac_address,\n                        name=name,\n                        description=description,\n                        x_position=x_position,\n                        y_position=y_position,\n                        latitude=latitude if latitude != 0 else None,\n                        longitude=longitude if longitude != 0 else None,\n                        mqtt_topic=mqtt_topic or None,\n                        wifi_ssid=wifi_ssid or None,\n                        is_active=is_active,\n                        signal_strength_calibration=signal_calibration,\n                        path_loss_exponent=path_loss\n                    )\n                    session.add(gateway)\n                    session.commit()\n                    set_success_and_rerun(f\"Gateway '{name}' added successfully!\")\n        \n        st.markdown(\"---\")\n        st.subheader(\"Configured Gateways\")\n        \n        gateways = session.query(Gateway).order_by(Gateway.name).all()\n        \n        if gateways:\n            for gw in gateways:\n                floor = session.query(Floor).filter(Floor.id == gw.floor_id).first()\n                building = session.query(Building).filter(Building.id == gw.building_id).first()\n                \n                status_icon = \"ðŸŸ¢\" if gw.is_active else \"ðŸ”´\"\n                \n                with st.expander(f\"{status_icon} {gw.name} ({gw.mac_address})\", expanded=False):\n                    col1, col2, col3 = st.columns([2, 2, 1])\n                    \n                    with col1:\n                        st.write(f\"**Building:** {building.name if building else 'Unknown'}\")\n                        st.write(f\"**Floor:** {floor.name if floor else 'Unknown'}\")\n                        st.write(f\"**Position:** ({gw.x_position:.1f}m, {gw.y_position:.1f}m)\")\n                        if gw.latitude and gw.longitude:\n                            st.write(f\"**GPS:** {gw.latitude:.6f}, {gw.longitude:.6f}\")\n                        if gw.wifi_ssid:\n                            st.write(f\"**WiFi:** {gw.wifi_ssid}\")\n                    \n                    with col2:\n                        st.write(f\"**MQTT Topic:** {gw.mqtt_topic or 'Default'}\")\n                        st.write(f\"**Calibration:** {gw.signal_strength_calibration} dBm\")\n                        st.write(f\"**Path Loss:** {gw.path_loss_exponent}\")\n                        if gw.description:\n                            st.write(f\"**Description:** {gw.description}\")\n                    \n                    with col3:\n                        if st.button(\"Toggle Active\", key=f\"toggle_gw_{gw.id}\"):\n                            gw.is_active = not gw.is_active\n                            session.commit()\n                            st.rerun()\n                        \n                        if st.button(\"Delete\", key=f\"del_gw_{gw.id}\", type=\"secondary\"):\n                            gw_name = gw.name\n                            session.delete(gw)\n                            session.commit()\n                            set_success_and_rerun(f\"Gateway '{gw_name}' deleted\")\n        else:\n            st.info(\"No gateways configured yet. Add your first gateway above.\")\n","path":null,"size_bytes":16943,"size_tokens":null},"utils/dwg_parser.py":{"content":"import ezdxf\nfrom typing import Dict, List, Tuple, Optional, Any\nimport json\nimport math\nfrom io import BytesIO\nimport tempfile\nimport os\n\n\ndef apply_transform(entity_data: Dict[str, Any], transform: Dict[str, float]) -> Dict[str, Any]:\n    \"\"\"Apply transformation (offset, scale, rotation) to entity coordinates\"\"\"\n    if not entity_data or 'coordinates' not in entity_data:\n        return entity_data\n    \n    offset_x = transform.get('offset_x', 0)\n    offset_y = transform.get('offset_y', 0)\n    scale_x = transform.get('scale_x', 1.0)\n    scale_y = transform.get('scale_y', 1.0)\n    rotation = transform.get('rotation', 0)\n    \n    cos_r = math.cos(rotation)\n    sin_r = math.sin(rotation)\n    \n    transformed_coords = []\n    for coord in entity_data['coordinates']:\n        if isinstance(coord, (list, tuple)) and len(coord) >= 2:\n            x = coord[0] * scale_x\n            y = coord[1] * scale_y\n            rx = x * cos_r - y * sin_r + offset_x\n            ry = x * sin_r + y * cos_r + offset_y\n            transformed_coords.append([rx, ry])\n    \n    result = entity_data.copy()\n    result['coordinates'] = transformed_coords\n    \n    if 'center' in entity_data:\n        cx, cy = entity_data['center']\n        cx = cx * scale_x\n        cy = cy * scale_y\n        rx = cx * cos_r - cy * sin_r + offset_x\n        ry = cx * sin_r + cy * cos_r + offset_y\n        result['center'] = [rx, ry]\n    \n    return result\n\n\ndef parse_dxf_file(file_content: bytes) -> Dict[str, Any]:\n    \"\"\"\n    Parse a DXF file and extract floor plan geometry.\n    Expands BLOCK/INSERT references to capture nested geometry.\n    \n    Returns a dict with:\n    - entities: List of geometric entities (walls, rooms, etc.)\n    - bounds: Bounding box of the drawing\n    - layers: List of layer names\n    - units: Drawing units if specified\n    \"\"\"\n    with tempfile.NamedTemporaryFile(suffix='.dxf', delete=False) as tmp:\n        tmp.write(file_content)\n        tmp_path = tmp.name\n    \n    try:\n        doc = ezdxf.readfile(tmp_path)\n        msp = doc.modelspace()\n        \n        entities = []\n        all_x = []\n        all_y = []\n        layers = set()\n        \n        def process_entity(entity, transform_matrix=None):\n            \"\"\"Process an entity, optionally applying transformation\"\"\"\n            nonlocal entities, all_x, all_y, layers\n            \n            layers.add(entity.dxf.layer)\n            entity_data = extract_entity_geometry(entity)\n            if entity_data:\n                if transform_matrix is not None:\n                    entity_data = apply_transform(entity_data, transform_matrix)\n                entities.append(entity_data)\n                coords = entity_data.get('coordinates', [])\n                for coord in coords:\n                    if isinstance(coord, (list, tuple)) and len(coord) >= 2:\n                        all_x.append(coord[0])\n                        all_y.append(coord[1])\n        \n        def expand_insert(insert_entity):\n            \"\"\"Expand an INSERT (block reference) to its constituent entities\"\"\"\n            try:\n                block_name = insert_entity.dxf.name\n                if block_name in doc.blocks:\n                    block = doc.blocks[block_name]\n                    insert_point = insert_entity.dxf.insert\n                    scale_x = getattr(insert_entity.dxf, 'xscale', 1.0)\n                    scale_y = getattr(insert_entity.dxf, 'yscale', 1.0)\n                    rotation = getattr(insert_entity.dxf, 'rotation', 0.0)\n                    \n                    transform = {\n                        'offset_x': insert_point.x,\n                        'offset_y': insert_point.y,\n                        'scale_x': scale_x,\n                        'scale_y': scale_y,\n                        'rotation': math.radians(rotation)\n                    }\n                    \n                    for block_entity in block:\n                        if block_entity.dxftype() == 'INSERT':\n                            expand_insert(block_entity)\n                        else:\n                            process_entity(block_entity, transform)\n            except Exception as e:\n                pass\n        \n        for entity in msp:\n            if entity.dxftype() == 'INSERT':\n                expand_insert(entity)\n            else:\n                process_entity(entity)\n        \n        bounds = None\n        if all_x and all_y:\n            bounds = {\n                'min_x': min(all_x),\n                'max_x': max(all_x),\n                'min_y': min(all_y),\n                'max_y': max(all_y),\n                'width': max(all_x) - min(all_x),\n                'height': max(all_y) - min(all_y)\n            }\n        \n        units_code = doc.header.get('$INSUNITS', 0)\n        units_map = {\n            0: 'Unitless',\n            1: 'Inches',\n            2: 'Feet',\n            3: 'Miles',\n            4: 'Millimeters',\n            5: 'Centimeters',\n            6: 'Meters',\n            7: 'Kilometers'\n        }\n        units = units_map.get(units_code, 'Unknown')\n        \n        return {\n            'entities': entities,\n            'bounds': bounds,\n            'layers': list(layers),\n            'units': units,\n            'entity_count': len(entities)\n        }\n        \n    finally:\n        os.unlink(tmp_path)\n\n\ndef extract_entity_geometry(entity) -> Optional[Dict[str, Any]]:\n    \"\"\"Extract geometry from a DXF entity.\"\"\"\n    dxftype = entity.dxftype()\n    layer = entity.dxf.layer\n    \n    try:\n        if dxftype == 'LINE':\n            return {\n                'type': 'line',\n                'layer': layer,\n                'coordinates': [\n                    [entity.dxf.start.x, entity.dxf.start.y],\n                    [entity.dxf.end.x, entity.dxf.end.y]\n                ]\n            }\n        \n        elif dxftype == 'LWPOLYLINE':\n            coords = []\n            for point in entity.get_points('xy'):\n                coords.append([point[0], point[1]])\n            if entity.closed and coords:\n                coords.append(coords[0])\n            return {\n                'type': 'polyline',\n                'layer': layer,\n                'closed': entity.closed,\n                'coordinates': coords\n            }\n        \n        elif dxftype == 'POLYLINE':\n            coords = []\n            for vertex in entity.vertices:\n                coords.append([vertex.dxf.location.x, vertex.dxf.location.y])\n            if entity.is_closed and coords:\n                coords.append(coords[0])\n            return {\n                'type': 'polyline',\n                'layer': layer,\n                'closed': entity.is_closed,\n                'coordinates': coords\n            }\n        \n        elif dxftype == 'CIRCLE':\n            cx, cy = entity.dxf.center.x, entity.dxf.center.y\n            r = entity.dxf.radius\n            coords = []\n            for i in range(37):\n                angle = 2 * math.pi * i / 36\n                coords.append([cx + r * math.cos(angle), cy + r * math.sin(angle)])\n            return {\n                'type': 'circle',\n                'layer': layer,\n                'center': [cx, cy],\n                'radius': r,\n                'coordinates': coords\n            }\n        \n        elif dxftype == 'ARC':\n            cx, cy = entity.dxf.center.x, entity.dxf.center.y\n            r = entity.dxf.radius\n            start_angle = math.radians(entity.dxf.start_angle)\n            end_angle = math.radians(entity.dxf.end_angle)\n            if end_angle < start_angle:\n                end_angle += 2 * math.pi\n            coords = []\n            num_points = max(2, int((end_angle - start_angle) / (math.pi / 18)) + 1)\n            for i in range(num_points):\n                angle = start_angle + (end_angle - start_angle) * i / (num_points - 1)\n                coords.append([cx + r * math.cos(angle), cy + r * math.sin(angle)])\n            return {\n                'type': 'arc',\n                'layer': layer,\n                'center': [cx, cy],\n                'radius': r,\n                'coordinates': coords\n            }\n        \n        elif dxftype == 'ELLIPSE':\n            cx, cy = entity.dxf.center.x, entity.dxf.center.y\n            major_axis = entity.dxf.major_axis\n            ratio = entity.dxf.ratio\n            a = math.sqrt(major_axis.x**2 + major_axis.y**2)\n            b = a * ratio\n            rotation = math.atan2(major_axis.y, major_axis.x)\n            coords = []\n            for i in range(37):\n                angle = 2 * math.pi * i / 36\n                x = a * math.cos(angle)\n                y = b * math.sin(angle)\n                rx = x * math.cos(rotation) - y * math.sin(rotation) + cx\n                ry = x * math.sin(rotation) + y * math.cos(rotation) + cy\n                coords.append([rx, ry])\n            return {\n                'type': 'ellipse',\n                'layer': layer,\n                'center': [cx, cy],\n                'coordinates': coords\n            }\n        \n        elif dxftype == 'SPLINE':\n            coords = []\n            try:\n                for point in entity.control_points:\n                    coords.append([point.x, point.y])\n            except:\n                pass\n            if coords:\n                return {\n                    'type': 'spline',\n                    'layer': layer,\n                    'coordinates': coords\n                }\n        \n        elif dxftype == 'TEXT' or dxftype == 'MTEXT':\n            try:\n                if dxftype == 'TEXT':\n                    insert = entity.dxf.insert\n                    text = entity.dxf.text\n                else:\n                    insert = entity.dxf.insert\n                    text = entity.text\n                return {\n                    'type': 'text',\n                    'layer': layer,\n                    'text': text,\n                    'coordinates': [[insert.x, insert.y]]\n                }\n            except:\n                pass\n        \n        elif dxftype == 'HATCH':\n            coords = []\n            try:\n                for path in entity.paths:\n                    path_coords = []\n                    if hasattr(path, 'vertices'):\n                        for vertex in path.vertices:\n                            path_coords.append([vertex.x, vertex.y])\n                    if path_coords:\n                        coords.extend(path_coords)\n            except:\n                pass\n            if coords:\n                return {\n                    'type': 'hatch',\n                    'layer': layer,\n                    'coordinates': coords\n                }\n        \n        elif dxftype == 'INSERT':\n            try:\n                insert = entity.dxf.insert\n                return {\n                    'type': 'block_insert',\n                    'layer': layer,\n                    'block_name': entity.dxf.name,\n                    'coordinates': [[insert.x, insert.y]]\n                }\n            except:\n                pass\n        \n    except Exception as e:\n        pass\n    \n    return None\n\n\ndef dxf_to_geojson(dxf_data: Dict[str, Any], \n                   scale: float = 1.0,\n                   origin_x: float = 0,\n                   origin_y: float = 0,\n                   wall_layers: Optional[List[str]] = None,\n                   room_layers: Optional[List[str]] = None) -> str:\n    \"\"\"\n    Convert parsed DXF data to GeoJSON format for floor plan display.\n    \n    Args:\n        dxf_data: Parsed DXF data from parse_dxf_file()\n        scale: Scale factor to convert DXF units to meters\n        origin_x: X coordinate offset\n        origin_y: Y coordinate offset\n        wall_layers: Layer names to treat as walls (e.g., ['WALLS', 'A-WALL'])\n        room_layers: Layer names to treat as rooms (e.g., ['ROOMS', 'A-AREA'])\n    \n    Returns:\n        GeoJSON string\n    \"\"\"\n    if wall_layers is None:\n        wall_layers = ['WALL', 'WALLS', 'A-WALL', 'S-WALL', 'PARTITION']\n    if room_layers is None:\n        room_layers = ['ROOM', 'ROOMS', 'A-AREA', 'A-ROOM', 'SPACE', 'ZONE']\n    \n    wall_layers_lower = [l.lower() for l in wall_layers]\n    room_layers_lower = [l.lower() for l in room_layers]\n    \n    features = []\n    \n    for entity in dxf_data.get('entities', []):\n        layer = entity.get('layer', '').lower()\n        coords = entity.get('coordinates', [])\n        entity_type = entity.get('type', '')\n        \n        if not coords:\n            continue\n        \n        scaled_coords = []\n        for coord in coords:\n            if isinstance(coord, (list, tuple)) and len(coord) >= 2:\n                scaled_coords.append([\n                    (coord[0] - origin_x) * scale,\n                    (coord[1] - origin_y) * scale\n                ])\n        \n        if not scaled_coords:\n            continue\n        \n        geom_type = 'wall'\n        is_room = False\n        \n        for room_layer in room_layers_lower:\n            if room_layer in layer:\n                geom_type = 'room'\n                is_room = True\n                break\n        \n        if not is_room:\n            for wall_layer in wall_layers_lower:\n                if wall_layer in layer:\n                    geom_type = 'wall'\n                    break\n        \n        if is_room or entity.get('closed', False):\n            if len(scaled_coords) >= 3:\n                if scaled_coords[0] != scaled_coords[-1]:\n                    scaled_coords.append(scaled_coords[0])\n                feature = {\n                    'type': 'Feature',\n                    'properties': {\n                        'name': entity.get('layer', 'Unknown'),\n                        'geomType': geom_type,\n                        'layer': entity.get('layer', ''),\n                        'entityType': entity_type\n                    },\n                    'geometry': {\n                        'type': 'Polygon',\n                        'coordinates': [scaled_coords]\n                    }\n                }\n                features.append(feature)\n        else:\n            feature = {\n                'type': 'Feature',\n                'properties': {\n                    'name': entity.get('layer', 'Unknown'),\n                    'geomType': geom_type,\n                    'subType': 'inner',\n                    'layer': entity.get('layer', ''),\n                    'entityType': entity_type\n                },\n                'geometry': {\n                    'type': 'LineString',\n                    'coordinates': scaled_coords\n                }\n            }\n            features.append(feature)\n    \n    geojson = {\n        'type': 'FeatureCollection',\n        'features': features,\n        'properties': {\n            'units': dxf_data.get('units', 'Unknown'),\n            'bounds': dxf_data.get('bounds'),\n            'layers': dxf_data.get('layers', [])\n        }\n    }\n    \n    return json.dumps(geojson)\n\n\ndef get_dxf_dimensions(dxf_data: Dict[str, Any], scale: float = 1.0) -> Tuple[float, float]:\n    \"\"\"Get the width and height of the DXF drawing in meters.\"\"\"\n    bounds = dxf_data.get('bounds')\n    if bounds:\n        width = bounds['width'] * scale\n        height = bounds['height'] * scale\n        return max(1.0, width), max(1.0, height)\n    return 100.0, 100.0\n\n\ndef detect_dxf_scale(dxf_data: Dict[str, Any]) -> float:\n    \"\"\"\n    Attempt to detect the appropriate scale factor based on drawing units.\n    Returns scale factor to convert to meters.\n    Always returns at least 1.0 to avoid zero scaling.\n    \"\"\"\n    units = dxf_data.get('units', 'Unknown')\n    \n    scale_factors = {\n        'Millimeters': 0.001,\n        'Centimeters': 0.01,\n        'Meters': 1.0,\n        'Inches': 0.0254,\n        'Feet': 0.3048,\n        'Kilometers': 1000.0,\n        'Miles': 1609.34,\n        'Unitless': 1.0,\n        'Unknown': 1.0\n    }\n    \n    scale = scale_factors.get(units, 1.0)\n    return scale if scale > 0 else 1.0\n","path":null,"size_bytes":15835,"size_tokens":null},"views/coverage_zones.py":{"content":"import streamlit as st\nimport json\nimport plotly.graph_objects as go\nfrom PIL import Image\nfrom io import BytesIO\nimport base64\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom database import get_db_session, Floor, Building, CoverageZone, Zone, ZoneAlert, Beacon, Position, Gateway\nfrom utils.mqtt_publisher import get_mqtt_publisher\n\n\ndef latlon_to_meters(lat, lon, origin_lat, origin_lon):\n    \"\"\"Convert lat/lon to meters relative to origin\"\"\"\n    import math\n    lat_diff = lat - origin_lat\n    lon_diff = lon - origin_lon\n    y = lat_diff * 111320\n    x = lon_diff * 111320 * math.cos(math.radians(origin_lat))\n    return x, y\n\n\ndef extract_building_footprint(floor):\n    \"\"\"Extract building footprint polygon from floor plan GeoJSON\"\"\"\n    if not floor.floor_plan_geojson:\n        return None\n    \n    try:\n        geojson_data = json.loads(floor.floor_plan_geojson)\n        \n        for feature in geojson_data.get('features', []):\n            props = feature.get('properties', {})\n            geom = feature.get('geometry', {})\n            geom_type = props.get('geomType', '')\n            \n            if geom_type == 'building':\n                geometry_type = geom.get('type', '')\n                \n                if geometry_type == 'Polygon':\n                    coords = geom.get('coordinates', [[]])[0]\n                    if coords and floor.origin_lat and floor.origin_lon:\n                        converted = []\n                        for c in coords:\n                            if len(c) >= 2:\n                                x, y = latlon_to_meters(c[1], c[0], floor.origin_lat, floor.origin_lon)\n                                converted.append([x, y])\n                        return converted\n                    return coords\n                \n                elif geometry_type == 'MultiPolygon':\n                    all_coords = []\n                    for polygon in geom.get('coordinates', []):\n                        if polygon and polygon[0]:\n                            ring = polygon[0]\n                            if floor.origin_lat and floor.origin_lon:\n                                for c in ring:\n                                    if len(c) >= 2:\n                                        x, y = latlon_to_meters(c[1], c[0], floor.origin_lat, floor.origin_lon)\n                                        all_coords.append([x, y])\n                            else:\n                                all_coords.extend(ring)\n                    \n                    if all_coords:\n                        xs = [c[0] for c in all_coords]\n                        ys = [c[1] for c in all_coords]\n                        min_x, max_x = min(xs), max(xs)\n                        min_y, max_y = min(ys), max(ys)\n                        return [\n                            [min_x, min_y],\n                            [max_x, min_y],\n                            [max_x, max_y],\n                            [min_x, max_y],\n                            [min_x, min_y]\n                        ]\n        \n        return None\n    except Exception:\n        return None\n\n\ndef render_floor_plan(fig, floor):\n    \"\"\"Render floor plan on figure\"\"\"\n    if floor.floor_plan_image:\n        try:\n            image = Image.open(BytesIO(floor.floor_plan_image))\n            buffered = BytesIO()\n            image.save(buffered, format=\"PNG\")\n            img_str = base64.b64encode(buffered.getvalue()).decode()\n            \n            fig.add_layout_image(\n                dict(\n                    source=f\"data:image/png;base64,{img_str}\",\n                    xref=\"x\",\n                    yref=\"y\",\n                    x=0,\n                    y=floor.height_meters,\n                    sizex=floor.width_meters,\n                    sizey=floor.height_meters,\n                    sizing=\"stretch\",\n                    opacity=0.9,\n                    layer=\"below\"\n                )\n            )\n            return True\n        except Exception:\n            pass\n    \n    if floor.floor_plan_geojson:\n        try:\n            geojson_data = json.loads(floor.floor_plan_geojson)\n            rendered = False\n            \n            for feature in geojson_data.get('features', []):\n                props = feature.get('properties', {})\n                geom = feature.get('geometry', {})\n                geometry_type = geom.get('type', '')\n                geom_type = props.get('geomType', '')\n                \n                if geometry_type in ['Polygon', 'MultiPolygon']:\n                    if geometry_type == 'Polygon':\n                        rings = [geom.get('coordinates', [[]])[0]]\n                    else:\n                        rings = [poly[0] for poly in geom.get('coordinates', []) if poly]\n                    \n                    for ring in rings:\n                        xs = []\n                        ys = []\n                        for c in ring:\n                            if len(c) >= 2:\n                                if floor.origin_lat and floor.origin_lon:\n                                    x, y = latlon_to_meters(c[1], c[0], floor.origin_lat, floor.origin_lon)\n                                else:\n                                    x, y = c[0], c[1]\n                                xs.append(x)\n                                ys.append(y)\n                        \n                        if xs:\n                            fill_color = 'rgba(46, 92, 191, 0.1)' if geom_type == 'room' else 'rgba(200, 200, 200, 0.1)'\n                            line_color = '#2e5cbf' if geom_type == 'room' else '#444'\n                            \n                            fig.add_trace(go.Scatter(\n                                x=xs, y=ys,\n                                fill='toself',\n                                fillcolor=fill_color,\n                                line=dict(color=line_color, width=1),\n                                mode='lines',\n                                showlegend=False,\n                                hoverinfo='skip'\n                            ))\n                            rendered = True\n                \n                elif geometry_type == 'LineString':\n                    coords = geom.get('coordinates', [])\n                    xs = []\n                    ys = []\n                    for c in coords:\n                        if len(c) >= 2:\n                            if floor.origin_lat and floor.origin_lon:\n                                x, y = latlon_to_meters(c[1], c[0], floor.origin_lat, floor.origin_lon)\n                            else:\n                                x, y = c[0], c[1]\n                            xs.append(x)\n                            ys.append(y)\n                    \n                    if xs:\n                        fig.add_trace(go.Scatter(\n                            x=xs, y=ys,\n                            mode='lines',\n                            line=dict(color='#333', width=1),\n                            showlegend=False,\n                            hoverinfo='skip'\n                        ))\n                        rendered = True\n            \n            return rendered\n        except Exception:\n            pass\n    \n    return False\n\n\ndef render_coverage_zones(fig, zones):\n    \"\"\"Render coverage zones on figure\"\"\"\n    for zone in zones:\n        try:\n            coords = json.loads(zone.polygon_coords)\n            if coords:\n                xs = [c[0] for c in coords]\n                ys = [c[1] for c in coords]\n                \n                if xs[0] != xs[-1] or ys[0] != ys[-1]:\n                    xs.append(xs[0])\n                    ys.append(ys[0])\n                \n                color = zone.color or '#2e5cbf'\n                r, g, b = int(color[1:3], 16), int(color[3:5], 16), int(color[5:7], 16)\n                \n                fig.add_trace(go.Scatter(\n                    x=xs, y=ys,\n                    fill='toself',\n                    fillcolor=f'rgba({r}, {g}, {b}, 0.2)',\n                    line=dict(color=color, width=2),\n                    mode='lines',\n                    name=zone.name,\n                    hovertemplate=f\"<b>{zone.name}</b><br>Accuracy: Â±{zone.target_accuracy}m<extra></extra>\"\n                ))\n                \n                center_x = sum(xs[:-1]) / len(xs[:-1])\n                center_y = sum(ys[:-1]) / len(ys[:-1])\n                fig.add_annotation(\n                    x=center_x, y=center_y,\n                    text=f\"{zone.name}<br>Â±{zone.target_accuracy}m\",\n                    showarrow=False,\n                    font=dict(size=10, color=color),\n                    bgcolor='rgba(255,255,255,0.8)'\n                )\n        except Exception:\n            pass\n\n\ndef point_in_zone(x, y, zone):\n    \"\"\"Check if a point is inside a zone rectangle\"\"\"\n    return zone.x_min <= x <= zone.x_max and zone.y_min <= y <= zone.y_max\n\n\ndef check_zone_transitions(session, floor_id):\n    \"\"\"Check for beacon zone entry/exit events\"\"\"\n    zones = session.query(Zone).filter(\n        Zone.floor_id == floor_id,\n        Zone.is_active == True\n    ).all()\n    \n    if not zones:\n        return []\n    \n    alerts = []\n    thirty_seconds_ago = datetime.utcnow() - timedelta(seconds=30)\n    \n    beacons = session.query(Beacon).filter(Beacon.is_active == True).all()\n    \n    for beacon in beacons:\n        positions = session.query(Position).filter(\n            Position.beacon_id == beacon.id,\n            Position.floor_id == floor_id,\n            Position.timestamp >= thirty_seconds_ago\n        ).order_by(Position.timestamp.desc()).limit(2).all()\n        \n        if len(positions) < 2:\n            continue\n        \n        current_pos = positions[0]\n        prev_pos = positions[1]\n        \n        for zone in zones:\n            was_in_zone = point_in_zone(prev_pos.x_position, prev_pos.y_position, zone)\n            is_in_zone = point_in_zone(current_pos.x_position, current_pos.y_position, zone)\n            \n            if not was_in_zone and is_in_zone and zone.alert_on_enter:\n                existing = session.query(ZoneAlert).filter(\n                    ZoneAlert.zone_id == zone.id,\n                    ZoneAlert.beacon_id == beacon.id,\n                    ZoneAlert.alert_type == 'enter',\n                    ZoneAlert.timestamp >= thirty_seconds_ago\n                ).first()\n                \n                if not existing:\n                    alert = ZoneAlert(\n                        zone_id=zone.id,\n                        beacon_id=beacon.id,\n                        alert_type='enter',\n                        x_position=current_pos.x_position,\n                        y_position=current_pos.y_position,\n                        timestamp=datetime.utcnow()\n                    )\n                    session.add(alert)\n                    session.commit()\n                    alerts.append({\n                        'type': 'enter',\n                        'zone': zone.name,\n                        'beacon': beacon.name,\n                        'time': datetime.utcnow()\n                    })\n                    \n                    publisher = get_mqtt_publisher()\n                    if publisher.is_connected():\n                        floor = session.query(Floor).filter(Floor.id == zone.floor_id).first()\n                        floor_name = floor.name if floor else \"\"\n                        publisher.publish_alert(\n                            alert_type='enter',\n                            beacon_mac=beacon.mac_address,\n                            beacon_name=beacon.name,\n                            zone_id=zone.id,\n                            zone_name=zone.name,\n                            floor_name=floor_name,\n                            x=current_pos.x_position,\n                            y=current_pos.y_position,\n                            resource_type=beacon.resource_type\n                        )\n            \n            elif was_in_zone and not is_in_zone and zone.alert_on_exit:\n                existing = session.query(ZoneAlert).filter(\n                    ZoneAlert.zone_id == zone.id,\n                    ZoneAlert.beacon_id == beacon.id,\n                    ZoneAlert.alert_type == 'exit',\n                    ZoneAlert.timestamp >= thirty_seconds_ago\n                ).first()\n                \n                if not existing:\n                    alert = ZoneAlert(\n                        zone_id=zone.id,\n                        beacon_id=beacon.id,\n                        alert_type='exit',\n                        x_position=current_pos.x_position,\n                        y_position=current_pos.y_position,\n                        timestamp=datetime.utcnow()\n                    )\n                    session.add(alert)\n                    session.commit()\n                    alerts.append({\n                        'type': 'exit',\n                        'zone': zone.name,\n                        'beacon': beacon.name,\n                        'time': datetime.utcnow()\n                    })\n                    \n                    publisher = get_mqtt_publisher()\n                    if publisher.is_connected():\n                        floor = session.query(Floor).filter(Floor.id == zone.floor_id).first()\n                        floor_name = floor.name if floor else \"\"\n                        publisher.publish_alert(\n                            alert_type='exit',\n                            beacon_mac=beacon.mac_address,\n                            beacon_name=beacon.name,\n                            zone_id=zone.id,\n                            zone_name=zone.name,\n                            floor_name=floor_name,\n                            x=current_pos.x_position,\n                            y=current_pos.y_position,\n                            resource_type=beacon.resource_type\n                        )\n    \n    return alerts\n\n\ndef show():\n    st.title(\"Coverage Zones & Alerts\")\n    st.write(\"Define coverage areas and manage geofencing alerts for beacon tracking.\")\n    \n    tab1, tab2, tab3 = st.tabs([\"Coverage Zones\", \"Live Monitoring\", \"Alert History\"])\n    \n    with tab1:\n        render_coverage_zones_tab()\n    \n    with tab2:\n        render_live_monitoring_tab()\n    \n    with tab3:\n        render_alert_history_tab()\n\n\ndef render_coverage_zones_tab():\n    \"\"\"Render the coverage zones management tab\"\"\"\n    if 'drawing_vertices' not in st.session_state:\n        st.session_state.drawing_vertices = []\n    if 'drawing_mode' not in st.session_state:\n        st.session_state.drawing_mode = False\n    if 'viewport_bounds' not in st.session_state:\n        st.session_state.viewport_bounds = None\n    \n    with get_db_session() as session:\n        buildings = session.query(Building).order_by(Building.name).all()\n        \n        if not buildings:\n            st.warning(\"No buildings found. Please add a building first.\")\n            return\n        \n        building_options = {b.name: b.id for b in buildings}\n        \n        col1, col2 = st.columns([1, 2])\n        \n        with col1:\n            st.subheader(\"Select Floor\")\n            \n            selected_building = st.selectbox(\n                \"Building\",\n                options=list(building_options.keys()),\n                key=\"cz_building\"\n            )\n            \n            if selected_building:\n                floors = session.query(Floor).filter(\n                    Floor.building_id == building_options[selected_building]\n                ).order_by(Floor.floor_number).all()\n                \n                if floors:\n                    floor_options = {f\"{f.name} (Level {f.floor_number})\": f.id for f in floors}\n                    selected_floor_name = st.selectbox(\n                        \"Floor\",\n                        options=list(floor_options.keys()),\n                        key=\"cz_floor\"\n                    )\n                    selected_floor_id = floor_options.get(selected_floor_name)\n                    selected_floor = session.query(Floor).get(selected_floor_id) if selected_floor_id else None\n                else:\n                    st.warning(\"No floors found for this building.\")\n                    selected_floor = None\n            else:\n                selected_floor = None\n            \n            st.divider()\n            \n            if selected_floor:\n                st.subheader(\"Coverage Zones\")\n                \n                zones = session.query(CoverageZone).filter(\n                    CoverageZone.floor_id == selected_floor.id\n                ).order_by(CoverageZone.priority.desc()).all()\n                \n                if zones:\n                    for zone in zones:\n                        with st.expander(f\"ðŸ”· {zone.name} (Â±{zone.target_accuracy}m)\", expanded=False):\n                            st.write(f\"**Priority:** {zone.priority}\")\n                            st.write(f\"**Active:** {'Yes' if zone.is_active else 'No'}\")\n                            if zone.description:\n                                st.write(f\"**Description:** {zone.description}\")\n                            \n                            col_edit, col_del = st.columns(2)\n                            with col_edit:\n                                if st.button(\"Edit\", key=f\"edit_zone_{zone.id}\"):\n                                    st.session_state['editing_zone_id'] = zone.id\n                                    st.rerun()\n                            with col_del:\n                                if st.button(\"Delete\", key=f\"del_zone_{zone.id}\", type=\"secondary\"):\n                                    session.delete(zone)\n                                    session.commit()\n                                    st.success(f\"Deleted zone '{zone.name}'\")\n                                    st.rerun()\n                else:\n                    st.info(\"No coverage zones defined yet.\")\n                \n                st.divider()\n                \n                st.subheader(\"Add Zone\")\n                \n                zone_creation_method = st.radio(\n                    \"How do you want to define the zone area?\",\n                    [\"Draw Custom Shape\", \"Enter Rectangle Bounds\", \"Cover Entire Floor\"],\n                    horizontal=False,\n                    help=\"Draw: enter vertex coordinates | Rectangle: enter X/Y min/max | Entire: full floor coverage\",\n                    key=\"zone_creation_method\"\n                )\n                \n                prev_method = st.session_state.get('prev_creation_method')\n                if prev_method and prev_method != zone_creation_method:\n                    st.session_state.drawing_vertices = []\n                    st.session_state['pending_polygon'] = None\n                    st.session_state['use_viewport'] = False\n                    st.session_state['viewport_bounds'] = None\n                st.session_state['prev_creation_method'] = zone_creation_method\n                \n                if zone_creation_method == \"Draw Custom Shape\":\n                    st.info(\"ðŸ“ **Add points** using coordinates from the floor plan. Hover over the chart to see X/Y values, then enter them below.\")\n                    \n                    if st.session_state.drawing_vertices:\n                        st.write(f\"**Vertices placed:** {len(st.session_state.drawing_vertices)}\")\n                        vertices_to_delete = []\n                        for i, v in enumerate(st.session_state.drawing_vertices):\n                            col_pt, col_del = st.columns([4, 1])\n                            with col_pt:\n                                st.caption(f\"Point {i+1}: ({v[0]:.1f}, {v[1]:.1f}) m\")\n                            with col_del:\n                                if st.button(\"âŒ\", key=f\"del_pt_{i}\", help=\"Remove this point\"):\n                                    vertices_to_delete.append(i)\n                        for idx in reversed(vertices_to_delete):\n                            st.session_state.drawing_vertices.pop(idx)\n                        if vertices_to_delete:\n                            st.rerun()\n                    \n                    with st.form(key=\"add_vertex_form\", clear_on_submit=True):\n                        st.markdown(\"**Add vertex:**\")\n                        col_x, col_y = st.columns(2)\n                        with col_x:\n                            new_x = st.number_input(\"X (m)\", min_value=0.0, max_value=float(selected_floor.width_meters) if selected_floor else 100.0, value=0.0, step=0.5, key=\"form_vertex_x\")\n                        with col_y:\n                            new_y = st.number_input(\"Y (m)\", min_value=0.0, max_value=float(selected_floor.height_meters) if selected_floor else 100.0, value=0.0, step=0.5, key=\"form_vertex_y\")\n                        \n                        add_submitted = st.form_submit_button(\"Add Point\", type=\"primary\")\n                        if add_submitted:\n                            is_duplicate = any(\n                                abs(v[0] - new_x) < 0.5 and abs(v[1] - new_y) < 0.5\n                                for v in st.session_state.drawing_vertices\n                            )\n                            if not is_duplicate and (new_x > 0 or new_y > 0):\n                                st.session_state.drawing_vertices.append([round(new_x, 2), round(new_y, 2)])\n                    \n                    col_draw1, col_draw2, col_draw3 = st.columns(3)\n                    with col_draw1:\n                        if st.button(\"Undo Last\", disabled=len(st.session_state.drawing_vertices) == 0):\n                            st.session_state.drawing_vertices.pop()\n                    with col_draw2:\n                        if st.button(\"Clear All\", disabled=len(st.session_state.drawing_vertices) == 0):\n                            st.session_state.drawing_vertices = []\n                    with col_draw3:\n                        can_complete = len(st.session_state.drawing_vertices) >= 3\n                        complete_btn = st.button(\"Complete Polygon\", type=\"primary\", disabled=not can_complete)\n                    \n                    if can_complete and complete_btn:\n                        st.session_state['pending_polygon'] = st.session_state.drawing_vertices.copy()\n                        st.session_state.drawing_vertices = []\n                \n                elif zone_creation_method == \"Enter Rectangle Bounds\":\n                    st.info(\"ðŸ“ Enter the corner coordinates to define a rectangular zone.\")\n                    \n                    col_vp1, col_vp2 = st.columns(2)\n                    with col_vp1:\n                        vp_x_min = st.number_input(\"X Min (m)\", min_value=0.0, max_value=float(selected_floor.width_meters), value=0.0, key=\"vp_x_min\")\n                        vp_y_min = st.number_input(\"Y Min (m)\", min_value=0.0, max_value=float(selected_floor.height_meters), value=0.0, key=\"vp_y_min\")\n                    with col_vp2:\n                        vp_x_max = st.number_input(\"X Max (m)\", min_value=0.0, max_value=float(selected_floor.width_meters), value=float(selected_floor.width_meters), key=\"vp_x_max\")\n                        vp_y_max = st.number_input(\"Y Max (m)\", min_value=0.0, max_value=float(selected_floor.height_meters), value=float(selected_floor.height_meters), key=\"vp_y_max\")\n                    \n                    if st.button(\"Set Rectangle Bounds\", type=\"primary\"):\n                        if vp_x_max > vp_x_min and vp_y_max > vp_y_min:\n                            st.session_state['use_viewport'] = True\n                            st.session_state['viewport_bounds'] = {\n                                'x_min': vp_x_min,\n                                'x_max': vp_x_max,\n                                'y_min': vp_y_min,\n                                'y_max': vp_y_max\n                            }\n                            st.rerun()\n                        else:\n                            st.error(\"Max values must be greater than min values.\")\n                \n                zone_name = st.text_input(\"Zone Name*\", placeholder=\"e.g., Main Area, Operating Room\")\n                zone_description = st.text_area(\"Description\", placeholder=\"Optional description\", height=68)\n                \n                col_acc, col_pri = st.columns(2)\n                with col_acc:\n                    target_accuracy = st.select_slider(\n                        \"Target Accuracy\",\n                        options=[0.5, 1.0, 2.0, 3.0, 5.0],\n                        value=1.0,\n                        format_func=lambda x: f\"Â±{x}m\"\n                    )\n                with col_pri:\n                    priority = st.number_input(\"Priority\", min_value=1, max_value=10, value=1, help=\"Higher priority zones take precedence\")\n                \n                zone_color = st.color_picker(\"Zone Color\", value=\"#2e5cbf\")\n                \n                pending_polygon = st.session_state.get('pending_polygon')\n                use_viewport = st.session_state.get('use_viewport')\n                viewport_bounds = st.session_state.get('viewport_bounds')\n                \n                if zone_creation_method == \"Cover Entire Floor\":\n                    if st.button(\"Create Zone\", type=\"primary\"):\n                        if not zone_name:\n                            st.error(\"Please enter a zone name\")\n                        else:\n                            polygon_coords = json.dumps([\n                                [0, 0],\n                                [selected_floor.width_meters, 0],\n                                [selected_floor.width_meters, selected_floor.height_meters],\n                                [0, selected_floor.height_meters],\n                                [0, 0]\n                            ])\n                            \n                            new_zone = CoverageZone(\n                                floor_id=selected_floor.id,\n                                name=zone_name,\n                                description=zone_description,\n                                polygon_coords=polygon_coords,\n                                target_accuracy=target_accuracy,\n                                priority=priority,\n                                color=zone_color,\n                                is_active=True\n                            )\n                            session.add(new_zone)\n                            session.commit()\n                            st.success(f\"Created zone '{zone_name}'\")\n                            st.rerun()\n                \n                elif pending_polygon:\n                    st.success(f\"Polygon ready with {len(pending_polygon)} vertices!\")\n                    if st.button(\"Save Zone\", type=\"primary\"):\n                        if not zone_name:\n                            st.error(\"Please enter a zone name\")\n                        else:\n                            closed_polygon = pending_polygon.copy()\n                            if closed_polygon[0] != closed_polygon[-1]:\n                                closed_polygon.append(closed_polygon[0])\n                            polygon_coords = json.dumps(closed_polygon)\n                            new_zone = CoverageZone(\n                                floor_id=selected_floor.id,\n                                name=zone_name,\n                                description=zone_description,\n                                polygon_coords=polygon_coords,\n                                target_accuracy=target_accuracy,\n                                priority=priority,\n                                color=zone_color,\n                                is_active=True,\n                                alert_on_enter=alert_on_enter,\n                                alert_on_exit=alert_on_exit\n                            )\n                            session.add(new_zone)\n                            session.commit()\n                            st.session_state['pending_polygon'] = None\n                            st.success(f\"Created zone '{zone_name}'\")\n                            st.rerun()\n                \n                elif use_viewport and viewport_bounds:\n                    x_min, x_max = viewport_bounds.get('x_min', 0), viewport_bounds.get('x_max', selected_floor.width_meters)\n                    y_min, y_max = viewport_bounds.get('y_min', 0), viewport_bounds.get('y_max', selected_floor.height_meters)\n                    st.success(f\"Rectangle bounds set: ({x_min:.1f}, {y_min:.1f}) to ({x_max:.1f}, {y_max:.1f})\")\n                    if st.button(\"Save Zone\", type=\"primary\"):\n                        if not zone_name:\n                            st.error(\"Please enter a zone name\")\n                        else:\n                            polygon_coords = json.dumps([\n                                [x_min, y_min],\n                                [x_max, y_min],\n                                [x_max, y_max],\n                                [x_min, y_max],\n                                [x_min, y_min]\n                            ])\n                            new_zone = CoverageZone(\n                                floor_id=selected_floor.id,\n                                name=zone_name,\n                                description=zone_description,\n                                polygon_coords=polygon_coords,\n                                target_accuracy=target_accuracy,\n                                priority=priority,\n                                color=zone_color,\n                                is_active=True,\n                                alert_on_enter=alert_on_enter,\n                                alert_on_exit=alert_on_exit\n                            )\n                            session.add(new_zone)\n                            session.commit()\n                            st.session_state['use_viewport'] = False\n                            st.session_state['viewport_bounds'] = None\n                            st.success(f\"Created zone '{zone_name}'\")\n                            st.rerun()\n        \n        with col2:\n            st.subheader(\"Floor Plan Preview\")\n            \n            if selected_floor:\n                current_mode = st.session_state.get('zone_creation_method', 'Draw Custom Shape')\n                \n                zones = session.query(CoverageZone).filter(\n                    CoverageZone.floor_id == selected_floor.id,\n                    CoverageZone.is_active == True\n                ).all()\n                \n                # Load focus area from database if available\n                if selected_floor.focus_min_x is not None:\n                    st.session_state['focus_area'] = {\n                        'x_min': selected_floor.focus_min_x,\n                        'x_max': selected_floor.focus_max_x,\n                        'y_min': selected_floor.focus_min_y,\n                        'y_max': selected_floor.focus_max_y\n                    }\n                    st.session_state['focus_x_min'] = selected_floor.focus_min_x\n                    st.session_state['focus_x_max'] = selected_floor.focus_max_x\n                    st.session_state['focus_y_min'] = selected_floor.focus_min_y\n                    st.session_state['focus_y_max'] = selected_floor.focus_max_y\n                elif 'focus_area' not in st.session_state:\n                    st.session_state['focus_area'] = None\n                \n                with st.expander(\"ðŸ” Focus Area (set view bounds)\", expanded=False):\n                    st.caption(\"Set specific view bounds to focus on a region. This will be saved for Gateway Planning.\")\n                    \n                    focus_col1, focus_col2 = st.columns(2)\n                    with focus_col1:\n                        focus_x_min = st.number_input(\"X Min\", min_value=0.0, max_value=float(selected_floor.width_meters), \n                                                       value=float(st.session_state.get('focus_x_min', 0.0)), step=1.0, key=\"focus_x_min_input\")\n                        focus_y_min = st.number_input(\"Y Min\", min_value=0.0, max_value=float(selected_floor.height_meters), \n                                                       value=float(st.session_state.get('focus_y_min', 0.0)), step=1.0, key=\"focus_y_min_input\")\n                    with focus_col2:\n                        focus_x_max = st.number_input(\"X Max\", min_value=0.0, max_value=float(selected_floor.width_meters), \n                                                       value=float(st.session_state.get('focus_x_max', selected_floor.width_meters)), step=1.0, key=\"focus_x_max_input\")\n                        focus_y_max = st.number_input(\"Y Max\", min_value=0.0, max_value=float(selected_floor.height_meters), \n                                                       value=float(st.session_state.get('focus_y_max', selected_floor.height_meters)), step=1.0, key=\"focus_y_max_input\")\n                    \n                    focus_btn_col1, focus_btn_col2, focus_btn_col3 = st.columns(3)\n                    with focus_btn_col1:\n                        if st.button(\"Save Focus Area\", type=\"primary\"):\n                            if focus_x_max > focus_x_min and focus_y_max > focus_y_min:\n                                selected_floor.focus_min_x = focus_x_min\n                                selected_floor.focus_max_x = focus_x_max\n                                selected_floor.focus_min_y = focus_y_min\n                                selected_floor.focus_max_y = focus_y_max\n                                session.commit()\n                                st.session_state['focus_area'] = {\n                                    'x_min': focus_x_min, 'x_max': focus_x_max,\n                                    'y_min': focus_y_min, 'y_max': focus_y_max\n                                }\n                                st.session_state['focus_x_min'] = focus_x_min\n                                st.session_state['focus_x_max'] = focus_x_max\n                                st.session_state['focus_y_min'] = focus_y_min\n                                st.session_state['focus_y_max'] = focus_y_max\n                                st.success(\"Focus area saved!\")\n                            else:\n                                st.error(\"Max must be greater than Min\")\n                    with focus_btn_col2:\n                        if st.button(\"Clear Focus\"):\n                            selected_floor.focus_min_x = None\n                            selected_floor.focus_max_x = None\n                            selected_floor.focus_min_y = None\n                            selected_floor.focus_max_y = None\n                            session.commit()\n                            st.session_state['focus_area'] = None\n                            st.session_state['focus_x_min'] = 0.0\n                            st.session_state['focus_x_max'] = selected_floor.width_meters\n                            st.session_state['focus_y_min'] = 0.0\n                            st.session_state['focus_y_max'] = selected_floor.height_meters\n                            st.success(\"Focus area cleared\")\n                            st.rerun()\n                    with focus_btn_col3:\n                        if zones and st.button(\"Focus on Zones\"):\n                            all_xs, all_ys = [], []\n                            for zone in zones:\n                                try:\n                                    coords = json.loads(zone.polygon_coords)\n                                    for c in coords:\n                                        all_xs.append(c[0])\n                                        all_ys.append(c[1])\n                                except:\n                                    pass\n                            if all_xs and all_ys:\n                                margin = 2.0\n                                focus_x_min = max(0, min(all_xs) - margin)\n                                focus_x_max = min(selected_floor.width_meters, max(all_xs) + margin)\n                                focus_y_min = max(0, min(all_ys) - margin)\n                                focus_y_max = min(selected_floor.height_meters, max(all_ys) + margin)\n                                selected_floor.focus_min_x = focus_x_min\n                                selected_floor.focus_max_x = focus_x_max\n                                selected_floor.focus_min_y = focus_y_min\n                                selected_floor.focus_max_y = focus_y_max\n                                session.commit()\n                                st.session_state['focus_area'] = {\n                                    'x_min': focus_x_min, 'x_max': focus_x_max,\n                                    'y_min': focus_y_min, 'y_max': focus_y_max\n                                }\n                                st.session_state['focus_x_min'] = focus_x_min\n                                st.session_state['focus_x_max'] = focus_x_max\n                                st.session_state['focus_y_min'] = focus_y_min\n                                st.session_state['focus_y_max'] = focus_y_max\n                                st.success(\"Focus area set to zones bounds\")\n                    \n                    if st.session_state.get('focus_area'):\n                        fa = st.session_state['focus_area']\n                        st.info(f\"Focused: X [{fa['x_min']:.1f} - {fa['x_max']:.1f}], Y [{fa['y_min']:.1f} - {fa['y_max']:.1f}]\")\n                \n                fig = go.Figure()\n                \n                has_floor_plan = render_floor_plan(fig, selected_floor)\n                \n                if not has_floor_plan:\n                    fig.add_shape(\n                        type=\"rect\",\n                        x0=0, y0=0,\n                        x1=selected_floor.width_meters, y1=selected_floor.height_meters,\n                        line=dict(color=\"#2e5cbf\", width=2),\n                        fillcolor=\"rgba(46, 92, 191, 0.05)\"\n                    )\n                \n                if zones:\n                    render_coverage_zones(fig, zones)\n                \n                drawing_vertices = st.session_state.get('drawing_vertices', [])\n                if drawing_vertices:\n                    xs = [v[0] for v in drawing_vertices]\n                    ys = [v[1] for v in drawing_vertices]\n                    \n                    fig.add_trace(go.Scatter(\n                        x=xs, y=ys,\n                        mode='markers+lines+text',\n                        marker=dict(size=14, color='#ff6b35', symbol='circle'),\n                        line=dict(color='#ff6b35', width=2, dash='dash'),\n                        text=[f\"{i+1}\" for i in range(len(xs))],\n                        textposition=\"top center\",\n                        textfont=dict(size=12, color='#ff6b35'),\n                        name='Drawing Points',\n                        hovertemplate='Point %{text}<br>X: %{x:.1f}m<br>Y: %{y:.1f}m<extra></extra>'\n                    ))\n                    \n                    if len(drawing_vertices) >= 3:\n                        fig.add_trace(go.Scatter(\n                            x=xs + [xs[0]], y=ys + [ys[0]],\n                            fill='toself',\n                            fillcolor='rgba(255, 107, 53, 0.15)',\n                            line=dict(color='rgba(255, 107, 53, 0.5)', width=1, dash='dot'),\n                            mode='lines',\n                            name='Preview',\n                            showlegend=False,\n                            hoverinfo='skip'\n                        ))\n                \n                pending_polygon = st.session_state.get('pending_polygon')\n                if pending_polygon:\n                    xs = [v[0] for v in pending_polygon]\n                    ys = [v[1] for v in pending_polygon]\n                    fig.add_trace(go.Scatter(\n                        x=xs + [xs[0]], y=ys + [ys[0]],\n                        fill='toself',\n                        fillcolor='rgba(46, 191, 92, 0.2)',\n                        line=dict(color='#2ebf5c', width=3),\n                        mode='lines',\n                        name='Completed Polygon',\n                        hovertemplate='Completed polygon ready to save<extra></extra>'\n                    ))\n                \n                focus_area = st.session_state.get('focus_area')\n                if focus_area:\n                    x_axis_config = dict(\n                        title=\"X (meters)\",\n                        range=[focus_area['x_min'], focus_area['x_max']],\n                        scaleanchor=\"y\",\n                        scaleratio=1,\n                        showgrid=True,\n                        gridwidth=1,\n                        gridcolor='rgba(0,0,0,0.1)',\n                        constrain='domain'\n                    )\n                    y_axis_config = dict(\n                        title=\"Y (meters)\",\n                        range=[focus_area['y_min'], focus_area['y_max']],\n                        showgrid=True,\n                        gridwidth=1,\n                        gridcolor='rgba(0,0,0,0.1)',\n                        constrain='domain'\n                    )\n                else:\n                    x_axis_config = dict(\n                        title=\"X (meters)\",\n                        range=[0, selected_floor.width_meters],\n                        scaleanchor=\"y\",\n                        scaleratio=1,\n                        showgrid=True,\n                        gridwidth=1,\n                        gridcolor='rgba(0,0,0,0.1)',\n                        constrain='domain'\n                    )\n                    y_axis_config = dict(\n                        title=\"Y (meters)\",\n                        range=[0, selected_floor.height_meters],\n                        showgrid=True,\n                        gridwidth=1,\n                        gridcolor='rgba(0,0,0,0.1)',\n                        constrain='domain'\n                    )\n                \n                fig.update_layout(\n                    height=600,\n                    uirevision=f\"floor_{selected_floor.id}_focus\",\n                    xaxis=x_axis_config,\n                    yaxis=y_axis_config,\n                    showlegend=True,\n                    legend=dict(\n                        orientation=\"h\",\n                        yanchor=\"bottom\",\n                        y=1.02,\n                        xanchor=\"right\",\n                        x=1\n                    ),\n                    margin=dict(l=50, r=50, t=50, b=50),\n                    plot_bgcolor='rgba(255,255,255,0.9)'\n                )\n                \n                st.plotly_chart(fig, use_container_width=True, key=\"floor_plan_view\")\n                \n                st.caption(f\"Floor dimensions: {selected_floor.width_meters:.1f}m Ã— {selected_floor.height_meters:.1f}m\")\n                \n                if zones:\n                    st.success(f\"{len(zones)} coverage zone(s) defined\")\n                else:\n                    st.info(\"No coverage zones defined. Gateways will be placed based on floor boundaries.\")\n            else:\n                st.info(\"Select a building and floor to view the floor plan.\")\n\n\ndef render_live_monitoring_tab():\n    \"\"\"Render the live zone monitoring tab\"\"\"\n    with get_db_session() as session:\n        buildings = session.query(Building).all()\n        if not buildings:\n            st.warning(\"No buildings configured.\")\n            return\n        \n        col1, col2 = st.columns([1, 3])\n        \n        with col1:\n            st.subheader(\"Settings\")\n            \n            building_options = {b.name: b.id for b in buildings}\n            selected_building = st.selectbox(\"Building\", options=list(building_options.keys()), key=\"monitor_building\")\n            \n            floors = session.query(Floor).filter(\n                Floor.building_id == building_options[selected_building]\n            ).order_by(Floor.floor_number).all()\n            \n            if not floors:\n                st.warning(\"No floor plans.\")\n                return\n            \n            floor_options = {f\"Floor {f.floor_number}\": f.id for f in floors}\n            selected_floor_name = st.selectbox(\"Floor\", options=list(floor_options.keys()), key=\"monitor_floor\")\n            selected_floor_id = floor_options[selected_floor_name]\n            \n            auto_refresh = st.checkbox(\"Auto-refresh\", value=False, key=\"zone_auto_refresh\")\n            \n            if st.button(\"Check for Alerts\"):\n                new_alerts = check_zone_transitions(session, selected_floor_id)\n                if new_alerts:\n                    for alert in new_alerts:\n                        st.warning(f\"{alert['beacon']} {alert['type']}ed {alert['zone']}\")\n                else:\n                    st.info(\"No new zone transitions detected\")\n            \n            st.divider()\n            st.subheader(\"Manage Alert Zones\")\n            \n            existing_zones = session.query(Zone).filter(\n                Zone.floor_id == selected_floor_id\n            ).all()\n            \n            if existing_zones:\n                zone_to_delete = st.selectbox(\n                    \"Select zone to delete\",\n                    options=[z.name for z in existing_zones],\n                    key=\"zone_to_delete\"\n                )\n                \n                if st.button(\"Delete Zone\", type=\"secondary\"):\n                    zone = session.query(Zone).filter(\n                        Zone.floor_id == selected_floor_id,\n                        Zone.name == zone_to_delete\n                    ).first()\n                    if zone:\n                        session.query(ZoneAlert).filter(ZoneAlert.zone_id == zone.id).delete()\n                        session.delete(zone)\n                        session.commit()\n                        st.success(f\"Deleted zone '{zone_to_delete}' and its alerts\")\n                        st.rerun()\n            else:\n                st.info(\"No alert zones on this floor\")\n        \n        with col2:\n            floor = session.query(Floor).filter(Floor.id == selected_floor_id).first()\n            \n            zones = session.query(Zone).filter(\n                Zone.floor_id == selected_floor_id,\n                Zone.is_active == True\n            ).all()\n            \n            gateways = session.query(Gateway).filter(\n                Gateway.floor_id == selected_floor_id,\n                Gateway.is_active == True\n            ).all()\n            \n            five_seconds_ago = datetime.utcnow() - timedelta(seconds=5)\n            recent_positions = session.query(Position).filter(\n                Position.floor_id == selected_floor_id,\n                Position.timestamp >= five_seconds_ago\n            ).order_by(Position.timestamp.desc()).all()\n            \n            beacon_positions = {}\n            for pos in recent_positions:\n                beacon = session.query(Beacon).filter(Beacon.id == pos.beacon_id).first()\n                if beacon and beacon.name not in beacon_positions:\n                    beacon_positions[beacon.name] = {\n                        'x': pos.x_position,\n                        'y': pos.y_position\n                    }\n            \n            st.subheader(f\"Zone Map: {floor.name or f'Floor {floor.floor_number}'}\")\n            \n            fig = go.Figure()\n            \n            has_floor_plan = render_floor_plan(fig, floor)\n            \n            if not has_floor_plan:\n                fig.add_shape(\n                    type=\"rect\",\n                    x0=0, y0=0,\n                    x1=float(floor.width_meters), y1=float(floor.height_meters),\n                    line=dict(color=\"#2e5cbf\", width=2),\n                    fillcolor=\"rgba(46, 92, 191, 0.05)\"\n                )\n            \n            for zone in zones:\n                fig.add_shape(\n                    type=\"rect\",\n                    x0=float(zone.x_min), y0=float(zone.y_min),\n                    x1=float(zone.x_max), y1=float(zone.y_max),\n                    line=dict(color=zone.color, width=2),\n                    fillcolor=zone.color,\n                    opacity=0.3\n                )\n                fig.add_annotation(\n                    x=(float(zone.x_min) + float(zone.x_max)) / 2,\n                    y=float(zone.y_max) + 0.5,\n                    text=zone.name,\n                    showarrow=False,\n                    font=dict(size=12, color=zone.color)\n                )\n            \n            for gw in gateways:\n                fig.add_trace(go.Scatter(\n                    x=[float(gw.x_position)],\n                    y=[float(gw.y_position)],\n                    mode='markers',\n                    marker=dict(size=10, color='blue', symbol='square'),\n                    name=f\"GW: {gw.name}\",\n                    showlegend=False\n                ))\n            \n            colors = ['red', 'green', 'orange', 'purple', 'cyan', 'magenta']\n            for idx, (beacon_name, pos) in enumerate(beacon_positions.items()):\n                color = colors[idx % len(colors)]\n                fig.add_trace(go.Scatter(\n                    x=[pos['x']],\n                    y=[pos['y']],\n                    mode='markers+text',\n                    marker=dict(size=12, color=color),\n                    text=[beacon_name],\n                    textposition='bottom center',\n                    name=beacon_name\n                ))\n            \n            fig.update_layout(\n                height=500,\n                xaxis=dict(\n                    title=\"X (meters)\",\n                    range=[0, float(floor.width_meters)],\n                    scaleanchor=\"y\",\n                    scaleratio=1\n                ),\n                yaxis=dict(\n                    title=\"Y (meters)\",\n                    range=[0, float(floor.height_meters)]\n                ),\n                showlegend=True,\n                margin=dict(l=50, r=50, t=50, b=50)\n            )\n            \n            st.plotly_chart(fig, use_container_width=True, key=\"zone_monitoring_chart\")\n            \n            st.subheader(\"Current Zone Occupancy\")\n            \n            if zones and beacon_positions:\n                for zone in zones:\n                    beacons_in_zone = []\n                    for beacon_name, pos in beacon_positions.items():\n                        if point_in_zone(pos['x'], pos['y'], zone):\n                            beacons_in_zone.append(beacon_name)\n                    \n                    if beacons_in_zone:\n                        st.write(f\"**{zone.name}:** {', '.join(beacons_in_zone)}\")\n                    else:\n                        st.write(f\"**{zone.name}:** Empty\")\n            elif not zones:\n                st.info(\"No alert zones defined for this floor. Alert zones (rectangular areas with entry/exit triggers) are separate from coverage zones used for gateway planning.\")\n            else:\n                st.info(\"No beacons currently tracked on this floor.\")\n            \n            if auto_refresh:\n                import time\n                time.sleep(2)\n                st.rerun()\n\n\ndef render_alert_history_tab():\n    \"\"\"Render the alert history tab\"\"\"\n    with get_db_session() as session:\n        st.subheader(\"Alert History\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            filter_type = st.selectbox(\n                \"Filter by Type\",\n                options=[\"All\", \"Enter\", \"Exit\"],\n                key=\"alert_filter_type\"\n            )\n        \n        with col2:\n            filter_ack = st.selectbox(\n                \"Filter by Status\",\n                options=[\"All\", \"Unacknowledged\", \"Acknowledged\"],\n                key=\"alert_filter_ack\"\n            )\n        \n        query = session.query(ZoneAlert).order_by(ZoneAlert.timestamp.desc())\n        \n        if filter_type != \"All\":\n            query = query.filter(ZoneAlert.alert_type == filter_type.lower())\n        \n        if filter_ack == \"Unacknowledged\":\n            query = query.filter(ZoneAlert.acknowledged == False)\n        elif filter_ack == \"Acknowledged\":\n            query = query.filter(ZoneAlert.acknowledged == True)\n        \n        alerts = query.limit(100).all()\n        \n        if alerts:\n            st.write(f\"**Total alerts shown:** {len(alerts)}\")\n            \n            if st.button(\"Acknowledge All Visible\"):\n                for alert in alerts:\n                    alert.acknowledged = True\n                st.success(\"All alerts acknowledged\")\n                st.rerun()\n            \n            for alert in alerts:\n                zone = session.query(Zone).filter(Zone.id == alert.zone_id).first()\n                beacon = session.query(Beacon).filter(Beacon.id == alert.beacon_id).first()\n                \n                icon = \"ðŸšª\" if alert.alert_type == \"enter\" else \"ðŸš¶\"\n                ack_icon = \"âœ“\" if alert.acknowledged else \"!\"\n                \n                with st.expander(\n                    f\"{icon} [{ack_icon}] {beacon.name if beacon else 'Unknown'} {alert.alert_type}ed {zone.name if zone else 'Unknown'} - {alert.timestamp.strftime('%Y-%m-%d %H:%M:%S')}\",\n                    expanded=False\n                ):\n                    col1, col2 = st.columns([3, 1])\n                    \n                    with col1:\n                        st.write(f\"**Zone:** {zone.name if zone else 'Unknown'}\")\n                        st.write(f\"**Beacon:** {beacon.name if beacon else 'Unknown'}\")\n                        st.write(f\"**Position:** ({alert.x_position:.2f}, {alert.y_position:.2f})\")\n                        st.write(f\"**Time:** {alert.timestamp}\")\n                    \n                    with col2:\n                        if not alert.acknowledged:\n                            if st.button(\"Acknowledge\", key=f\"ack_{alert.id}\"):\n                                alert.acknowledged = True\n                                st.rerun()\n        else:\n            st.info(\"No alerts recorded yet.\")\n\n\nif __name__ == \"__main__\":\n    show()\n","path":null,"size_bytes":53938,"size_tokens":null},"views/gateway_planning.py":{"content":"import streamlit as st\nimport plotly.graph_objects as go\nimport numpy as np\nimport json\nimport base64\nimport math\nfrom io import BytesIO\nfrom PIL import Image\nfrom database.models import (\n    get_db_session, Building, Floor, Gateway, GatewayPlan, PlannedGateway, CoverageZone\n)\n\n\ndef latlon_to_meters(lat, lon, origin_lat, origin_lon):\n    \"\"\"Convert lat/lon to local meter coordinates using equirectangular projection\"\"\"\n    dx = (lon - origin_lon) * math.cos(math.radians(origin_lat)) * 111000\n    dy = (lat - origin_lat) * 111000\n    return dx, dy\n\n\ndef render_dxf_floor_plan(fig, floor):\n    \"\"\"Render DXF floor plan (stored as GeoJSON) in local meter coordinates\"\"\"\n    if not floor.floor_plan_geojson:\n        return False\n    \n    try:\n        geojson_data = json.loads(floor.floor_plan_geojson)\n        \n        for feature in geojson_data.get('features', []):\n            props = feature.get('properties', {})\n            geom = feature.get('geometry', {})\n            geom_type = props.get('geomType', '')\n            \n            if geom.get('type') == 'Polygon':\n                coords = geom.get('coordinates', [[]])[0]\n                if coords:\n                    xs = [c[0] for c in coords]\n                    ys = [c[1] for c in coords]\n                    \n                    name = props.get('name', 'Unnamed')\n                    \n                    if geom_type == 'room':\n                        fill_color = 'rgba(46, 92, 191, 0.15)'\n                        line_color = '#2e5cbf'\n                    else:\n                        fill_color = 'rgba(200, 200, 200, 0.1)'\n                        line_color = '#666'\n                    \n                    fig.add_trace(go.Scatter(\n                        x=xs,\n                        y=ys,\n                        fill='toself',\n                        fillcolor=fill_color,\n                        line=dict(color=line_color, width=1),\n                        name=name,\n                        hovertemplate=f\"<b>{name}</b><extra></extra>\",\n                        mode='lines',\n                        showlegend=False\n                    ))\n            \n            elif geom.get('type') == 'LineString':\n                coords = geom.get('coordinates', [])\n                if coords:\n                    xs = [c[0] for c in coords]\n                    ys = [c[1] for c in coords]\n                    \n                    if geom_type == 'wall':\n                        line_width = 2\n                        line_color = '#333'\n                    else:\n                        line_width = 1\n                        line_color = '#666'\n                    \n                    fig.add_trace(go.Scatter(\n                        x=xs,\n                        y=ys,\n                        mode='lines',\n                        line=dict(color=line_color, width=line_width),\n                        showlegend=False,\n                        hoverinfo='skip'\n                    ))\n        \n        return True\n    except Exception as e:\n        return False\n\n\ndef render_polygon_ring(fig, ring_coords, floor, props, is_building=False):\n    \"\"\"Render a single polygon ring (exterior or interior)\"\"\"\n    if not ring_coords:\n        return\n    \n    xs = []\n    ys = []\n    for c in ring_coords:\n        if len(c) >= 2:\n            lon, lat = c[0], c[1]\n            x, y = latlon_to_meters(lat, lon, floor.origin_lat, floor.origin_lon)\n            xs.append(x)\n            ys.append(y)\n    \n    if not xs:\n        return\n    \n    name = props.get('name', '')\n    geom_type = props.get('geomType', '')\n    \n    if geom_type == 'room':\n        fill_color = 'rgba(46, 92, 191, 0.15)'\n        line_color = '#2e5cbf'\n        line_width = 1\n    elif geom_type == 'building':\n        fill_color = 'rgba(200, 200, 200, 0.1)'\n        line_color = '#444'\n        line_width = 2\n    else:\n        fill_color = 'rgba(150, 150, 150, 0.1)'\n        line_color = '#666'\n        line_width = 1\n    \n    fig.add_trace(go.Scatter(\n        x=xs,\n        y=ys,\n        fill='toself',\n        fillcolor=fill_color,\n        line=dict(color=line_color, width=line_width),\n        name=name if name else geom_type,\n        hovertemplate=f\"<b>{name or geom_type}</b><extra></extra>\",\n        mode='lines',\n        showlegend=False\n    ))\n    \n    if name and geom_type == 'room':\n        center_x = sum(xs) / len(xs)\n        center_y = sum(ys) / len(ys)\n        fig.add_annotation(\n            x=center_x,\n            y=center_y,\n            text=name[:12],\n            showarrow=False,\n            font=dict(size=8, color='#1a1a1a')\n        )\n\n\ndef render_geojson_floor_plan(fig, floor):\n    \"\"\"Render GeoJSON floor plan as Plotly traces in meter coordinates.\n    \n    Handles all geometry types: Point, LineString, Polygon, MultiPolygon, etc.\n    \"\"\"\n    if not floor.floor_plan_geojson or not floor.origin_lat or not floor.origin_lon:\n        return False\n    \n    try:\n        geojson_data = json.loads(floor.floor_plan_geojson)\n        rendered_any = False\n        \n        for feature in geojson_data.get('features', []):\n            props = feature.get('properties', {})\n            geom = feature.get('geometry', {})\n            geometry_type = geom.get('type', '')\n            geom_type = props.get('geomType', '')\n            \n            if geometry_type == 'Polygon':\n                rings = geom.get('coordinates', [])\n                if rings:\n                    render_polygon_ring(fig, rings[0], floor, props)\n                    rendered_any = True\n            \n            elif geometry_type == 'MultiPolygon':\n                polygons = geom.get('coordinates', [])\n                for polygon in polygons:\n                    if polygon:\n                        render_polygon_ring(fig, polygon[0], floor, props, is_building=True)\n                        rendered_any = True\n            \n            elif geometry_type == 'LineString':\n                coords = geom.get('coordinates', [])\n                if coords:\n                    xs = []\n                    ys = []\n                    for c in coords:\n                        if len(c) >= 2:\n                            lon, lat = c[0], c[1]\n                            x, y = latlon_to_meters(lat, lon, floor.origin_lat, floor.origin_lon)\n                            xs.append(x)\n                            ys.append(y)\n                    \n                    if xs:\n                        wall_type = props.get('subType', 'inner')\n                        line_width = 2 if wall_type == 'outer' or geom_type == 'wall' else 1\n                        \n                        fig.add_trace(go.Scatter(\n                            x=xs,\n                            y=ys,\n                            mode='lines',\n                            line=dict(color='#333', width=line_width),\n                            showlegend=False,\n                            hoverinfo='skip'\n                        ))\n                        rendered_any = True\n            \n            elif geometry_type == 'MultiLineString':\n                lines = geom.get('coordinates', [])\n                for line_coords in lines:\n                    if line_coords:\n                        xs = []\n                        ys = []\n                        for c in line_coords:\n                            if len(c) >= 2:\n                                lon, lat = c[0], c[1]\n                                x, y = latlon_to_meters(lat, lon, floor.origin_lat, floor.origin_lon)\n                                xs.append(x)\n                                ys.append(y)\n                        \n                        if xs:\n                            fig.add_trace(go.Scatter(\n                                x=xs,\n                                y=ys,\n                                mode='lines',\n                                line=dict(color='#333', width=1),\n                                showlegend=False,\n                                hoverinfo='skip'\n                            ))\n                            rendered_any = True\n        \n        return rendered_any\n    except Exception as e:\n        return False\n\n\ndef create_floor_plan_figure(floor):\n    \"\"\"Create base figure with floor plan image or GeoJSON/DXF if available\"\"\"\n    fig = go.Figure()\n    \n    has_floor_plan = False\n    \n    if floor.floor_plan_image:\n        try:\n            image = Image.open(BytesIO(floor.floor_plan_image))\n            buffered = BytesIO()\n            image.save(buffered, format=\"PNG\")\n            img_str = base64.b64encode(buffered.getvalue()).decode()\n            \n            fig.add_layout_image(\n                dict(\n                    source=f\"data:image/png;base64,{img_str}\",\n                    xref=\"x\",\n                    yref=\"y\",\n                    x=0,\n                    y=floor.height_meters,\n                    sizex=floor.width_meters,\n                    sizey=floor.height_meters,\n                    sizing=\"stretch\",\n                    opacity=0.9,\n                    layer=\"below\"\n                )\n            )\n            has_floor_plan = True\n        except Exception as e:\n            pass\n    \n    if not has_floor_plan and floor.floor_plan_type == 'dxf' and floor.floor_plan_geojson:\n        has_floor_plan = render_dxf_floor_plan(fig, floor)\n    \n    if not has_floor_plan and floor.floor_plan_geojson:\n        has_floor_plan = render_geojson_floor_plan(fig, floor)\n    \n    return fig, has_floor_plan\n\n\ndef calculate_recommended_gateways(floor_area: float, target_accuracy: float, signal_range: float = 15.0, floor=None) -> dict:\n    \"\"\"Calculate recommended number of gateways based on floor area and target accuracy.\n    \n    Optimizes for minimum gateways while ensuring overlapping coverage for triangulation.\n    For perimeter placement, gateways only need to cover inward, reducing the count needed.\n    \"\"\"\n    if floor:\n        bounds = extract_building_bounds(floor)\n        actual_area = bounds['width'] * bounds['height']\n        actual_width = bounds['width']\n        actual_height = bounds['height']\n    else:\n        actual_area = floor_area\n        actual_width = np.sqrt(floor_area)\n        actual_height = np.sqrt(floor_area)\n    \n    effective_range = signal_range * 0.8\n    \n    if target_accuracy <= 0.5:\n        min_gateways = 4\n        overlap_factor = 0.5\n        geometry_note = \"4 gateways in corners provide surrounding geometry for sub-meter accuracy\"\n    elif target_accuracy <= 1.0:\n        min_gateways = 3\n        overlap_factor = 0.6\n        geometry_note = \"3 gateways in triangle formation for meter-level accuracy\"\n    elif target_accuracy <= 2.0:\n        min_gateways = 3\n        overlap_factor = 0.7\n        geometry_note = \"3 gateways for reliable 2D positioning\"\n    else:\n        min_gateways = 2\n        overlap_factor = 0.8\n        geometry_note = \"2 gateways for basic zone-level coverage\"\n    \n    coverage_diameter = effective_range * 2 * overlap_factor\n    \n    gw_along_width = max(2, int(np.ceil(actual_width / coverage_diameter)))\n    gw_along_height = max(2, int(np.ceil(actual_height / coverage_diameter)))\n    \n    if actual_width <= coverage_diameter * 1.5 and actual_height <= coverage_diameter * 1.5:\n        gateways_for_coverage = min_gateways\n    elif actual_width <= coverage_diameter * 2 and actual_height <= coverage_diameter * 2:\n        gateways_for_coverage = max(min_gateways, 4)\n    else:\n        perimeter_gateways = 2 * (gw_along_width + gw_along_height) - 4\n        gateways_for_coverage = max(min_gateways, perimeter_gateways)\n    \n    if gateways_for_coverage > 12:\n        geometry_note = f\"{gateways_for_coverage} gateways needed for full coverage - consider zone-based approach\"\n    \n    return {\n        \"recommended\": gateways_for_coverage,\n        \"minimum\": min_gateways,\n        \"coverage_radius\": effective_range,\n        \"geometry_note\": geometry_note,\n        \"achievable\": target_accuracy >= 0.5,\n        \"actual_building_area\": actual_area\n    }\n\n\ndef evaluate_placement_quality(gateways: list, floor_width: float, floor_height: float, target_accuracy: float, signal_range: float = 15.0) -> dict:\n    \"\"\"Evaluate the quality of gateway placement\"\"\"\n    if len(gateways) < 2:\n        return {\n            \"score\": 0,\n            \"status\": \"insufficient\",\n            \"message\": \"At least 2 gateways required for any positioning\",\n            \"coverage_percent\": 0,\n            \"issues\": [\"Need minimum 2 gateways\"]\n        }\n    \n    positions = np.array([[g['x'], g['y']] for g in gateways])\n    \n    centroid = positions.mean(axis=0)\n    floor_center = np.array([floor_width / 2, floor_height / 2])\n    center_offset = np.linalg.norm(centroid - floor_center) / max(floor_width, floor_height)\n    \n    if len(gateways) >= 3:\n        angles = []\n        for i, pos in enumerate(positions):\n            angle = np.arctan2(pos[1] - centroid[1], pos[0] - centroid[0])\n            angles.append(angle)\n        angles = sorted(angles)\n        angle_gaps = []\n        for i in range(len(angles)):\n            gap = angles[(i + 1) % len(angles)] - angles[i]\n            if gap < 0:\n                gap += 2 * np.pi\n            angle_gaps.append(gap)\n        max_gap = max(angle_gaps)\n        angular_distribution = 1.0 - (max_gap / (2 * np.pi))\n    else:\n        angular_distribution = 0.3\n    \n    distances = []\n    for i in range(len(positions)):\n        for j in range(i + 1, len(positions)):\n            distances.append(np.linalg.norm(positions[i] - positions[j]))\n    avg_distance = np.mean(distances)\n    ideal_distance = max(floor_width, floor_height) * 0.4\n    distance_score = 1.0 - min(1.0, abs(avg_distance - ideal_distance) / ideal_distance)\n    \n    grid_size = 1.0\n    x_points = np.arange(0, floor_width, grid_size)\n    y_points = np.arange(0, floor_height, grid_size)\n    covered_points = 0\n    total_points = len(x_points) * len(y_points)\n    \n    for x in x_points:\n        for y in y_points:\n            gateways_in_range = 0\n            for pos in positions:\n                dist = np.sqrt((x - pos[0])**2 + (y - pos[1])**2)\n                if dist <= signal_range:\n                    gateways_in_range += 1\n            if target_accuracy <= 1.0:\n                if gateways_in_range >= 3:\n                    covered_points += 1\n            else:\n                if gateways_in_range >= 2:\n                    covered_points += 1\n    \n    coverage_percent = (covered_points / total_points) * 100 if total_points > 0 else 0\n    \n    issues = []\n    if len(gateways) < 3 and target_accuracy <= 2.0:\n        issues.append(f\"Need at least 3 gateways for {target_accuracy}m accuracy\")\n    if len(gateways) < 4 and target_accuracy <= 0.5:\n        issues.append(f\"Need 4+ calibrated gateways for sub-meter accuracy\")\n    if center_offset > 0.3:\n        issues.append(\"Gateways are not centered over floor area\")\n    if angular_distribution < 0.6 and len(gateways) >= 3:\n        issues.append(\"Gateways are clustered - spread them around the perimeter\")\n    if coverage_percent < 80:\n        issues.append(f\"Only {coverage_percent:.0f}% coverage - add more gateways\")\n    \n    gateway_count_score = min(1.0, len(gateways) / (4 if target_accuracy <= 0.5 else 3))\n    overall_score = (\n        gateway_count_score * 0.3 +\n        angular_distribution * 0.25 +\n        distance_score * 0.2 +\n        (coverage_percent / 100) * 0.25\n    )\n    \n    if len(issues) == 0:\n        status = \"excellent\"\n        message = f\"Placement meets requirements for Â±{target_accuracy}m accuracy\"\n    elif overall_score >= 0.7:\n        status = \"good\"\n        message = \"Placement is acceptable with minor improvements possible\"\n    elif overall_score >= 0.5:\n        status = \"fair\"\n        message = \"Placement needs improvement for target accuracy\"\n    else:\n        status = \"poor\"\n        message = \"Placement does not meet accuracy requirements\"\n    \n    return {\n        \"score\": overall_score,\n        \"status\": status,\n        \"message\": message,\n        \"coverage_percent\": coverage_percent,\n        \"issues\": issues,\n        \"details\": {\n            \"gateway_count_score\": gateway_count_score,\n            \"angular_distribution\": angular_distribution,\n            \"distance_score\": distance_score,\n            \"center_offset\": center_offset\n        }\n    }\n\n\ndef coords_look_like_latlon(all_coords, floor=None):\n    \"\"\"Detect if coordinates are lat/lon (degrees) vs meters.\n    \n    Decision logic:\n    1. If floor_plan_type is 'dxf', coordinates are in meters\n    2. If floor has origin_lat/origin_lon AND floor_plan_type is 'geojson', likely lat/lon\n    3. Otherwise, check coordinate ranges (lat/lon has much smaller range than meters)\n    \"\"\"\n    if not all_coords:\n        return False\n    \n    if floor:\n        if floor.floor_plan_type == 'dxf':\n            return False\n        if floor.floor_plan_type == 'geojson' and floor.origin_lat and floor.origin_lon:\n            return True\n    \n    xs = [c[0] for c in all_coords if len(c) >= 2]\n    ys = [c[1] for c in all_coords if len(c) >= 2]\n    \n    if not xs or not ys:\n        return False\n    \n    x_range = max(xs) - min(xs)\n    y_range = max(ys) - min(ys)\n    \n    if x_range < 1 and y_range < 1:\n        all_x_in_lon_range = all(-180 <= x <= 180 for x in xs)\n        all_y_in_lat_range = all(-90 <= y <= 90 for y in ys)\n        if all_x_in_lon_range and all_y_in_lat_range:\n            return True\n    \n    return False\n\n\ndef extract_coords_from_geometry(geom):\n    \"\"\"Extract all coordinates from a GeoJSON geometry, handling all types.\"\"\"\n    coords = []\n    geom_type = geom.get('type', '')\n    \n    if geom_type == 'Point':\n        coords.append(geom.get('coordinates', []))\n    elif geom_type == 'LineString':\n        coords.extend(geom.get('coordinates', []))\n    elif geom_type == 'Polygon':\n        for ring in geom.get('coordinates', []):\n            coords.extend(ring)\n    elif geom_type == 'MultiPoint':\n        coords.extend(geom.get('coordinates', []))\n    elif geom_type == 'MultiLineString':\n        for line in geom.get('coordinates', []):\n            coords.extend(line)\n    elif geom_type == 'MultiPolygon':\n        for polygon in geom.get('coordinates', []):\n            for ring in polygon:\n                coords.extend(ring)\n    \n    return coords\n\n\ndef extract_building_bounds(floor):\n    \"\"\"Extract actual building boundaries from floor plan geometry.\n    \n    Handles:\n    - DXF plans: coordinates already in meters\n    - GeoJSON lat/lon: converted to meters using floor origin (detected by small ranges)\n    - GeoJSON meters: used directly (detected by large ranges)\n    - All geometry types: Point, LineString, Polygon, MultiPolygon, etc.\n    \"\"\"\n    min_x, max_x, min_y, max_y = None, None, None, None\n    \n    if floor.floor_plan_geojson:\n        try:\n            geojson_data = json.loads(floor.floor_plan_geojson)\n            all_coords = []\n            \n            for feature in geojson_data.get('features', []):\n                geom = feature.get('geometry', {})\n                feature_coords = extract_coords_from_geometry(geom)\n                all_coords.extend(feature_coords)\n            \n            if all_coords:\n                is_latlon = coords_look_like_latlon(all_coords, floor)\n                has_origin = floor.origin_lat is not None and floor.origin_lon is not None\n                \n                if is_latlon and has_origin:\n                    xs = []\n                    ys = []\n                    for c in all_coords:\n                        if len(c) >= 2:\n                            lon, lat = c[0], c[1]\n                            x, y = latlon_to_meters(lat, lon, floor.origin_lat, floor.origin_lon)\n                            xs.append(x)\n                            ys.append(y)\n                else:\n                    xs = [c[0] for c in all_coords if len(c) >= 2]\n                    ys = [c[1] for c in all_coords if len(c) >= 2]\n                \n                if xs and ys:\n                    min_x, max_x = min(xs), max(xs)\n                    min_y, max_y = min(ys), max(ys)\n        except Exception:\n            pass\n    \n    width = (max_x - min_x) if min_x is not None else 0\n    height = (max_y - min_y) if min_y is not None else 0\n    \n    if min_x is None or width < 5 or height < 5:\n        min_x, max_x = 0, floor.width_meters\n        min_y, max_y = 0, floor.height_meters\n    \n    return {\n        'min_x': min_x, 'max_x': max_x,\n        'min_y': min_y, 'max_y': max_y,\n        'width': max_x - min_x,\n        'height': max_y - min_y,\n        'center_x': (min_x + max_x) / 2,\n        'center_y': (min_y + max_y) / 2\n    }\n\n\ndef point_in_polygon(x, y, polygon):\n    \"\"\"Ray casting algorithm to check if point is inside polygon.\n    \n    Args:\n        x, y: Point coordinates\n        polygon: List of [x, y] coordinates forming the polygon\n    \n    Returns:\n        True if point is inside polygon\n    \"\"\"\n    n = len(polygon)\n    inside = False\n    \n    j = n - 1\n    for i in range(n):\n        xi, yi = polygon[i][0], polygon[i][1]\n        xj, yj = polygon[j][0], polygon[j][1]\n        \n        if ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi):\n            inside = not inside\n        j = i\n    \n    return inside\n\n\ndef get_coverage_zone_bounds(zone):\n    \"\"\"Extract bounds from a coverage zone polygon\"\"\"\n    try:\n        coords = json.loads(zone.polygon_coords)\n        if coords:\n            xs = [c[0] for c in coords]\n            ys = [c[1] for c in coords]\n            return {\n                'min_x': min(xs), 'max_x': max(xs),\n                'min_y': min(ys), 'max_y': max(ys),\n                'width': max(xs) - min(xs),\n                'height': max(ys) - min(ys),\n                'center_x': (min(xs) + max(xs)) / 2,\n                'center_y': (min(ys) + max(ys)) / 2,\n                'polygon': coords\n            }\n    except Exception:\n        pass\n    return None\n\n\ndef calculate_gateways_for_zone(zone):\n    \"\"\"Calculate how many gateways are needed for a coverage zone based on its target accuracy.\"\"\"\n    bounds = get_coverage_zone_bounds(zone)\n    if not bounds:\n        return 3  # Default\n    \n    zone_area = bounds['width'] * bounds['height']\n    target_accuracy = zone.target_accuracy or 1.0\n    \n    # Use same logic as calculate_recommended_gateways\n    if target_accuracy <= 0.5:\n        min_gateways = 4\n    elif target_accuracy <= 1.0:\n        min_gateways = 3\n    elif target_accuracy <= 2.0:\n        min_gateways = 3\n    else:\n        min_gateways = 2\n    \n    # For small zones, fewer gateways may suffice\n    if zone_area < 50:  # Small zone < 50 sq meters\n        return max(2, min_gateways - 1)\n    elif zone_area < 200:  # Medium zone\n        return min_gateways\n    else:  # Large zone\n        # Add more gateways for larger areas\n        extra = int(zone_area / 200)\n        return min(min_gateways + extra, 8)\n\n\ndef suggest_gateway_positions_for_zone(zone_bounds, num_gateways, signal_range=15.0):\n    \"\"\"Suggest gateway positions within a coverage zone polygon.\"\"\"\n    suggestions = []\n    \n    bx_min, bx_max = zone_bounds['min_x'], zone_bounds['max_x']\n    by_min, by_max = zone_bounds['min_y'], zone_bounds['max_y']\n    bw = zone_bounds['width']\n    bh = zone_bounds['height']\n    cx, cy = zone_bounds['center_x'], zone_bounds['center_y']\n    polygon = zone_bounds.get('polygon', [])\n    \n    wall_offset = 1.5\n    \n    if num_gateways <= 2:\n        candidates = [\n            {\"x\": bx_min + wall_offset, \"y\": cy, \"name\": \"GW-1 (West)\"},\n            {\"x\": bx_max - wall_offset, \"y\": cy, \"name\": \"GW-2 (East)\"},\n        ]\n    elif num_gateways == 3:\n        candidates = [\n            {\"x\": bx_min + wall_offset, \"y\": by_min + bh * 0.3, \"name\": \"GW-1 (SW)\"},\n            {\"x\": bx_max - wall_offset, \"y\": by_min + bh * 0.3, \"name\": \"GW-2 (SE)\"},\n            {\"x\": cx, \"y\": by_max - wall_offset, \"name\": \"GW-3 (N)\"},\n        ]\n    elif num_gateways == 4:\n        candidates = [\n            {\"x\": bx_min + wall_offset, \"y\": by_min + wall_offset, \"name\": \"GW-1 (SW)\"},\n            {\"x\": bx_max - wall_offset, \"y\": by_min + wall_offset, \"name\": \"GW-2 (SE)\"},\n            {\"x\": bx_max - wall_offset, \"y\": by_max - wall_offset, \"name\": \"GW-3 (NE)\"},\n            {\"x\": bx_min + wall_offset, \"y\": by_max - wall_offset, \"name\": \"GW-4 (NW)\"},\n        ]\n    else:\n        candidates = []\n        perimeter = 2 * (bw + bh)\n        spacing = perimeter / num_gateways\n        current_dist = spacing / 2\n        gw_num = 1\n        \n        sides = [\n            ('S', bx_min, by_min + wall_offset, bx_max, by_min + wall_offset, bw),\n            ('E', bx_max - wall_offset, by_min, bx_max - wall_offset, by_max, bh),\n            ('N', bx_max, by_max - wall_offset, bx_min, by_max - wall_offset, bw),\n            ('W', bx_min + wall_offset, by_max, bx_min + wall_offset, by_min, bh),\n        ]\n        \n        cumulative = 0\n        for side_name, x1, y1, x2, y2, length in sides:\n            while current_dist < cumulative + length and gw_num <= num_gateways:\n                t = (current_dist - cumulative) / length\n                x = x1 + t * (x2 - x1)\n                y = y1 + t * (y2 - y1)\n                candidates.append({\"x\": x, \"y\": y, \"name\": f\"GW-{gw_num} ({side_name})\"})\n                gw_num += 1\n                current_dist += spacing\n            cumulative += length\n    \n    for c in candidates:\n        if polygon:\n            if point_in_polygon(c['x'], c['y'], polygon):\n                suggestions.append({\n                    \"x\": round(float(c['x']), 2),\n                    \"y\": round(float(c['y']), 2),\n                    \"name\": c['name']\n                })\n            else:\n                suggestions.append({\n                    \"x\": round(float(cx), 2),\n                    \"y\": round(float(cy), 2),\n                    \"name\": c['name'] + \" (adjusted)\"\n                })\n        else:\n            suggestions.append({\n                \"x\": round(float(c['x']), 2),\n                \"y\": round(float(c['y']), 2),\n                \"name\": c['name']\n            })\n    \n    return suggestions\n\n\ndef suggest_gateway_positions(floor_width: float, floor_height: float, num_gateways: int, \n                              signal_range: float = 15.0, floor=None) -> list:\n    \"\"\"Suggest optimal gateway positions inside the actual building footprint.\n    \n    Places gateways along the building perimeter (near walls) with positions\n    optimized for triangulation coverage while minimizing the number of gateways.\n    \"\"\"\n    suggestions = []\n    \n    if floor:\n        bounds = extract_building_bounds(floor)\n        bx_min, bx_max = bounds['min_x'], bounds['max_x']\n        by_min, by_max = bounds['min_y'], bounds['max_y']\n        bw = bounds['width']\n        bh = bounds['height']\n        cx, cy = bounds['center_x'], bounds['center_y']\n    else:\n        bx_min, by_min = 0, 0\n        bx_max, bw = float(floor_width), float(floor_width)\n        by_max, bh = float(floor_height), float(floor_height)\n        cx, cy = bw / 2, bh / 2\n    \n    wall_offset = 1.5\n    \n    if num_gateways <= 2:\n        suggestions = [\n            {\"x\": round(bx_min + wall_offset, 2), \"y\": round(cy, 2), \"name\": \"GW-1 (West Wall)\"},\n            {\"x\": round(bx_max - wall_offset, 2), \"y\": round(cy, 2), \"name\": \"GW-2 (East Wall)\"},\n        ]\n    elif num_gateways == 3:\n        suggestions = [\n            {\"x\": round(bx_min + wall_offset, 2), \"y\": round(by_min + bh * 0.3, 2), \"name\": \"GW-1 (West)\"},\n            {\"x\": round(bx_max - wall_offset, 2), \"y\": round(by_min + bh * 0.3, 2), \"name\": \"GW-2 (East)\"},\n            {\"x\": round(cx, 2), \"y\": round(by_max - wall_offset, 2), \"name\": \"GW-3 (North)\"},\n        ]\n    elif num_gateways == 4:\n        suggestions = [\n            {\"x\": round(bx_min + wall_offset, 2), \"y\": round(by_min + wall_offset, 2), \"name\": \"GW-1 (SW Corner)\"},\n            {\"x\": round(bx_max - wall_offset, 2), \"y\": round(by_min + wall_offset, 2), \"name\": \"GW-2 (SE Corner)\"},\n            {\"x\": round(bx_max - wall_offset, 2), \"y\": round(by_max - wall_offset, 2), \"name\": \"GW-3 (NE Corner)\"},\n            {\"x\": round(bx_min + wall_offset, 2), \"y\": round(by_max - wall_offset, 2), \"name\": \"GW-4 (NW Corner)\"},\n        ]\n    else:\n        perimeter = 2 * (bw + bh)\n        spacing = perimeter / num_gateways\n        \n        current_dist = spacing / 2\n        gw_num = 1\n        \n        sides = [\n            ('S', bx_min, by_min + wall_offset, bx_max, by_min + wall_offset, bw),\n            ('E', bx_max - wall_offset, by_min, bx_max - wall_offset, by_max, bh),\n            ('N', bx_max, by_max - wall_offset, bx_min, by_max - wall_offset, bw),\n            ('W', bx_min + wall_offset, by_max, bx_min + wall_offset, by_min, bh),\n        ]\n        \n        cumulative = 0\n        for side_name, x1, y1, x2, y2, length in sides:\n            while current_dist < cumulative + length and gw_num <= num_gateways:\n                t = (current_dist - cumulative) / length\n                x = x1 + t * (x2 - x1)\n                y = y1 + t * (y2 - y1)\n                \n                suggestions.append({\n                    \"x\": round(float(x), 2),\n                    \"y\": round(float(y), 2),\n                    \"name\": f\"GW-{gw_num} ({side_name} Wall)\"\n                })\n                gw_num += 1\n                current_dist += spacing\n            \n            cumulative += length\n    \n    return suggestions\n\n\ndef render_gateway_planning():\n    \"\"\"Render the gateway planning interface\"\"\"\n    st.header(\"Gateway Planning\")\n    st.markdown(\"Plan optimal gateway placement before physical installation to achieve your target accuracy.\")\n    \n    with get_db_session() as session:\n        buildings = session.query(Building).all()\n        \n        if not buildings:\n            st.warning(\"Please add a building with floor plans first in the Buildings section.\")\n            return\n        \n        col1, col2 = st.columns([1, 2])\n        \n        with col1:\n            st.subheader(\"Plan Configuration\")\n            \n            building_options = {b.id: b.name for b in buildings}\n            selected_building_id = st.selectbox(\n                \"Select Building\",\n                options=list(building_options.keys()),\n                format_func=lambda x: building_options[x],\n                key=\"plan_building\"\n            )\n            \n            selected_building = session.query(Building).filter(Building.id == selected_building_id).first()\n            floors = selected_building.floors if selected_building else []\n            \n            if not floors:\n                st.warning(\"No floors defined for this building. Please add floor plans first.\")\n                return\n            \n            floor_options = {f.id: f\"{f.name or f'Floor {f.floor_number}'}\" for f in floors}\n            selected_floor_id = st.selectbox(\n                \"Select Floor\",\n                options=list(floor_options.keys()),\n                format_func=lambda x: floor_options[x],\n                key=\"plan_floor\"\n            )\n            \n            selected_floor = session.query(Floor).filter(Floor.id == selected_floor_id).first()\n            \n            st.divider()\n            \n            st.markdown(\"**Target Accuracy**\")\n            target_accuracy = st.select_slider(\n                \"Desired positioning accuracy\",\n                options=[0.5, 1.0, 2.0, 3.0, 5.0],\n                value=1.0,\n                format_func=lambda x: f\"Â±{x}m\",\n                key=\"target_accuracy\"\n            )\n            \n            if target_accuracy <= 0.5:\n                st.info(\"Sub-meter accuracy requires 4+ calibrated gateways with optimal geometry, or consider UWB technology.\")\n            elif target_accuracy <= 1.0:\n                st.info(\"1-meter accuracy requires 3+ gateways with good triangulation geometry.\")\n            \n            signal_range = st.slider(\n                \"Expected signal range (meters)\",\n                min_value=5.0,\n                max_value=30.0,\n                value=15.0,\n                step=1.0,\n                help=\"Typical BLE range is 10-20m indoors depending on environment\"\n            )\n            \n            floor_area = selected_floor.width_meters * selected_floor.height_meters\n            recommendations = calculate_recommended_gateways(floor_area, target_accuracy, signal_range, floor=selected_floor)\n            \n            st.divider()\n            st.markdown(\"**Recommendations**\")\n            st.metric(\"Recommended Gateways\", recommendations[\"recommended\"])\n            st.caption(recommendations[\"geometry_note\"])\n            \n            if not recommendations[\"achievable\"]:\n                st.warning(\"Sub-0.5m accuracy is at the limit of BLE technology. Consider UWB for better results.\")\n            \n            st.divider()\n            \n            existing_plans = session.query(GatewayPlan).filter(\n                GatewayPlan.floor_id == selected_floor_id\n            ).all()\n            \n            plan_options = {\"new\": \"Create New Plan\"}\n            for plan in existing_plans:\n                plan_options[plan.id] = f\"{plan.name} (Â±{plan.target_accuracy}m)\"\n            \n            selected_plan_key = st.selectbox(\n                \"Gateway Plan\",\n                options=list(plan_options.keys()),\n                format_func=lambda x: plan_options[x],\n                key=\"selected_plan\"\n            )\n            \n            if selected_plan_key == \"new\":\n                plan_name = st.text_input(\"Plan Name\", value=f\"Plan for {floor_options[selected_floor_id]}\")\n                if st.button(\"Create Plan\", type=\"primary\"):\n                    new_plan = GatewayPlan(\n                        floor_id=selected_floor_id,\n                        name=plan_name,\n                        target_accuracy=target_accuracy,\n                        signal_range=signal_range\n                    )\n                    session.add(new_plan)\n                    session.commit()\n                    st.success(f\"Created plan: {plan_name}\")\n                    st.rerun()\n                current_plan = None\n            else:\n                current_plan = session.query(GatewayPlan).filter(GatewayPlan.id == selected_plan_key).first()\n                \n                if current_plan:\n                    st.caption(f\"Plan configuration: Â±{current_plan.target_accuracy}m accuracy, {current_plan.signal_range}m signal range\")\n                    if st.button(\"Delete Plan\", type=\"secondary\"):\n                        session.delete(current_plan)\n                        session.commit()\n                        st.success(\"Plan deleted\")\n                        st.rerun()\n        \n        with col2:\n            st.subheader(\"Floor Plan & Gateway Placement\")\n            \n            if selected_floor:\n                effective_target_accuracy = current_plan.target_accuracy if current_plan and current_plan.target_accuracy else target_accuracy\n                effective_signal_range = current_plan.signal_range if current_plan and current_plan.signal_range else signal_range\n                \n                floor_area = selected_floor.width_meters * selected_floor.height_meters\n                effective_recommendations = calculate_recommended_gateways(floor_area, effective_target_accuracy, effective_signal_range, floor=selected_floor)\n                \n                floor_width = selected_floor.width_meters\n                floor_height = selected_floor.height_meters\n                \n                fig, has_floor_plan = create_floor_plan_figure(selected_floor)\n                \n                if not has_floor_plan:\n                    fig.add_shape(\n                        type=\"rect\",\n                        x0=0, y0=0,\n                        x1=floor_width, y1=floor_height,\n                        line=dict(color=\"#2e5cbf\", width=2),\n                        fillcolor=\"rgba(46, 92, 191, 0.05)\"\n                    )\n                \n                coverage_zones = session.query(CoverageZone).filter(\n                    CoverageZone.floor_id == selected_floor_id,\n                    CoverageZone.is_active == True\n                ).order_by(CoverageZone.priority.desc()).all()\n                \n                for cz in coverage_zones:\n                    try:\n                        coords = json.loads(cz.polygon_coords)\n                        if coords:\n                            xs = [c[0] for c in coords]\n                            ys = [c[1] for c in coords]\n                            \n                            if xs[0] != xs[-1] or ys[0] != ys[-1]:\n                                xs.append(xs[0])\n                                ys.append(ys[0])\n                            \n                            zone_color = cz.color or '#2e5cbf'\n                            r, g, b = int(zone_color[1:3], 16), int(zone_color[3:5], 16), int(zone_color[5:7], 16)\n                            \n                            fig.add_trace(go.Scatter(\n                                x=xs, y=ys,\n                                fill='toself',\n                                fillcolor=f'rgba({r}, {g}, {b}, 0.15)',\n                                line=dict(color=zone_color, width=2, dash='dash'),\n                                mode='lines',\n                                name=f\"{cz.name} (Â±{cz.target_accuracy}m)\",\n                                hovertemplate=f\"<b>{cz.name}</b><br>Target: Â±{cz.target_accuracy}m<extra></extra>\"\n                            ))\n                    except Exception:\n                        pass\n                \n                planned_gateways = []\n                if current_plan:\n                    db_planned_gateways = session.query(PlannedGateway).filter(\n                        PlannedGateway.plan_id == current_plan.id\n                    ).order_by(PlannedGateway.id).all()\n                    for pg in db_planned_gateways:\n                        planned_gateways.append({\n                            'id': pg.id,\n                            'name': pg.name,\n                            'x': pg.x_position,\n                            'y': pg.y_position,\n                            'is_installed': pg.is_installed\n                        })\n                \n                for gw in planned_gateways:\n                    theta = np.linspace(0, 2*np.pi, 50)\n                    r = effective_signal_range\n                    x_circle = gw['x'] + r * np.cos(theta)\n                    y_circle = gw['y'] + r * np.sin(theta)\n                    \n                    color = 'rgba(0, 142, 211, 0.15)' if not gw['is_installed'] else 'rgba(46, 191, 92, 0.15)'\n                    \n                    fig.add_trace(go.Scatter(\n                        x=x_circle.tolist(),\n                        y=y_circle.tolist(),\n                        mode='lines',\n                        line=dict(color='#008ed3' if not gw['is_installed'] else '#2ebf5c', width=1, dash='dot'),\n                        fill='toself',\n                        fillcolor=color,\n                        name=f\"{gw['name']} coverage\",\n                        showlegend=False,\n                        hoverinfo='skip'\n                    ))\n                \n                if planned_gateways:\n                    fig.add_trace(go.Scatter(\n                        x=[gw['x'] for gw in planned_gateways if not gw['is_installed']],\n                        y=[gw['y'] for gw in planned_gateways if not gw['is_installed']],\n                        mode='markers+text',\n                        marker=dict(size=20, color='#008ed3', symbol='diamond'),\n                        text=[gw['name'] for gw in planned_gateways if not gw['is_installed']],\n                        textposition='top center',\n                        textfont=dict(size=10),\n                        name='Planned Gateways',\n                        hovertemplate='<b>%{text}</b><br>Position: (%{x:.1f}m, %{y:.1f}m)<extra></extra>'\n                    ))\n                    \n                    installed = [gw for gw in planned_gateways if gw['is_installed']]\n                    if installed:\n                        fig.add_trace(go.Scatter(\n                            x=[gw['x'] for gw in installed],\n                            y=[gw['y'] for gw in installed],\n                            mode='markers+text',\n                            marker=dict(size=20, color='#2ebf5c', symbol='diamond'),\n                            text=[gw['name'] for gw in installed],\n                            textposition='top center',\n                            textfont=dict(size=10),\n                            name='Installed Gateways',\n                            hovertemplate='<b>%{text}</b><br>Position: (%{x:.1f}m, %{y:.1f}m)<br>INSTALLED<extra></extra>'\n                        ))\n                \n                existing_gateways = session.query(Gateway).filter(\n                    Gateway.floor_id == selected_floor_id,\n                    Gateway.is_active == True\n                ).all()\n                \n                if existing_gateways:\n                    fig.add_trace(go.Scatter(\n                        x=[gw.x_position for gw in existing_gateways],\n                        y=[gw.y_position for gw in existing_gateways],\n                        mode='markers+text',\n                        marker=dict(size=16, color='#ff6b35', symbol='square'),\n                        text=[gw.name for gw in existing_gateways],\n                        textposition='top center',\n                        textfont=dict(size=9),\n                        name='Active Gateways',\n                        hovertemplate='<b>%{text}</b><br>Position: (%{x:.1f}m, %{y:.1f}m)<br>ACTIVE<extra></extra>'\n                    ))\n                \n                fig.update_layout(\n                    height=600,\n                    xaxis=dict(\n                        title=\"X (meters)\",\n                        range=[-2, floor_width + 2],\n                        scaleanchor=\"y\",\n                        scaleratio=1,\n                        showgrid=not has_floor_plan,\n                        gridwidth=1,\n                        gridcolor='rgba(0,0,0,0.1)',\n                        zeroline=False\n                    ),\n                    yaxis=dict(\n                        title=\"Y (meters)\",\n                        range=[-2, floor_height + 2],\n                        showgrid=not has_floor_plan,\n                        gridwidth=1,\n                        gridcolor='rgba(0,0,0,0.1)',\n                        zeroline=False\n                    ),\n                    showlegend=True,\n                    legend=dict(\n                        orientation=\"h\",\n                        yanchor=\"bottom\",\n                        y=1.02,\n                        xanchor=\"right\",\n                        x=1,\n                        bgcolor='rgba(255,255,255,0.8)'\n                    ),\n                    margin=dict(l=50, r=50, t=50, b=50),\n                    plot_bgcolor='rgba(240,240,240,0.3)' if not has_floor_plan else 'rgba(255,255,255,0)'\n                )\n                \n                st.plotly_chart(fig, use_container_width=True)\n                \n                if coverage_zones:\n                    st.info(f\"ðŸ“ **{len(coverage_zones)} coverage zone(s) defined** - Gateways will be placed within these areas. [Manage zones â†’](Coverage Zones)\")\n                else:\n                    st.caption(\"ðŸ’¡ Tip: Define coverage zones to specify which areas need positioning. Go to **Coverage Zones** in the sidebar.\")\n                \n                if current_plan:\n                    quality = evaluate_placement_quality(\n                        planned_gateways, floor_width, floor_height, \n                        effective_target_accuracy, effective_signal_range\n                    )\n                    \n                    status_colors = {\n                        \"excellent\": \"green\",\n                        \"good\": \"blue\", \n                        \"fair\": \"orange\",\n                        \"poor\": \"red\",\n                        \"insufficient\": \"red\"\n                    }\n                    \n                    col_q1, col_q2, col_q3 = st.columns(3)\n                    with col_q1:\n                        st.metric(\"Placement Score\", f\"{quality['score']*100:.0f}%\")\n                    with col_q2:\n                        st.metric(\"Coverage\", f\"{quality['coverage_percent']:.0f}%\")\n                    with col_q3:\n                        color = status_colors.get(quality['status'], 'gray')\n                        st.markdown(f\"**Status:** :{color}[{quality['status'].upper()}]\")\n                    \n                    if quality['issues']:\n                        with st.expander(\"Placement Issues\", expanded=True):\n                            for issue in quality['issues']:\n                                st.warning(issue)\n                    else:\n                        st.success(quality['message'])\n        \n        if current_plan:\n            st.divider()\n            st.subheader(\"Manage Planned Gateways\")\n            \n            col_add1, col_add2, col_add3, col_add4 = st.columns([2, 1, 1, 1])\n            \n            with col_add1:\n                new_gw_name = st.text_input(\"Gateway Name\", value=f\"GW-{len(planned_gateways)+1}\", key=\"new_gw_name\")\n            with col_add2:\n                new_gw_x = st.number_input(\"X Position (m)\", min_value=0.0, max_value=floor_width, value=floor_width/2, key=\"new_gw_x\")\n            with col_add3:\n                new_gw_y = st.number_input(\"Y Position (m)\", min_value=0.0, max_value=floor_height, value=floor_height/2, key=\"new_gw_y\")\n            with col_add4:\n                st.markdown(\"<br>\", unsafe_allow_html=True)\n                if st.button(\"Add Gateway\", type=\"primary\", key=\"add_gw\"):\n                    position_valid = True\n                    zone_name_matched = None\n                    \n                    if coverage_zones:\n                        position_valid = False\n                        for cz in coverage_zones:\n                            try:\n                                coords = json.loads(cz.polygon_coords)\n                                if coords and point_in_polygon(float(new_gw_x), float(new_gw_y), coords):\n                                    position_valid = True\n                                    zone_name_matched = cz.name\n                                    break\n                            except Exception:\n                                continue\n                    \n                    if position_valid:\n                        new_planned_gw = PlannedGateway(\n                            plan_id=current_plan.id,\n                            name=new_gw_name,\n                            x_position=float(new_gw_x),\n                            y_position=float(new_gw_y)\n                        )\n                        session.add(new_planned_gw)\n                        session.commit()\n                        zone_msg = f\" (in {zone_name_matched})\" if zone_name_matched else \"\"\n                        st.success(f\"Added {new_gw_name}{zone_msg}\")\n                        st.rerun()\n                    else:\n                        st.error(\"Position is outside all coverage zones. Gateways must be placed within defined coverage areas.\")\n            \n            # Auto-suggest gateways based on coverage zones\n            if coverage_zones:\n                st.markdown(\"**Auto-suggest by Coverage Zone**\")\n                \n                # Show summary of zones and gateway requirements\n                total_suggested = 0\n                zone_gateway_counts = []\n                for cz in coverage_zones:\n                    gw_count = calculate_gateways_for_zone(cz)\n                    zone_gateway_counts.append((cz, gw_count))\n                    total_suggested += gw_count\n                \n                with st.expander(\"Zone Gateway Requirements\", expanded=False):\n                    for cz, count in zone_gateway_counts:\n                        st.write(f\"**{cz.name}** (Â±{cz.target_accuracy}m): {count} gateways\")\n                \n                if st.button(f\"Auto-suggest {total_suggested} gateways for all zones\", type=\"primary\"):\n                    existing_gws = session.query(PlannedGateway).filter(\n                        PlannedGateway.plan_id == current_plan.id\n                    ).all()\n                    added_count = 0\n                    gw_num = len(existing_gws) + 1\n                    \n                    for cz, num_gateways in zone_gateway_counts:\n                        zone_bounds = get_coverage_zone_bounds(cz)\n                        if zone_bounds:\n                            zone_suggestions = suggest_gateway_positions_for_zone(\n                                zone_bounds, num_gateways, signal_range=effective_signal_range\n                            )\n                            for i, suggestion in enumerate(zone_suggestions):\n                                exists = any(\n                                    abs(pg.x_position - float(suggestion['x'])) < 1 and abs(pg.y_position - float(suggestion['y'])) < 1\n                                    for pg in existing_gws\n                                )\n                                if not exists:\n                                    new_planned_gw = PlannedGateway(\n                                        plan_id=current_plan.id,\n                                        name=f\"GW-{gw_num} ({cz.name})\",\n                                        x_position=float(suggestion['x']),\n                                        y_position=float(suggestion['y'])\n                                    )\n                                    session.add(new_planned_gw)\n                                    existing_gws.append(new_planned_gw)\n                                    added_count += 1\n                                    gw_num += 1\n                    \n                    session.commit()\n                    st.success(f\"Added {added_count} gateway positions across {len(coverage_zones)} zone(s)\")\n                    st.rerun()\n            else:\n                # Fallback to floor-based suggestion if no coverage zones\n                suggestions = suggest_gateway_positions(\n                    floor_width, floor_height, effective_recommendations[\"recommended\"],\n                    signal_range=effective_signal_range, floor=selected_floor\n                )\n                if st.button(f\"Auto-suggest {effective_recommendations['recommended']} gateway positions\"):\n                    existing_gws = session.query(PlannedGateway).filter(\n                        PlannedGateway.plan_id == current_plan.id\n                    ).all()\n                    added_count = 0\n                    for suggestion in suggestions:\n                        exists = any(\n                            abs(pg.x_position - float(suggestion['x'])) < 1 and abs(pg.y_position - float(suggestion['y'])) < 1\n                            for pg in existing_gws\n                        )\n                        if not exists:\n                            new_planned_gw = PlannedGateway(\n                                plan_id=current_plan.id,\n                                name=suggestion['name'],\n                                x_position=float(suggestion['x']),\n                                y_position=float(suggestion['y'])\n                            )\n                            session.add(new_planned_gw)\n                            added_count += 1\n                    session.commit()\n                    st.success(f\"Added {added_count} suggested gateway positions\")\n                    st.rerun()\n            \n            if planned_gateways:\n                st.markdown(\"**Current Planned Gateways**\")\n                \n                for gw in planned_gateways:\n                    with st.container():\n                        cols = st.columns([3, 2, 2, 1, 1])\n                        with cols[0]:\n                            st.markdown(f\"**{gw['name']}**\")\n                        with cols[1]:\n                            st.caption(f\"X: {gw['x']:.1f}m\")\n                        with cols[2]:\n                            st.caption(f\"Y: {gw['y']:.1f}m\")\n                        with cols[3]:\n                            if gw['is_installed']:\n                                st.markdown(\":green[Installed]\")\n                            else:\n                                st.markdown(\":blue[Planned]\")\n                        with cols[4]:\n                            if st.button(\"Delete\", key=f\"del_gw_{gw['id']}\"):\n                                pg = session.query(PlannedGateway).filter(PlannedGateway.id == gw['id']).first()\n                                if pg:\n                                    session.delete(pg)\n                                    session.commit()\n                                    st.rerun()\n            \n            st.divider()\n            st.subheader(\"Export Plan\")\n            \n            col_exp1, col_exp2 = st.columns(2)\n            \n            with col_exp1:\n                if st.button(\"Export as Installation Guide\"):\n                    export_gateways = session.query(PlannedGateway).filter(\n                        PlannedGateway.plan_id == current_plan.id\n                    ).order_by(PlannedGateway.id).all()\n                    guide_text = f\"\"\"# Gateway Installation Guide\n## {current_plan.name}\n### Floor: {floor_options[selected_floor_id]}\n### Target Accuracy: Â±{current_plan.target_accuracy}m\n\n## Planned Gateway Positions\n\n| Gateway | X Position | Y Position | Notes |\n|---------|------------|------------|-------|\n\"\"\"\n                    for pg in export_gateways:\n                        guide_text += f\"| {pg.name} | {pg.x_position:.1f}m | {pg.y_position:.1f}m | {pg.notes or ''} |\\n\"\n                    \n                    guide_text += f\"\"\"\n## Installation Notes\n\n1. Position each gateway as close to the planned coordinates as possible\n2. Ensure line-of-sight between gateways where possible\n3. Mount gateways at 2-3 meters height for optimal coverage\n4. Avoid placing near metal objects or water pipes\n5. After installation, use the Calibration Wizard to fine-tune accuracy\n\n## Coverage Requirements\n\n- Signal Range: {current_plan.signal_range}m\n- Minimum {effective_recommendations['minimum']} gateways required\n- {effective_recommendations['geometry_note']}\n\"\"\"\n                    \n                    st.download_button(\n                        \"Download Installation Guide\",\n                        guide_text,\n                        file_name=f\"gateway_installation_guide_{current_plan.name.replace(' ', '_')}.md\",\n                        mime=\"text/markdown\"\n                    )\n            \n            with col_exp2:\n                if st.button(\"Export as JSON\"):\n                    json_export_gateways = session.query(PlannedGateway).filter(\n                        PlannedGateway.plan_id == current_plan.id\n                    ).order_by(PlannedGateway.id).all()\n                    export_data = {\n                        \"plan_name\": current_plan.name,\n                        \"floor\": floor_options[selected_floor_id],\n                        \"floor_dimensions\": {\n                            \"width_m\": float(floor_width),\n                            \"height_m\": float(floor_height)\n                        },\n                        \"target_accuracy_m\": float(current_plan.target_accuracy),\n                        \"signal_range_m\": float(current_plan.signal_range),\n                        \"gateways\": [\n                            {\n                                \"name\": pg.name,\n                                \"x_m\": float(pg.x_position),\n                                \"y_m\": float(pg.y_position),\n                                \"is_installed\": pg.is_installed\n                            }\n                            for pg in json_export_gateways\n                        ]\n                    }\n                    \n                    st.download_button(\n                        \"Download JSON\",\n                        json.dumps(export_data, indent=2),\n                        file_name=f\"gateway_plan_{current_plan.name.replace(' ', '_')}.json\",\n                        mime=\"application/json\"\n                    )\n","path":null,"size_bytes":56277,"size_tokens":null}},"version":2}